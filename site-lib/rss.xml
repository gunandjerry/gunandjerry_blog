<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[건제리의 블로그]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>건제리의 블로그</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 11 Dec 2025 13:25:07 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 11 Dec 2025 13:25:05 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[구현 기록 인덱스]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/커스텀 어빌리티 태스크" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/커스텀 어빌리티 태스크" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/커스텀-어빌리티-태스크.html" class="internal-link" target="_self" rel="noopener nofollow">커스텀 어빌리티 태스크</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/초기화시 자동으로 GA를 부여하고 태그를 부착하는 커스텀 ASC 만들기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/초기화시 자동으로 GA를 부여하고 태그를 부착하는 커스텀 ASC 만들기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/초기화시-자동으로-ga를-부여하고-태그를-부착하는-커스텀-asc-만들기.html" class="internal-link" target="_self" rel="noopener nofollow">초기화시 자동으로 GA를 부여하고 태그를 부착하는 커스텀 ASC 만들기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/PlayMontageGameplayCue" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/PlayMontageGameplayCue" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/playmontagegameplaycue.html" class="internal-link" target="_self" rel="noopener nofollow">PlayMontageGameplayCue</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 플레이어 스탯 관리" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 플레이어 스탯 관리" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-플레이어-스탯-관리.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 플레이어 스탯 관리</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/상호작용, Interactable Component" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/상호작용, Interactable Component" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/상호작용,-interactable-component.html" class="internal-link" target="_self" rel="noopener nofollow">상호작용, Interactable Component</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼에 Dissolving 이펙트 입히기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼에 Dissolving 이펙트 입히기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼에-dissolving-이펙트-입히기.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼에 Dissolving 이펙트 입히기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼을 플레이어 캐릭터로 사용하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼을 플레이어 캐릭터로 사용하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼을-플레이어-캐릭터로-사용하기.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼을 플레이어 캐릭터로 사용하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼 페이셜 애니메이션" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼 페이셜 애니메이션" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼-페이셜-애니메이션.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼 페이셜 애니메이션</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/공격 반응성 개선하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/공격 반응성 개선하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/공격-반응성-개선하기.html" class="internal-link" target="_self" rel="noopener nofollow">공격 반응성 개선하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 장비 스왑, 착용 모션 동기화" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 장비 스왑, 착용 모션 동기화" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-장비-스왑,-착용-모션-동기화.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 장비 스왑, 착용 모션 동기화</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/참고자료/Procedural Dungeon 플러그인 분석" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/참고자료/Procedural Dungeon 플러그인 분석" href="0-발행완료/프로젝트/2504_f급헌터생존기/참고자료/procedural-dungeon-플러그인-분석.html" class="internal-link" target="_self" rel="noopener nofollow">Procedural Dungeon 플러그인 분석</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/동적 생성 미니맵" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/동적 생성 미니맵" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/동적-생성-미니맵.html" class="internal-link" target="_self" rel="noopener nofollow">동적 생성 미니맵</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 절차적 던전 생성" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 절차적 던전 생성" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-절차적-던전-생성.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 절차적 던전 생성</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Camera Shake Pattern" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Camera Shake Pattern" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/custom-camera-shake-pattern.html" class="internal-link" target="_self" rel="noopener nofollow">Custom Camera Shake Pattern</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Chaos Destruction을 사용한 오브젝트 부수기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Chaos Destruction을 사용한 오브젝트 부수기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/chaos-destruction을-사용한-오브젝트-부수기.html" class="internal-link" target="_self" rel="noopener nofollow">Chaos Destruction을 사용한 오브젝트 부수기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기)" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기)" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/플레이어-주변-액터-외곽선으로-강조하기-(custom-stencil로-외곽선-그리기).html" class="internal-link" target="_self" rel="noopener nofollow">플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기)</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Vignette Effect 매니저" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Vignette Effect 매니저" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/vignette-effect-매니저.html" class="internal-link" target="_self" rel="noopener nofollow">Vignette Effect 매니저</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Stencil Buffer 사용하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Stencil Buffer 사용하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/custom-stencil-buffer-사용하기.html" class="internal-link" target="_self" rel="noopener nofollow">Custom Stencil Buffer 사용하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 스턴 홀로그램 이펙트" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 스턴 홀로그램 이펙트" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-스턴-홀로그램-이펙트.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 스턴 홀로그램 이펙트</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Details Property Customization" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Details Property Customization" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/details-property-customization.html" class="internal-link" target="_self" rel="noopener nofollow">Details Property Customization</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Clothing Physics, 깃발" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Clothing Physics, 깃발" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/clothing-physics,-깃발.html" class="internal-link" target="_self" rel="noopener nofollow">Clothing Physics, 깃발</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Physics Swing Door, Chest" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Physics Swing Door, Chest" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/physics-swing-door,-chest.html" class="internal-link" target="_self" rel="noopener nofollow">Physics Swing Door, Chest</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/프롭 스폰 포인트, 스폰될 액터 미리보기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/프롭 스폰 포인트, 스폰될 액터 미리보기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/프롭-스폰-포인트,-스폰될-액터-미리보기.html" class="internal-link" target="_self" rel="noopener nofollow">프롭 스폰 포인트, 스폰될 액터 미리보기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/입력 가능한 텍스트보드 액터" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/입력 가능한 텍스트보드 액터" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/입력-가능한-텍스트보드-액터.html" class="internal-link" target="_self" rel="noopener nofollow">입력 가능한 텍스트보드 액터</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/스켈레탈 메쉬에 화살 박기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/스켈레탈 메쉬에 화살 박기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/스켈레탈-메쉬에-화살-박기.html" class="internal-link" target="_self" rel="noopener nofollow">스켈레탈 메쉬에 화살 박기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메쉬 위에 비디오 재생하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메쉬 위에 비디오 재생하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메쉬-위에-비디오-재생하기.html" class="internal-link" target="_self" rel="noopener nofollow">메쉬 위에 비디오 재생하기</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/바닥 메쉬에 Surface Type 추가하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/바닥 메쉬에 Surface Type 추가하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/기능-설명서/바닥-메쉬에-surface-type-추가하기.html" class="internal-link" target="_self" rel="noopener nofollow">바닥 메쉬에 Surface Type 추가하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/기능-설명서/treasurebookshelf-액터를-통해-랜덤-아이템-스폰하기.html" class="internal-link" target="_self" rel="noopener nofollow">TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기</a>]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-기록-인덱스.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 기록 인덱스.md</guid><pubDate>Thu, 11 Dec 2025 13:24:46 GMT</pubDate></item><item><title><![CDATA[브리지(Bridge) 패턴]]></title><description><![CDATA[두 개 이상의 서로 다른 독립적인 개념(기능)이 조합되어야 하는 클래스를 만들 때, 각 개념(기능)별로 객체를 나누고 has-a 관계로 소유하게 함으로써 조합을 구현하는 것. 클래스 폭발(한 클래스의 크기가 너무 커지는 것)을 막고 의존성을 줄이기 위한 방법이다.
형태는 <a data-tooltip-position="top" aria-label="0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/전략(Strategy) 패턴" data-href="0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/전략(Strategy) 패턴" href="0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/전략(strategy)-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">전략 패턴</a>과 유사한데, 전략 패턴이 '알고리즘을 교체해가며 쓰는 것'에 집중한다면 브리지 패턴은 '수평적으로 기능을 확장'하는 것에 집중한다.꼴이 유사한 디자인 패턴을 명확히 구분해야 하는 이유는?
디자인 패턴은 단순히 코드를 보기 좋게, 수정하기 쉽게, 협업이 수월하게 만드는 것 뿐만이 아니라 이렇게 코드를 작성한 의도와 방향성까지 알려준다.
<br><img alt="♣VaultStorage/attachment/Pasted image 20251202150603.png" src="♣vaultstorage/attachment/pasted-image-20251202150603.png" target="_self" style="width: 450px; max-width: 100%;">마법 공격 스킬을 정의한다고 해보자.
(1) 스킬의 형태: 미사일 형태로 발사됨, 일정 범위 안에서 터트림
(2) 스킬의 속성: 불, 물두 가지 요소를 조합해서 스킬을 만든다고 한다면 2x2 = 4개의 스킬 타입이 만들어지며, 요소가 늘어날 때마다 경우의 수는 급격하게 늘어나게 된다.이번엔 스킬의 형태를 메인 요소로 삼고 나머지 요소는 브리지 패턴으로 소유하게 해보자.class Element { ... };
class FireElement : public Element { ... }; class Spell
{
protected: Element* element;
public: virtual void Cast() abstract;
}; class MissileSpell : public Spell
{
protected: float speed;
public: virtual void Cast() override { ... };
}; class ExplosionSpell : public Spell
{
protected: float radius;
public: virtual void Cast() override { ... };
};
이제 스킬 캐스트의 주체는 현재 스펠이 무엇이고, 어떤 요소들이 조합되어 있는지 알 필요 없이 Cast()만 호출하면 된다.]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/브리지(bridge)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/브리지(Bridge) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:21:20 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[빌더(Builder) 패턴]]></title><description><![CDATA[객체를 생성할 때 수 많은 옵션이 제공되는 경우, 이를 모두 매개변수로 다루기가 매우 번거롭다. 대신 '빌더'를 두고 이 빌더의 메서드로 각각의 옵션을 지정한 후 빌더를 통해 최종적인 객체를 생성해내는 것을 빌더 패턴이라고 부른다.일반적으로 의존성 역전을 위해 <a data-tooltip-position="top" aria-label="0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/팩토리 메서드(Factory Method) 패턴" data-href="0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/팩토리 메서드(Factory Method) 패턴" href="0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/팩토리-메서드(factory-method)-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">팩토리 메서드 패턴</a>을 기반으로 범용 메서드를 가진 추상 빌더를 두고 이를 상속해 구체적인 빌더 클래스를 정의하여 사용한다.설계도를 구성할 땐 체이닝 기법(옵션을 지정하는 메서드가 this를 반환하여 바로 다음 메서드 호출로 연결될 수 있게 하는 것)을 사용하면 편리하다. 단, 이는 라인 디버깅을 어렵게 만든다.<br><img alt="♣VaultStorage/attachment/Pasted image 20251202111600.png" src="♣vaultstorage/attachment/pasted-image-20251202111600.png" target="_self" style="width: 625px; max-width: 100%;">위 구조는 의존성을 최대한 줄이기 위해 (1) 객체를 생성하는 빌더와 (2) 빌더를 통해 객체를 설계하는 디렉터를 두고 클라이언트는 큰 틀에서 무엇을 원하는 지만 요구하도록 한다.이는 한 가지 예시일 뿐 모든 빌더 패턴이 이런 구조를 가지지는 않는다. 로우 레벨에선 클라이언트에 노출되지 않기 때문에 여러 구체적인 옵션을 각각 달아주는 메서드들을 직접 호출하는 편이 편리한 것 같다.아래와 같은 여러 옵션, 멤버를 가진 클래스가 있다고 해보자.class Computer
{
public: Computer(string cpu, string gpu, string ssd) : cpu(cpu), gpu(gpu), ssd(ssd) {} string cpu; string gpu; string ssd;
};
빌더 패턴을 사용하지 않는다면, 다음과 같이 컴퓨터를 생성하기 위해 매개변수로 옵션을 각각 지정해줘야 한다.Computer* MyComputer = new Computer("Inter I7", "None", "2TB");
이 과정은 매우 의존성이 높고 번거로우며, 실수를 하기도 쉽다.대신 컴퓨터 빌더가 번거로운 생성 작업을 대신 수행해주도록 해보자.class ComputerBuilder
{
protected: Computer* computer{ nullptr }; public: virtual ~ComputerBuilder() = default; virtual ComputerBuilder&amp; Build() abstract; virtual Computer* Get() abstract; virtual ComputerBuilder&amp; AttachCPU() abstract; virtual ComputerBuilder&amp; AttachGPU() abstract; virtual ComputerBuilder&amp; AttachSSD() abstract;
}; class OfficeComputerBuilder : public ComputerBuilder
{
public: virtual ComputerBuilder&amp; Build() { computer = new Computer; return *this; } virtual Computer* Get() { return computer; } virtual ComputerBuilder&amp; AttachCPU() override { computer-&gt;cpu = "Intel i5"; } virtual ComputerBuilder&amp; AttachGPU() override { computer-&gt;gpu = "GTX750ti"; } virtual ComputerBuilder&amp; AttachSSD() override { computer-&gt;ssd = "500GB"; }
}; class GamingComputerBuilder : public ComputerBuilder
{
public: virtual ComputerBuilder&amp; Build() { computer = new Computer; return *this; } virtual Computer* Get() { return computer; } virtual ComputerBuilder&amp; AttachCPU() override { computer-&gt;cpu = "Intel i9"; } virtual ComputerBuilder&amp; AttachGPU() override { computer-&gt;gpu = "RTX4060"; } virtual ComputerBuilder&amp; AttachSSD() override { computer-&gt;ssd = "2TB"; }
};
이제 사용자는 빌더를 통해 매우 직관적이고 편리하게 컴퓨터 객체를 만들 수 있다.OfficeComputerBuilder builder; Computer* MyComputer = builder.Build().AttachCPU().AttachSSD().Get();
만약 이 동작조차 추상화하고싶다면 Director 클래스를 두어야 한다.class ComputerBuildingDirector
{ ComputerBuilder* builder;
public: ComputerBuildingDirector(ComputerBuilder* builder) : builder(builder) {} Computer* BuildComputerWithGPU() { if (!builder) return nullptr; return builder-&gt;Build().AttachCPU().AttachGPU().AttachSSD().Get(); } Computer* BuildComputerWithoutGPU() { if (!builder) return nullptr; return builder-&gt;Build().AttachCPU().AttachSSD().Get(); }
}; void CreateNewComputer()
{ OfficeComputerBuilder builder; ComputerBuildingDirector director(&amp;builder); Computer* MyComputer = director.BuildComputerWithoutGPU();
}
]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/빌더(builder)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/빌더(Builder) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:21:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프로토타입(Prototype) 패턴]]></title><description><![CDATA[객체 스스로가 자신을 복제하도록 하는 생성 패턴.
외부에서 수행하는 객체의 복사는 번거롭고 접근제어자에 의해 아예 불가능한 경우도 있다. 무엇보다 복제할 타입에 대한 정보를 알고 있어야 하므로 의존성이 크다.그러나 상위 클래스의 가상 복제 함수를 통해 스스로 복제 후 새로운 객체를 반환하는 로직이 있다면 사용자는 타입에 대한 정보 없이도 객체를 마음껏 복제할 수 있다.<img alt="♣VaultStorage/attachment/Pasted image 20251202122957.png" src="♣vaultstorage/attachment/pasted-image-20251202122957.png" target="_self" style="width: 575px; max-width: 100%;">class Shape
{
protected: float x, y; string color; public: Shape(float x, float y, string color) : x(x), y(y), color(color) {}
}; class Rectangle : public Shape
{
protected: float width, height; public: Rectangle(float x, float y, string color, float width, float height) : Shape(x, y, color), width(width), height(height) {}
}; class Circle : public Shape
{
protected: float radius; public: Circle(float x, float y, string color, float radius) : Shape(x, y, color), radius(radius) {}
};
위와 같이 멤버 변수들이 은닉된 클래스를 여러 개 복제해야 한다고 해보자.프로토타입 패턴을 사용하지 않는다면 복제된 객체가 필요한 경우 구체적인 타입에 대해 변수를 직접 복사하여 넣거나 복사생성을 하거나 해야 한다.
이 과정에서 사용자가 구체적인 자식 타입에 대한 정보를 알아야 하므로 의존성이 발생한다.하지만 아래와 같이 Clone() 메서드를 추가한다고 해보자.class Shape
{
protected: float x, y; string color; public: Shape(float x, float y, string color) : x(x), y(y), color(color) {} virtual Shape* Clone() abstract;
}; class Rectangle : public Shape
{
protected: float width, height; public: Rectangle(float x, float y, string color, float width, float height) : Shape(x, y, color), width(width), height(height) {} virtual Shape* Clone() override { return new Rectangle(x, y, color, width, height); }
}; class Circle : public Shape
{
protected: float radius; public: Circle(float x, float y, string color, float radius) : Shape(x, y, color), radius(radius) {} virtual Shape* Clone() override { return new Circle(x, y, color, radius); }
};
이제 사용자는 Shape라는 최상위 타입만을 다루면서 구체적인 개별 객체를 자유롭게 복사할 수 있다.// Shape* shape1 = new Rectangle(10, 10, "Red", 20, 20); Shape* shape2 = shape1-&gt;Clone();
]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/프로토타입(prototype)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/프로토타입(Prototype) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:20:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[퍼사드(Facade) 패턴]]></title><description><![CDATA[복잡한 하위 시스템을 숨기고 사용자에게 단순하게 통합된 인터페이스를 제공하는 것.
Facade는 건물의 정면(외관)을 뜻한다. 근데 이게 정말 디자인패턴이라고 이름을 붙일 만한 방법론일까?<img alt="♣VaultStorage/attachment/Pasted image 20251202183847.png" src="♣vaultstorage/attachment/pasted-image-20251202183847.png" target="_self" style="width: 650px; max-width: 100%;">// 복잡하고 다양한 하위 시스템들
class Renderer {};
class SoundSystem {};
class PhysicsEngine {}; // Facade 클래스
class GameEngineFacade
{
protected: Renderer* renderer; SoundSystem* sound; PhysicsEngine* physics; public: GameEngineFacade() { renderer = new Renderer; sound = new SoundSystem; physics = new PhysicsEngine; } virtual void StartGame() { renderer-&gt;InitRenderer(); sound-&gt;InitSoundSystem(); }
}; class GameEngineFacadeWithPhysics : public GameEngineFacade
{
public: virtual void StartGame() { GameEngineFacade::StartGame(); physics-&gt;InitPhysicsEngine(); physics-&gt;CreatePhysicsFrame(); }
};
이제 사용자는 Facade의 StartGame()만 호출하면 된다.]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/퍼사드(facade)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/퍼사드(Facade) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:20:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[팩토리 메서드(Factory Method) 패턴]]></title><description><![CDATA[객체의 생성을 팩토리 클래스에 위임하고, 팩토리 클래스의 상속을 통해 다양한 객체의 생성을 처리하는 생성 패턴.<img alt="♣VaultStorage/attachment/Pasted image 20251201160536.png" src="♣vaultstorage/attachment/pasted-image-20251201160536.png" target="_self" style="width: 650px; max-width: 100%;">단적으로 말해 new 키워드로 어떤 구체적인 객체를 생성하려면 반드시 해당 타입에 대해 알고있어야 한다. 예를 들어, 다음과 같이 여러 클래스의 캐릭터를 생성하는 상황이라고 해보자.class CharacterClass
{
protected: float phys_attack{ 0 }; float magic_attack{ 0 };
public: CharacterClass(int phys_attack, int magic_attack) : phys_attack(phys_attack), magic_attack(magic_attack) {} virtual ~CharacterClass() = default;
}; class WarriorClass : public CharacterClass
{
public: WarriorClass() : CharacterClass(10, 0) {}
}; class MagicianClass : public CharacterClass
{
public: MagicianClass() : CharacterClass(0, 10) {}
};
유저가 클래스 중 한 가지를 골라 해당 클래스의 캐릭터 인스턴스를 생성하게 하려면 어떻게 해야 할까?
팩토리 패턴을 사용하지 않는다면, 아래와 같이 만들어야 한다.vector&lt;CharacterClass*&gt; Players;
void AddNewPlayer(EClassType class_type)
{ switch (class_type) { case EClassType::Warrior: Players.push_back(new WarriorClass); break; case EClassType::Magician: Players.push_back(new MagicianClass); break; }
}
이 코드의 문제점은 클래스가 하나 추가될 때마다 함수의 내용이 변해야 한다는 것이다. OCP(개방-폐쇄 원칙)에 반한다.대신 팩토리 클래스에게 생성에 대한 책임을 위임하면 어떨까?class CharacterFactory
{
public: virtual ~CharacterFactory() = default; virtual CharacterClass* CreateCharacter() abstract;
}; class WarriorCharacterFactory : public CharacterFactory
{
public: virtual CharacterClass* CreateCharacter() override { return new WarriorClass; }
}; class MagicianCharacterFactory : public CharacterFactory
{
public: virtual CharacterClass* CreateCharacter() override { return new MagicianClass; }
};
이제 플레이어 캐릭터를 생성하는 함수에선 직접 캐릭터 인스턴스를 생성하지 않아도 된다. 따라서 플레이어가 고른 클래스의 타입을 몰라도 된다.
대신 플레이어가 고른 클래스에 알맞은 팩토리만 전달하면 된다. 이를 의존성의 역전이라고 부른다.void AddNewPlayer(CharacterFactory* factory)
{ Players.push_back(factory-&gt;CreateCharacter());
}
이제 클래스를 아무리 늘려도 그 클래스를 생성하는 팩토리만 정의하면 다른 곳은 건들 필요가 없어진다.
추가로 생성 후 초기화 작업도 팩토리가 담당할 수 있을 것이다. 추상 팩토리(Abstract factory) 패턴
굳이 왜 이름을 나눠 놓은 건지는 모르겠지만, 하나의 팩토리 클래스가 여러 종류의 '서로 어울리는 집합'의 객체들을 생성한다면 이를 추상 팩토리 패턴이라고 부른다.
]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/팩토리-메서드(factory-method)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/팩토리 메서드(Factory Method) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:20:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[전략(Strategy) 패턴]]></title><description><![CDATA[수평적인 기능 확장 및 전환을 위해, 각각의 구체화된 방식을 담당하는 '전략 클래스'들을 동적으로 교체해가며 동일한 방식으로 쓸 수 있도록 설계하는 것.
사실상 전략이라고 불리는 '구체화된 기능'으로서의 객체를 담는 부모 포인터 변수를 has-a로 가지고 있는 게 전부다. 게임에서도 유용하게 사용된다. <img alt="♣VaultStorage/attachment/Pasted image 20251202143648.png" src="♣vaultstorage/attachment/pasted-image-20251202143648.png" target="_self" style="width: 450px; max-width: 100%;">아래와 같은 결제 시스템이 있다고 해보자. class OrderSystem
{
public: void Order(EOrderType type, float price) { switch (type) { case EOrderType::Card: { CardPaymentSystem card; card-&gt;PayByCard(price); break; } case EOrderType::KakaoPay: { KakaoAPI kakao; kakao-&gt;PayWithKakao(price * 0.95f); break; } case EOrderType::SamsungPay: { SamsungAPI samsung; samsung-&gt;PayUsingSamsungWallet(price * 0.9f); break; } } }
};
의존성이 매우 심한 나쁜 코드다. 두 가지 개선 방법이 떠오른다.
각각의 서로 사용 방법이 다른 결제 API들을 어댑터 패턴으로 동일한 방법으로 쓸 수 있게 캡슐화한다.
결제 방법은 의존성 주입과 전략 패턴을 사용해 바꿔가면서 사용할 수 있게 한다.
class KakaoPaymentProcessor : public PaymentMethod
{
public: virtual void Pay(float price) override { KakaoPaymentProcessor kakao; kakao-&gt;Pay(price * 0.95f); }
}; class OrderSystem
{
protected: PaymentMethod* method;
public: void SetMethod(PaymentMethod* _method) { method = _method; } void Order(float price) { method-&gt;Pay(price); }
};
KakaoPaymentProcessor kakao;
OrderSystem order_system; order_system.SetMethod(&amp;kakao);
order_system.Order(100);
이제 OrderSystem은 강한 커플링에서 해방되었으며, 얼마든지 새로운 결제 방식이 추가될 수 있다. ]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/전략(strategy)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/전략(Strategy) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:20:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[어댑터(Adaptor) 패턴]]></title><description><![CDATA[서로 호환되지 않는 두 인터페이스가 있을 때, 한 쪽을 어댑터 클래스로 래핑하여 호환되도록 하는 것.
사실 서로 호환되지 않는 두 클래스를 서로 호환되게 하기 위해 중간 매개체를 두는 건 디자인 패턴이라고 부르기도 어려운 당연한 일이다. 하지만 여기서 핵심은 이러한 '중간 매개 과정'을 기존 클래스의 상속으로 구현하여 의존성을 만들지 않는 것에 있다.<img alt="♣VaultStorage/attachment/Pasted image 20251202134803.png" src="♣vaultstorage/attachment/pasted-image-20251202134803.png" target="_self" style="width: 575px; max-width: 100%;">예를 들어 외부 결제 API가 있고, 결제 처리 프로세스가 있다고 해보자.class KakaoPayAPI
{
public: void Pay(int amount) { std::cout &lt;&lt; "카카오페이 결제: " &lt;&lt; amount &lt;&lt; "원" &lt;&lt; std::endl; }
}; class PaymentProcessor
{
public: void ProcessPayment(const std::string&amp; method, int amount) { if (method == "CardPay") { std::cout &lt;&lt; "카드 결제: " &lt;&lt; amount &lt;&lt; "원" &lt;&lt; std::endl; } else if (method == "KakaoPay") { KakaoPayAPI kakao; kakao.Pay(amount); } }
};
이 코드의 문제점은 PaymentProcessor가 각각의 외부 결제 API 클래스를 알고 있어야 하고, 결제 방법이 추가될 때마다 코드가 수정되어야 한다는 것이다.하지만 어댑터 패턴과 인터페이스를 사용하면 아래와 같이 간단하게 정리된다.class KakaoPayAPI
{
public: void Pay(int amount) { std::cout &lt;&lt; "카카오페이 결제: " &lt;&lt; amount &lt;&lt; "원" &lt;&lt; std::endl; }
}; class PaymentMethod
{
public: virtual void Pay(int amount) abstract;
}; class KakaoPayPaymentMethod : public PaymentMethod
{ KakaoPayAPI kakao_module;
public: virtual void Pay(int amount) override { kakao_module.Pay(amount); }
}; class PaymentProcessor
{
public: void ProcessPayment(PaymentMethod* method, int amount) { method-&gt;Pay(amount); }
};
]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/어댑터(adaptor)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/어댑터(Adaptor) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:19:59 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[복합체(Composite) 패턴]]></title><description><![CDATA[트리 구조로 만들어지는 객체들의 구조 안에서, 클라이언트가 그 구조나 타입을 신경쓰지 않고 명령을 내릴 수 있도록 재귀적인 객체들의 명령 하달 구조를 만드는 것.
파일 탐색기의 폴더 구조를 생각하면 된다.<img alt="♣VaultStorage/attachment/Pasted image 20251202174605.png" src="♣vaultstorage/attachment/pasted-image-20251202174605.png" target="_self" style="width: 450px; max-width: 100%;">파일 탐색기를 만든다고 해보자. 사용자가 최상위 폴더의 GetSize()를 호출했을 때, 그 폴더 안에 있는 모든 파일들의 용량 합계를 구하고 싶다.복합체 패턴을 사용하지 않는다면 아래와 같이 폴더 클래스 안에 자식의 타입에 따라 별도로 관리하기 위한 배열을 선언해야 한다.class File
{ string file_name; int file_size;
public: File(string n, int s) : file_name(n), file_size(s) {} int GetSize() const { return file_size; }
}; class Directory
{ std::string directory_name; std::vector&lt;File*&gt; files; std::vector&lt;Directory*&gt; sub_dirs;
public: Directory(std::string n) : directory_name(n) {} void AddFile(File* f) { files.push_back(f); } void AddDir(Directory* d) { sub_dirs.push_back(d); } int GetSize() { int total = 0; for (auto* file : files) { total += file-&gt;GetSize(); } for (auto* dir : sub_dirs) { total += dir-&gt;GetSize(); } return total; }
};
구체적인 타입에 대한 커플링이 매우 심한 코드다. 예컨대 특수취급을 해야 하는 바로가기 파일같은 것이 추가된다면 대대적인 공사를 해야 한다.폴더도 파일도, 어쩌면 훗날 추가될 지 모르는 다른 타입도 결국 하나의 노드라는 점은 똑같다. 그렇다면 이들을 하나의 인터페이스로 묶어 관리해보자.class FileSystemNode
{
public: virtual ~FileSystemNode() = default; virtual int GetSize() const abstract; virtual string GetName() const abstract;
}; // File과 Shortcut은 Leaf가 된다.
class File : public FileSystemNode
{ string file_name; int file_size;
public: File(string n, int s) : file_name(n), file_size(s) {} virtual int GetSize() const override { return file_size; } virtual string GetName() const override { return file_name; }
};
class Shortcut : public FileSystemNode
{ string file_name; FileSystemNode* go_to;
public: Shortcut(std::string n, FileSystemNode* g) : file_name(n), go_to(g) {} virtual int GetSize() const override { return 1; } virtual string GetName() const override { return file_name; }
}; class Directory : public FileSystemNode
{ std::string directory_name; std::vector&lt;FileSystemNode*&gt; childs;
public: Directory(std::string n) : directory_name(n) {} void Add(FileSystemNode* node) { childs.push_back(node); } virtual int GetSize() const override { int total = 0; for (auto* node : childs) { total += node-&gt;GetSize(); } } virtual string GetName() const override { return directory_name; }
};
이제 어떤 타입이 추가되어도 디렉토리 클래스를 건들 이유가 없다.]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/복합체(composite)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/복합체(Composite) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:19:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데코레이터(Decorator) 패턴]]></title><description><![CDATA[베이스 객체를 내부에 소유하고 있는 장식(껍데기) = 데코레이터로 베이스 객체를 계속 겹겹이 싸가면서 확장하는 방법.
상속 없이 기능을 확장할 수 있는 방법이지만, 코드가 다소 지저분해진다.<img alt="♣VaultStorage/attachment/Pasted image 20251202180952.png" src="♣vaultstorage/attachment/pasted-image-20251202180952.png" target="_self" style="width: 550px; max-width: 100%;">데코레이터 패턴은 더는 상속이 불가능한 상황 등에서 불가피하게 선택하는 면이 강하다. 그래서 예시를 생각해내기가 마땅치 않다. 다음 예시는 명백하게 더 나은 방법이 있지만 데코레이터 패턴을 설명하기 위해 들었다.총을 만든다고 가정해보자. 총에는 조준경이나 소음기를 달 수도 있고, 총알을 폭발탄으로 바꿀 수도 있다. 게다가 총의 종류도 라이플, SMG 등 다양하다.
만약 아무런 디자인 패턴을 쓰지 않는다면, 각각의 조합에 대한 클래스들을 모두 만들어야 할 것이다.class Gun { ... };
class Rifle : public Gun { ... };
class RifleWithScope : public Gun { ... };
class SMGWithSilence : public Gun { ... };
"왜 복합체 패턴이나 다른 방법을 사용하지 않나요?"라고 물어보지는 말고, 데코레이터 패턴을 사용해보자.먼저 데코레이터를 정의한다. 데코레이터도 Gun을 상속해야지만 사용자는 이 인터페이스가 실제로는 데코레이터인지, 총인지 몰라도 된다.class Gun
{
public: virtual ~Gun() = default; virtual void Fire() abstract; virtual int GetDamage() abstract;
}; // Gun의 타입들
class Rifle : public Gun
{ virtual void Fire() override { cout &lt;&lt; "라이플 빵야\n"; } virtual int GetDamage() override { return 10; }
};
class SMG : public Gun
{ virtual void Fire() override { cout &lt;&lt; "SMG 두두두두\n"; } virtual int GetDamage() override { return 2; }
}; // 데코레이터
class GunAccessory : public Gun
{
protected: Gun* WrappedGun;
public: GunAccessory(Gun* gun) : WrappedGun(gun) {} // 포장 // 기본 동작은 내용물인 무기에게 위임한다. virtual void Fire() override { WrappedGun-&gt;Fire(); } virtual int GetDamage() override { return WrappedGun-&gt;GetDamage(); }
}; class Scope : public GunAccessory
{
public: using GunAccessory::GunAccessory; virtual void Fire() override { cout &lt;&lt; "조준..."; WrappedGun-&gt;Fire(); }
}; class ExplosiveAmmo : public GunAccessory
{
public: using GunAccessory::GunAccessory; virtual int GetDamage() override { return 20 + WrappedGun-&gt;GetDamage(); }
}; int main()
{ Gun* MyGun = new Rifle; MyGun = new Scope(MyGun); // 스코프 장착 MyGun = new ExplosiveAmmo(MyGun); // 폭발탄약 장착
}
]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/데코레이터(decorator)-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/데코레이터(Decorator) 패턴.md</guid><pubDate>Thu, 11 Dec 2025 13:19:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[의존성 주입 패턴 (Dependency Injection Pattern)]]></title><description><![CDATA[고수준 모듈이 저수준 모듈을 사용할 때 이를 직접 생성하거나 제3자를 통해 찾아오는 대신,
고수준 모듈을 생성 또는 초기화하는 외부로부터 저수준 모듈을 '주입받아' 사용하는 패턴. 핵심은 의존성을 외부에서 동적으로 만들어내고 관리하는 것이다.기본적으로 <a class="internal-link" data-href="0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/의존성 역전 (Dependency Inversion Principle).md" href="0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/의존성-역전-(dependency-inversion-principle).html" target="_self" rel="noopener nofollow">의존성 역전 원칙</a>이 지켜진다는 전제로 구현되며, (1) 확장과 변경에 용이하게 하고, (2) 의존성을 명시적으로 드러내기 위해 사용한다.저수준 모듈을 외부에서 생성 또는 가져와 주입하기 때문에 보통은 해당 모듈의 수명까지 외부에서 관리하게 된다. 생성자 주입으로 주입된 객체를 주입의 대상만 사용하게끔 만들고 대상이 소멸할 때 주입된 객체도 같이 소멸하게 하는 방법도 있겠지만, 직관성이 크게 떨어지고 동적으로 의존성을 관리하는 의미가 퇴색되므로 좋은 방법이라고 할 수 없다.실제 사용법은 매우 간단하다. 생성자 또는 초기화 함수에서 인자로 주입할 객체를 전달하거나, 혹은 특정 함수를 호출할 때 사용할 객체를 인자로 전달하는 게 전부다.
의존성이 명확하게 드러난다: 의존성은 적으면 적을 수록 좋지만, 줄이는 데에는 한계가 있다. 의존은 반드시 발생한다. 그렇다면 의존성이 명확하게 드러나 유지보수에 들일 시간과 노력이 적어지는 쪽이 좋다.
의존성 주입 패턴은 이 객체를 생성하는데, 혹은 특정한 함수를 호출하는데 필요한 것이 무엇인지 호출을 하는 쪽에서 바로바로 알 수 있게 만들기 때문에 내부의 구현 로직을 전혀 몰라도 어떤 객체에 의존하는 지 명확하게 알 수 있다.
의존성이 줄어든다: 객체를 주입당하는 쪽은 그냥 주입해준 객체를 쓰고나서 신경을 끄면 된다.
테스트하기 쉽다: 테스트를 하고 싶다면 그냥 테스트용 Mock 냄비 객체를 주입해보면 된다.
단점이 없는 것은 아니다. 가장 큰 문제는 주입되는 개체의 수명 관리 문제다.
위에서도 말했지만 주입된 객체의 수명을 주입을 당한 객체가 직접 관리하는 것은 의존성 주입 패턴의 의미를 크게 퇴색시키는 좋지 못 한 방법이다.
그렇다면 외부에서 수명을 관리해주어야 하는데, 문제는 자칫 잘못했다간 주입된 객체의 수명이 그것을 사용하는 객체보다 먼저 끝나서 댕글링 포인터가 발생할 수도 있다는 것.이 문제의 가장 쉬운 해결법은 스마트 포인터를 쓰는 것이지만, 일반 포인터보다 비용이 큰 건 어쩔 수 없다.]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/의존성-주입-패턴-(dependency-injection-pattern).html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/의존성 주입 패턴 (Dependency Injection Pattern).md</guid><pubDate>Thu, 11 Dec 2025 13:19:10 GMT</pubDate></item><item><title><![CDATA[쓸모있는 잡다한 지식]]></title><description><![CDATA[
타입의 사이즈로 0은 허용되지 않는다. 가상함수도, 멤버변수도 없는 빈 깡통 클래스라도 사이즈는 1이다.
]]></description><link>0-발행완료/c,-c++/기타/쓸모있는-잡다한-지식.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/쓸모있는 잡다한 지식.md</guid><pubDate>Thu, 11 Dec 2025 13:17:48 GMT</pubDate></item><item><title><![CDATA[메모리 레이아웃]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20251209145723.png" src="♣vaultstorage/attachment/pasted-image-20251209145723.png" target="_self" style="width: 255px; max-width: 100%;">코드들이 담기는 영역. 당연히 Read-only이다. 별도의 공간을 배정받아야 하는 데이터들이 담기는 영역.
예컨대 전역·정적 변수들은 어떤 함수에서 접근하든 동일한 위치에 있어야 한다. 또한, 중복 선언이 필요하지 않은 문자열 리터럴도 한 번만 선언하고 재활용하면 되기 때문에 별도의 공간이 필요하다.데이터 영역은 크게 세 가지 파트로 나뉜다.
rodata (read-only data) 영역 : 상수, 문자열 리터럴 등의 Read-only 데이터가 담긴다. 읽기 전용이므로 문자열 리터럴의 주소를 포인터로 담는 등의 동작은 차단당한다.
data 영역 : 초기화된 전역변수와 정적 변수를 저장한다.
bss (block started by symbol) 영역 : 초기화되지 않은 전역변수와 정적 변수를 저장한다. 이 영역에 저장된 변수들은 main이 시작되기 전 모두 0 초기화가 이루어진다. 근본적으로 두 메모리 공간은 완벽하게 동일한 공간으로 서로 반대쪽 방향에서 마주보는 방향으로 메모리를 점점 점유해나간다. 차이는 '어떻게 점유하느냐'에서 발생한다.스택은 가상 메모리 공간의 가장 높은 주소부터 스택프레임을 쌓아가며 점유 영역을 넓혀가고, 힙은 데이터(BSS) 영역의 바로 다음 주소부터 필요하다면 자신이 사용하는 주소 범위를 점점 늘려가면서 점유 영역을 넓혀간다. 스택 메모리는 배정된 가상 메모리 공간에서 가장 높은 주소부터 시작해 낮은 주소 방향으로 SP(Stack Pointer) 레지스터를 단순이 이동시켜가면서 점유하고 있는 주소 범위를 넓힌다.
즉, 새 지역변수가 선언되면 SP의 주소를 내려 그만큼을 더 사용하고, 스택 프레임이 제거되면 그만큼 SP의 주소를 높여 줄여나가게 된다.반면 힙 메모리는 데이터(BSS) 영역의 바로 다음 주소에서 시작해 높은 주소 방향으로 최대 주소를 늘려가면서 점유 범위를 넓힌다.
예컨대 현재 힙이 사용하는 주소 범위가 100mb이며 100mb의 공간을 모두 사용하고 있는데 20mb 만큼의 힙 할당 요청이 들어오면, 최대 주소를 20mb 만큼 더 넓히는 것이다.
할당은 힙 영역이 사용할 수 있는 주소 공간 안에서 임의의 빈 공간을 찾아 해당 영역에 대한 점유를 선언하는 방식이다. 이런 방식은 필연적으로 단편화를 발생시키므로 탐색, 정리의 과정이 추가되어 스택보다 훨씬 느릴 수밖에 없다.힙 메모리로 배정된 영역이 다시 줄어들기도 할까?
결론부터 말해서 줄어들기도 한다. 하지만 추가 공간이 필요해 사용하는 주소 범위를 늘리는 동작은 쉽게 일어나도 다시 줄이는 동작은 잘 일어나지 않는다.
왜냐하면 힙 메모리 안에는 임의 위치에 산발적으로 할당된 영역들이 배치되므로, 주소 범위를 줄이려면 우선 힙 공간이 충분히 정리되어 끝 부분이 비어있어야 한다. 또한 그 남은 공간을 다시 쓸 것도 고려해야 하기 때문에 충분히 넓은 크기가 아니라면 줄이는 동작을 호출하지 않는다.
두 영역은 언젠가 중간에서 서로 만나게 되며, 이 때 메모리 포화가 일어나게 된다. SP 포인터가 힙이 점유중인 공간에 막혀 더이상 나아갈 수 없다면 스택 오버플로우가 발생하고, 힙에 더는 할당할 수 있는 주소공간이 남아있지 않고, 최대 주소를 늘릴 수도 없다면 할당 실패 예외가 던져지는 것이다.Note
흔히 스택 영역의 크기가 컴파일 타임에 고정된다고 착각하곤 한다. 이는 사실이 아니며, 컴파일 타임에 고정되는 건 어디까지나 각 스택프레임의 크기, 즉 이 함수가 호출됐을 때 사용할 스택 프레임의 크기이다.
OS의 입장에선 힙이든 스택이든 가상 메모리라는 거대한 주소 공간 안에서 '여기부터 여기까지는 내가 쓴다'고 점유를 선언하고, 실제 물리 메모리(페이지)를 연결(매핑)하는 행위임은 본질적으로 동일하다.]]></description><link>0-발행완료/컴퓨터과학/메모리-레이아웃.html</link><guid isPermaLink="false">0 발행완료/컴퓨터과학/메모리 레이아웃.md</guid><pubDate>Thu, 11 Dec 2025 13:17:15 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[가상 함수 (Virtual function)]]></title><description><![CDATA[OOP의 핵심인 다형성, 그 중에서도 가장 중요하다고 할 수 있는 서브타입 다형성(런타임 다형성, 오버라이딩)을 구현하기 위한 개념.C++에선 부모 클래스의 함수 서명을 자식 클래스에서 그대로 사용할 경우, 부모 클래스의 함수는 숨겨지게 된다. 예컨대 Foo() 라는 함수가 부모와 자식 모두에 존재하면, 자식 객체를 통해 Foo()를 호출하면 자식의 Foo()가 호출되게 된다.물론 그렇다고 부모의 Foo() 함수가 사라진 것은 아니다. 부모의 타입을 명시하여 접근하는 것으로 호출은 가능하다. (물론, 호출되는 위치에서 접근이 가능하다면)문제는 부모 타입 포인터가 기본적으로 부모 타입의 함수에만 접근할 수 있다는 데에 있다. 다형성을 활용하려면 부모 타입 포인터가 업캐스팅된 자식 타입 객체를 가리키게 하고, 자식 타입에서 작성한 로직을 사용하도록 해야 한다.이 때 가상 함수를 사용한다.
virtual 키워드를 붙인 멤버 함수는 가상 함수가 되며, 자식이 같은 서명으로 멤버 함수를 선언할 경우 부모의 함수를 덮어쓰게(override) 된다. 이는 부모 포인터를 통해 자식 객체를 가리키고, 자식이 override한 함수를 부모 포인터를 통해 호출하면, 포인터가 가리키는 실객체인 자식의 함수가 호출됨을 의미한다.Note
'overriding'은 어디까지나 부모-자식 간 캐스팅을 통한 실객체의 함수 호출을 가능케 한다는 의미이다. 부모의 함수와 자식의 함수가 공존하는 상태인 건 똑같다. 실제로, 가상 함수라고 해도 부모 타입을 명시적으로 써서 부모 함수에 접근하는 건 여전히 가능하다.
이게 어떻게 가능한 걸까?비밀은 가상 함수 테이블에 있다. 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해, 클래스 단위로 하나의 가상 함수 테이블을 만든다. 이 테이블은 클래스의 구조에 따라 고정된 형태로 컴파일 타임에 만들어진다.
가상 함수 테이블에는 오버라이딩 구조에 따라 현재 클래스의 타입을 통해 가상 함수를 호출했을 때 최종적으로 오버라이딩된 위치가 어디인지, 즉 클래스의 상속관계 안에서 어떤 클래스의 함수를 호출해야 하는지 기록되어 있다.가상 함수 테이블을 가진 클래스가 인스턴싱될 때, 객체는 자동적으로 '가상 함수 포인터(Virtual Pointer)'를 가지게 된다. 이 포인터는 자신의 가상 함수 테이블이 있는 위치를 가리키며, 따라서 객체의 크기는 일반 포인터 하나(64비트 OS에서 8바이트)분만큼 늘어난다.
그리고 가상함수가 호출되면 현재 vptr가 가리키고 있는 가상함수 테이블의 함수를 호출하게 됨으로써 마지막으로 오버라딩된 함수를 호출하게 된다.가상 함수 테이블과 가상 함수 포인터의 생성 시점
가상 함수 테이블은 컴파일 타임에 컴파일러에 의해 생성되지만, 실제로 그 테이블을 쓰는 것은 런타임에 인스턴스가 가상 함수 포인터를 가지고 생성될 때부터다.
또 가상 함수 포인터가 자신의 가상 함수 테이블을 가리키게 되는 건 생성자가 호출되는 시점이므로, 부모의 생성자에선 부모의 가상함수만 호출할 수 있음에 주의해야 한다. 즉, 자식 객체를 생성할 때 부모의 생성자가 먼저 호출되고, 그와 동시에 객체의 vptr는 부모의 가상 함수 테이블을 가리키며, 이후 자식의 생성자가 호출되면서 vptr가 가리키는 가상 함수 테이블이 바뀌어 그 때부터 자식이 오버라이딩한 함수의 호출이 가능해진다.
오버라이딩을 강제하는 가상 함수. virtual void Foo() = 0; 와 같이 '= 0' 키워드를 통해 선언한다. MSVC를 사용한다면 '= 0' 키워드는 MSVC가 추가한 'abstract' 키워드로 대체할 수 있다. 물론 C++ 표준이 아니므로 코드 호환성을 위해 '= 0'을 쓸 것을 권장한다.Note
순수 가상 함수는 오버라이딩을 강제하는 것이지 정의를 가지지 못 하는 게 아니다. 여전히 함수이며 정의가 있는 경우 부모 타입을 명시하여 호출하는 것도 가능하다. 물론 정의부가 없이 호출하면 찾을 수 없는 심볼 링크 에러가 발생한다.
하나 이상의 순수 가상 함수가 포함된 클래스를 추상 클래스(Abstract class)라고 부른다. 자식을 통해 구체화되어야 하는 추상 함수를 포함하는 클래스라는 뜻으로, 기본적으로 존재 자체가 상속될 것을 전제한다. 따라서 추상 클래스의 인스턴스를 만들 수는 없다.오로지 순수 가상 함수 멤버로만 이루어진 클래스는 특별히 인터페이스(Interface)라고 부른다. 말 그대로 어떠한 구현, 로직, 데이터도 가지지 않고 오직 서로 다른 객체 간의 소통을 위한 매개 레이어로만 쓰이는 클래스라고 할 수 있다.
C++ 이후의 언어들은 아예 인터페이스 클래스를 분리하고 예약어를 통해 명시적으로 선언하게 하기도 한다. 그러나 C++에선 별도의 키워드는 없다. (MSVC가 COM 프로그래밍에 쓰려고 추가한 __interface 키워드가 있긴 하지만, C++ 표준이 아니다.)class Parent
{
public: virtual void Foo() = 0 { std::cout &lt;&lt; "순수 가상 함수 역시 함수이며 정의를 가질 수 있다.\n"; }
}; class Child : public Parent
{
public: // C++11에서 오버라이드 함수임을 명시할 수 있는 override 키워드가 추가되었다. // 오버라이드 함수에만 붙일 수 있다. 그냥 사람이 오버라이드 함수임을 명확히 알 수 있도록 하는 데 쓰인다. virtual void Foo() override { std::cout &lt;&lt; "자식 클래스\n"; }
}; int main()
{ Parent* ptr = new Child; ptr-&gt;Foo(); ptr-&gt;Parent::Foo();
} vptr가 가리키는 vtable로 이동해 호출해야 하는 함수를 찾는 동작을 virtual dispatch라고 한다.
부모의 생성자에서 virtual dispatch를 시도하면 안 되는 이유는 의도는 자식 타입의 실 객체가 오버라이드한 가상함수를 호출하려는 것일지라도 자식 객체가 생성되기 전에, 즉 vptr가 자식의 가상 함수 테이블을 가리키기 전에 호출되어 부모 자신의 함수를 호출하게 되기 때문.
부모의 소멸자에서 virtual dispatch를 시도하면 안 되는 이유도 자식 객체가 이미 제거되어 vptr가 부모의 가상 함수 테이블을 가리키고 있기 때문.
부모 클래스에 반드시 virtual 소멸자가 필요한 이유: 업캐스팅으로 런타임 다형성을 활용할 생각이라면, 부모의 소멸자가 가상함수여야지만 실객체(자식)의 소멸자를 호출할 수 있기 때문. 부모의 소멸자가 가상함수가 아니면 자식 객체가 소멸하지 않는다.
]]></description><link>0-발행완료/c,-c++/문법/가상-함수-(virtual-function).html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/가상 함수 (Virtual function).md</guid><pubDate>Thu, 11 Dec 2025 13:16:22 GMT</pubDate></item><item><title><![CDATA[Stack Corruption]]></title><description><![CDATA[int* Func()
{ int x = 10; return &amp;x;
} int main()
{ int y = *Func();
}
위 코드는 기본적으로 Undefined Behavior이며, VS IDE에선 작동한다.
스택 메모리는 컴파일 타임에 할당되어 존재하기 때문에, Func의 스택 프레임이 제거된 뒤에 해당 위치에 남아있는 값을 복사하게 되기 때문이다.하지만 근본적으로 UB이기 때문에 정확한 동작을 예측할 수 없으며, 해당 위치를 다른 스택 프레임이 사용하게 될 경우 이상한 위치를 참조하여 크래쉬가 날 수도 있다.
이런 상황을 Stack corruption이 발생했다고 말한다.Note
흔히 힙 코럽션은 주의하지만, 스택은 알아서 풀린다는 이유로 사용에 주의를 기울이지 않는 경우가 많다. 힙 메모리의 문제가 아닌데 산발적인 크래쉬가 발생하고, 동작이 다른데 같은 위치에서 터지거나 할 땐 스택 코럽션이 발생했다고 의심해볼 수 있다.
]]></description><link>0-발행완료/c,-c++/기타/stack-corruption.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/Stack Corruption.md</guid><pubDate>Thu, 11 Dec 2025 13:15:34 GMT</pubDate></item><item><title><![CDATA[Dangling Pointer 문제]]></title><description><![CDATA[댕글링 포인터는 힙에서 할당이 해제된 공간의 주소를 가지고 있는 포인터이다.
C언어의 free() 함수나 C++의 delete 단항연산자는 메모리를 해제한 후 포인터를 nullptr로 초기화하지 않는다.댕글링 포인터를 통해 값을 수정하는 동작을 수행하면 어떻게 될까? 크게 2가지 경우로 나뉜다고 할 수 있다.버그가 있다는 걸 알 수 있으므로 가장 운이 좋은 경우라고 할 수 있다. 최신 VS IDE에선 write/read access violation 런타임 예외를 던져주기까지 한다.
원인은 OS가 회수된 영역의 접근 권한을 회수했기 때문이다.프로세스에 폭탄이 심긴 채로 동작하기 때문에 매우 위험한 상황이다. 만약 힙 메모리가 해제된 뒤, 해당 영역을 다른 변수에 할당한 경우 문제 없이 접근하는 게 가능하다.
결국 쓰레기값 또는 전혀 엉뚱하게 초기화된 값이 읽히거나, 다른 데이터를 오염시켜 나중에 문제를 발생시키게 된다.]]></description><link>0-발행완료/c,-c++/기타/dangling-pointer-문제.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/Dangling Pointer 문제.md</guid><pubDate>Thu, 11 Dec 2025 13:15:22 GMT</pubDate></item><item><title><![CDATA[Physics Swing Door, Chest]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250922121547.png" src="♣vaultstorage/attachment/pasted-image-20250922121547.png" target="_self" style="width: 250px; max-width: 100%;">경첩 위치에 PhysicsConstraint 컴포넌트를 부착한다.문은 언제나 밀어서 열며 미는 방향은 내적을 통해 간단하게 구할 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922122825.png" src="♣vaultstorage/attachment/pasted-image-20250922122825.png" target="_self" style="width: 194px; max-width: 100%;">빨간 화살표가 문의 Front 벡터, 보라색 화살표가 문에서 상호작용 당사자로 향하는 벡터일 경우, 두 벡터를 내적한 결과가 위 그림처럼 음수라면 Front 방향으로 회전시키면 된다.단, 아래 그림처럼 Front view 기준으로 경첩이 우측에 달려있는 경우, PhysicsConstraint에 의해 회전하는 방향이 반대가 되어야 하므로, 회전 방향을 역전시키거나 앞/뒤 판정을 역전시켜야 한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922123242.png" src="♣vaultstorage/attachment/pasted-image-20250922123242.png" target="_self" style="width: 200px; max-width: 100%;">bool AFHDoorBase::IsDoorOpenDirectionForward(AActor* Subject)
{ FVector SubjectPos = Subject-&gt;GetActorLocation(); FVector DoorPos = GetActorLocation(); FVector DoorToPlayer = (SubjectPos - DoorPos).GetSafeNormal2D(); FVector DoorRight = DoorMesh-&gt;GetForwardVector(); float dot = FVector::DotProduct(DoorToPlayer, DoorRight); if (bHingeIsRightOnFrontView) { return (dot &gt; 0) ? true : false; } else { return (dot &gt; 0) ? false : true; }
}
관절(Joint) 또는 물리적 제약을 추가하는 컴포넌트. 주요 설정은 다음과 같다.
두 개의 대상 간의 Joint를 생성한다. 대상은 Constraint - Component Name1과 2에 입력한다. 비워두면 월드 공간이 대상이 된다.
여기선 문에 경첩같은 관절을 심는 것이 목적이므로, 1에는 문 메쉬 컴포넌트의 이름을, 2는 비워두도록 한다.
Linear Limits(선형 제약)은 두 대상이 상대적으로 얼마나 이동할 수 있는지 정의한다. 문의 경우 축을 기준으로 회전하는 동작만 수행해야 하므로, X, Y, Z 모두 Locked로 설정한다.
Angular Limits(각도 제약)은 회전을 정의한다. 문은 대략 -100도 ~ 100도 사이의 회전각을 가져야 한다. 회전은 주축(보통 X) 회전인 Twist와 Twist를 기준으로 다른 두 축으로의 회전(Swing1, Swing2)로 구분된다.
Limited(각도 제한)로 설정한 뒤 각 축의 제한 각도를 변경해가며 회전 범위 기즈모가 어떻게 그려지는지 확인하자. 문의 경우, 경첩 위치에 PhysicsConstraint를 위치시킨 뒤 Swing1만 켜면 열고 닫는 동작을 구현할 수 있다. Angular Motor는 특정한 각도로 복원력을 가한다. 여기선 Target Orientation(목표 방향) - Drives의 Swing에 체크하고 Strength는 50을 주어 50의 힘으로 Target Orientation을 바라보려는 복원력을 가하도록 한다.
Angular Motor를 사용해 Target Orientation을 바꿔주는 것만으로 물리적으로 자연스러운 움직임을 구현할 수 있다.열고 닫는 것은 PhysicsConstraint의 모터를 이용하면 된다.AFHDoorBase::AFHDoorBase()
{ ... // 초기화 // 연결된 두 객체 간의 충돌 비활성화 PhysicsConstraint-&gt;SetDisableCollision(true); // X, Y, Z축 스프링은 제거 PhysicsConstraint-&gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0); PhysicsConstraint-&gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0); PhysicsConstraint-&gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0); // Swing1 회전만 사용. 앞 뒤로 RotationLimit만큼 열림. PhysicsConstraint-&gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Limited, RotationLimit); PhysicsConstraint-&gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Locked, 0); PhysicsConstraint-&gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Locked, 0); // Angular Drive 모드 변경 FConstraintInstance&amp; ConstraintInst = PhysicsConstraint-&gt;ConstraintInstance; ConstraintInst.ProfileInstance.AngularDrive.SwingDrive.bEnablePositionDrive = true; ConstraintInst.ProfileInstance.AngularDrive.SwingDrive.bEnableVelocityDrive = true; ConstraintInst.SetAngularDriveMode(EAngularDriveMode::Type::TwistAndSwing);
} void AFHDoorBase::PostInitializeComponents()
{ Super::PostInitializeComponents(); // 당연히 물리 시뮬레이션 대상이어야 하며 DoorMesh-&gt;SetSimulatePhysics(true); // 플레이어가 밀어서 열리지 않게 하기 위해 무겁게 한다. DoorMesh-&gt;SetMassOverrideInKg(NAME_None, 5000.0f, true);
} void AFHDoorBase::ToggleDoorOpen_Implementation(AActor* Subject, float power)
{ FRotator targetRot{ 0, 0, 0}; if (bIsOpened == true) { // 목표 회전각을 0으로 되돌린다. bIsOpened = false; } else { // 목표 회전각을 플레이어의 위치에 따라 앞 또는 뒤로 연 각도로 바꾼다. bIsOpened = true; targetRot.Yaw = IsDoorOpenDirectionForward(Subject) ? OpenDegree : -OpenDegree; } HandleDoor(DoorMesh, PhysicsConstraint, targetRot, power);
} void AFHDoorBase::HandleDoor(UStaticMeshComponent* _DoorMesh, UPhysicsConstraintComponent* _PhysicsConstraint, FRotator AngularOrientation, float movePower)
{ FConstraintInstance&amp; ConstraintInst = _PhysicsConstraint-&gt;ConstraintInstance; float inSpring{}; float damping{}; float forceLimit{}; _PhysicsConstraint-&gt;SetAngularOrientationTarget(AngularOrientation); ConstraintInst.GetAngularDriveParams(inSpring, damping, forceLimit); ConstraintInst.SetAngularDriveParams(movePower, damping, forceLimit); // Sleep 상태일 경우 물리 프로퍼티를 바꿔도 바로 반영되지 않으니 주의. _DoorMesh-&gt;WakeRigidBody();
}
만약 모터를 사용하지 않고 실제로 물리적인 힘을 가한다면 다음과 같이 작성한다. 좋은 방식은 아닌 듯 하다.// FName ForceAnchorSocketName{ TEXT("DoorPushPoint") };
// float PushForce{ 30000.0f }; FVector forcePos = DoorMesh-&gt;GetSocketLocation(ForceAnchorSocketName);
DoorMesh-&gt;AddImpluseAtLocation(ForceDirection * PushForce, forcePos);
상자를 열고 닫는 동작은 문과 똑같이 작업하면 된다.
단, 상자의 경우 닫힌 상태가 기본이 되지만 회전 각도는 아래 그림과 같이 설정되므로, 닫힌 상태에서 지향하는 각도는 -RotationLimit/2가 된다.Note
-RotationLimit/2 로는 윗뚜껑이 무거워도 회전 스프링이 워낙 쎄서 살짝 달랑거리는 느낌이 난다. RotationLimit * -0.7로 변경.
<br><img alt="♣VaultStorage/attachment/Pasted image 20250922192331.png" src="♣vaultstorage/attachment/pasted-image-20250922192331.png" target="_self" style="width: 150px; max-width: 100%;">Note
PhysicsConstraint 컴포넌트가 자신이 연결을 시키는 대상의 자식으로 설정되어 있지 않으면 블루프린트 뷰에서 그려지는 기즈모와 실제 제한 각도 또는 위치가 달라지는 버그가 있는 듯.
내부에 아이템을 스폰하는 동작은 단순히 상자 메쉬에 스폰 포인트 소켓을 달고 ChestDescriptor 데이터 에셋에 스폰 가능한 액터를 채워넣어 랜덤 스폰하는 방식으로 구현했다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/physics-swing-door,-chest.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Physics Swing Door, Chest.md</guid><pubDate>Thu, 11 Dec 2025 13:01:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[싱글톤 패턴]]></title><description><![CDATA[class Foo
{
public: static Foo&amp; GetInstance() { static Foo instance; return instance; }
};
C++11 이후 정적 지역 변수의 초기화는 thread-safe를 보장하도록 바꼈고, 이에 C++의 창시자 중 한 명인 Scott Meyers가 제시한 가장 간단하고 효율적인 싱글톤 패턴.별도의 스레드 안전장치(주로 std::call_once)를 쓸 이유가 없어서 빠르고, 최초로 GetInstance()를 호출할 때 정적 지역 변수가 초기화되므로 지연 초기화가 적용된다.다만 정적 변수이니만큼 언제 소멸될 지 제어할 수 없다는 게 단점.template &lt;typename T&gt;
class SingleTon
{
public: SingleTon(const SingleTon&amp;) = delete; SingleTon(SingleTon&amp;&amp;) noexcept = delete; SingleTon&amp; operator=(const SingleTon&amp;) = delete; SingleTon&amp; operator=(SingleTon&amp;&amp;) noexcept = delete; static const std::shared_ptr&lt;T&gt;&amp; GetInstance() { std::call_once(_initFlag, [] { T* prime = new T(); _instance = std::shared_ptr&lt;T&gt;(prime, Deleter()); }); return _instance; } struct Deleter { // 소멸자를 protected로 선언하여 외부 소멸을 막고, 대신 다음과 같이 커스텀 딜리터를 정의하여 필요한 경우 조치를 취한다. void operator()(const T* instance) { delete instance; } }; protected: SingleTon() = default; virtual ~SingleTon() = default; private: inline static std::shared_ptr&lt;T&gt; _instance{}; inline static std::once_flag _initFlag{};
}; class Foo : public Singleton&lt;Foo&gt;
{ }
std::call_once를 사용해 스레드 안전성을 보장하고, std::shared_ptr를 사용해 싱글톤 객체의 수명을 관리하는 방식.Meyer’s singleton은 전역 변수로만 생성할 수 있었지만 이 방법을 사용하면 멤버 변수로도 생성이 가능하다. 근데 멤버 변수로 쓸 거면 싱글톤 패턴으로 만들 이유가 전혀 없다. 그럼 왜 있는 걸까? 그냥 구식 코드일까?그래도 소멸을 원할 때 시킬 수 있으니 그것 장점.]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/싱글톤-패턴.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/싱글톤 패턴.md</guid><pubDate>Thu, 25 Sep 2025 13:32:07 GMT</pubDate></item><item><title><![CDATA[함수와 객체의 노출을 제한하기]]></title><description><![CDATA[함수와 객체를 외부로 노출시켜도 되는지, 노출시켜야 하는지 판단하는 것은 설계에 있어 매우 중요하다.꼭 필요한 게 아니라면 일단 숨겨놓는 것을 기본으로 삼는 것이 맞다. 사용자는 언제 어느 때 어떤 행동을 취할 지 누구도 알 수 없으므로, 최대한 숨기고 접근하지 못 하게 만들어 예외 상황을 원천 차단하는 것이 좋은 설계다.C++ 기준이다.노출되지 않아야 하는 멤버는 private 접근 지정자를 통해 은닉한다.네임스페이스를 활용하면 접근 난이도를 높혀 일반 사용자의 접근을 차단할 수 있다.// 코어 개발자만 사용하는 네임 스페이스로 감싸는 예시
// 네임스페이스를 명시하고 접근해야 하므로 접근 난도가 높아지고, 자연히 일반 사용자의 접근을 막을 수 있다.
namespace Engine
{ void DoSomething();
} // 익명 네임스페이스(Anonymous namespace)를 사용하는 방식
// 익명 네임스페이스는 그것이 포함된 목적파일 단위로, 그 목적파일 안에서만 접근할 수 있는 변수와 함수를 선언한다. 이걸 소스파일에서 선언하면 해당 소스 파일 안에만 존재하는 선언이 되므로 외부에서 접근할 수 없다.
namespace
{ void DoSomething();
}
전역적으로 선언된 static 변수나 함수는 그것이 포함된 목적파일 단위로, 그 목적파일 안에서만 접근할 수 있게(파일 스코프로 종속) 된다. 따라서 익명 네임스페이스처럼 소스 파일 안에서 선언하면 해당 목적 파일 안에만 존재하는 선언이 되므로 외부에서 접근할 수 없다.이를 'Internal linkage'를 가진다고 말한다. Internal linkage를 가지는 요소는 심볼이 해당 목적 파일 안에서만 존재하게 되며 외부에서 extern 키워드 등으로 심볼을 찾을 수 없다.]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/함수와-객체의-노출을-제한하기.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/함수와 객체의 노출을 제한하기.md</guid><pubDate>Tue, 23 Sep 2025 13:03:39 GMT</pubDate></item><item><title><![CDATA[의존성 역전 (Dependency Inversion Principle)]]></title><description><![CDATA[객체지향의 5대 원칙인 SOLID 원칙 중 D에 해당한다. 또한 "수정은 어렵게, 확장은 쉽게" 설계해야 한다는 개방-폐쇄 원칙을 가장 쉽게 구현할 수 있는 방법이기도 하다.<img alt="♣VaultStorage/attachment/Pasted image 20250419132354.png" src="♣vaultstorage/attachment/pasted-image-20250419132354.png" target="_self">개발자스럽게 표현하면 "고수준(High-level) 모듈이 저수준(Low-level) 모듈에 직접 의존하지 않게 한다"고 말한다.
고수준, 저수준 모듈은 일반적으로 말하는 그 하이-레벨, 로우-레벨의 의미가 맞다. 로우-레벨은 어플리케이션의 밑단에서 구체적인 기능과 로직을 구현하는 것이고, 하이-레벨은 보다 추상화되고 사용자에게 노출될 가능성이 큰 것이다.더 쉽게 말하면 다른 모듈을 참조할 때 직접 참조하지 말고 인터페이스같은 추상화 레이어를 하나 끼고서 참조하라는 것이다. 이로 인한 장점을 나열해보자면 다음과 같다.
만약 인터페이스를 통해 추상화하지 않는다면, 저수준 모듈이 변했을 때 그걸 사용하던 고수준 모듈의 로직도 변해야 할 수 있다.
반면 인터페이스를 통해 추상화하고 인터페이스의 명세가 약속한 대로 저수준 모듈이 기능을 제공해주기만 한다면, 고수준 모듈은 저수준 모듈이 어떻게 변하던 신경을 쓸 필요가 없다. 인터페이스를 통해 기능 단위로 잘 분리된 함수들만 제공받을 수 있으면 된다.
여러 종류의 저수준 모듈이 있어도 같은 인터페이스를 상속하기만 하면 고수준 모듈에선 쉽게 교체하여 사용할 수 있다. 이는 런타임에도 가능하므로 아주 강력한 장점이 된다.
테스트나 디버깅을 할 땐 테스트용 Mock 객체를 끼워서 사용해보면 된다. 이런 유연한 구조로 시간, 비용이 절약된다.
]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/의존성-역전-(dependency-inversion-principle).html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/의존성 역전 (Dependency Inversion Principle).md</guid><pubDate>Tue, 23 Sep 2025 13:03:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[서비스 로케이터 패턴 (Service locator pattern)]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250419151747.png" src="♣vaultstorage/attachment/pasted-image-20250419151747.png" target="_self">여러 기능들을 '서비스 로케이터'라는 전역 클래스를 통해 관리하고 제공하는 디자인 패턴.
각각의 기능을 제공하는 객체들을 서비스라고 부르며, 서비스 로케이터에 타입 또는 이름으로 서비스 객체를 등록하고, 필요한 곳에서 이를 요청하여 받아 사용하는 것이 골자이다.개념도 간단하고 구현하기도 쉽다. 다만 구체적인 구현 방식은 하기 나름이라 매우 다양한 형태로 나타날 수 있다.이 패턴을 사용하는 목적은 기본적으로 객체 간 의존성을 최소화하고, 생명주기의 관리마저 서비스 로케이터를 통해 쉽게 수행하는 것에 있다.
의존성을 줄이기 위한 방법론이란 점에서 의존성 주입 패턴과 자주 비교된다. 결론만 말해 서비스 로케이터 패턴은 의존성 주입 패턴보다 당장 구현하기는 더 쉽고 직관적이나, 의존성을 명확하게 드러내는 데는 의존성 주입 패턴이 나아서 확장과 유지보수에는 불리하다. 후술하겠지만 이 때문에 서비스 로케이터 패턴은 오히려 사용을 지양해야 하는 '안티 패턴'이며, 대안으로 의존성 주입 패턴을 사용해야 한다고 주장하는 사람도 있다.혹자는 서비스 로케이터 패턴은 사용하기는 커녕 오히려 지양해야 하는 Anti-Pattern이라고 말한다.
이유는 서비스 로케이터가 서비스를 제공해주는 형태 자체가 '내가 무슨 서비스를 사용(의존)하는 지' 명확하게 알 수 없게 만든다는 것이다. 이는 특히 협업을 할 때, 외부 라이브러리를 사용할 때 두드러지는 문제다.예를 들어, 라면을 끓이고 싶다고 하자. 라면을 끓이려면 물과 냄비가 필요하다. 그렇다면 라면을 끓이는 주체인 RamenChef는 다음과 같이 설계하면 될 것이다.class RamenChef
{ Pot pot; Water water;
public: void Cook() { // pot과 water를 사용해 라면을 끓인다. }
};
이 코드는 아주 단순한 형태로 개방-폐쇄 원칙을 따르지 않고 있다. 단순히 다른 객체를 has-a 관계로 포함하고 있으니 Pot이나 Water가 수정되면 영향을 받게 되는 '나쁜 설계'에 해당한다.
하지만 이런 나쁜 설계조차도, 라면을 끓이기 위해선 Pot과 Water를 써야 한다는 사실만큼은 직관적으로 보여준다. 즉, 코드만 보고 '종속성을 명확히 알 수 있다'는 것이다.하지만 서비스 로케이터처럼 외부에서 객체를 요구하는 방식을 사용한다고 해보자.class Kitchen
{ static Pot pot; static Water water;
public: static Pot* GetPot() { return &amp;pot; } static Water* GetWater() { return &amp;water; }
}; class RamenChef
{
public: void Cook() { Pot* pot = Kitchen::GetPot(); Water* water = Kitchen::GetWater(); // pot과 water를 사용해 라면을 끓인다. }
}
이 코드는 다음과 같은 문제를 가진다.
RamenChef의 작동 원리를 모르는 사람은 라면을 끓이기 위해 Pot과 Water가 필요하다는 사실을 알기가 쉽지 않다. 이 사람들이 보기에 이 코드는 "자기도 모르게 누군가 주방에서 냄비와 물을 은글슬쩍 가져오는" 것처럼 보일 것이다.
서비스 로케이터의 입장에서도, 어떤 클래스가 어떤 서비스를 사용하고 있는지 알 방법이 없다. 서비스들은 각각의 독립된 기능을 수행하므로 어떤 클래스가 어떤 서비스를 사용하는 지는 몰라도 상관없다고 말할 수 있지만, 의존성이 아예 없는 코드를 짜는 건 너무 힘들기 때문에 언제 문제가 생길지 알 수 없다.
따라서 서비스 로케이터 패턴을 지양해야 한다고 말하는 사람들은 의존성 주입 패턴을 그 대안으로 사용할 것을 권고한다. 의존성 주입 패턴은 명확하게 필요한 객체를 인자 타입으로 요구하기 때문에 노출된 함수만 사용하는 외부자가 보기에도 어떤 객체에 의존하는 지가 아주 명확하게 드러난다.]]></description><link>0-발행완료/프로그래밍-일반/설계방법론,-디자인패턴/서비스-로케이터-패턴-(service-locator-pattern).html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계방법론, 디자인패턴/서비스 로케이터 패턴 (Service locator pattern).md</guid><pubDate>Tue, 23 Sep 2025 13:03:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[index]]></title><description><![CDATA[안녕하세요. 게임 개발자 지망생 이건제입니다.포트폴리오 페이지 링크를 목적으로 작성했던 문서들중 일부를 온라인으로 발행한 블로그입니다.포트폴리오 페이지는 아래 주소에서 보실 수 있습니다.
<a data-tooltip-position="top" aria-label="https://gunandjerry.github.io/" rel="noopener nofollow" class="external-link is-unresolved" href="https://gunandjerry.github.io/" target="_self">gunandjerry의 포트폴리오</a>프로젝트 관련 문서들은 쉽게 찾아보실 수 있게 인덱스 문서를 통해 정리해두었습니다.<br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/언리얼 엔진 공부 기록 인덱스" data-href="0 발행완료/언리얼 엔진/언리얼 엔진 공부 기록 인덱스" href="0-발행완료/언리얼-엔진/언리얼-엔진-공부-기록-인덱스.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 엔진 공부 기록 인덱스</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 기록 인덱스" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 기록 인덱스" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-기록-인덱스.html" class="internal-link" target="_self" rel="noopener nofollow">2504_F급헌터생존기/구현 기록 인덱스</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/디버깅 기록 인덱스" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/디버깅 기록 인덱스" href="0-발행완료/프로젝트/2504_f급헌터생존기/디버깅-기록-인덱스.html" class="internal-link" target="_self" rel="noopener nofollow">2504_F급헌터생존기/디버깅 기록 인덱스</a>]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Thu, 11 Dec 2025 05:05:19 GMT</pubDate></item><item><title><![CDATA[언리얼 엔진 공부 기록 인덱스]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/그래픽 옵션 변경하기" data-href="0 발행완료/언리얼 엔진/엔진 지식/그래픽 옵션 변경하기" href="0-발행완료/언리얼-엔진/엔진-지식/그래픽-옵션-변경하기.html" class="internal-link" target="_self" rel="noopener nofollow">그래픽 옵션 변경하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/네비게이션 시스템" data-href="0 발행완료/언리얼 엔진/엔진 지식/네비게이션 시스템" href="0-발행완료/언리얼-엔진/엔진-지식/네비게이션-시스템.html" class="internal-link" target="_self" rel="noopener nofollow">네비게이션 시스템</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Level Travel" data-href="0 발행완료/언리얼 엔진/엔진 지식/Level Travel" href="0-발행완료/언리얼-엔진/엔진-지식/level-travel.html" class="internal-link" target="_self" rel="noopener nofollow">Level Travel</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/LevelScriptActor, WorldSettings" data-href="0 발행완료/언리얼 엔진/엔진 지식/LevelScriptActor, WorldSettings" href="0-발행완료/언리얼-엔진/엔진-지식/levelscriptactor,-worldsettings.html" class="internal-link" target="_self" rel="noopener nofollow">LevelScriptActor, WorldSettings</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/모듈" data-href="0 발행완료/언리얼 엔진/엔진 지식/모듈" href="0-발행완료/언리얼-엔진/엔진-지식/모듈.html" class="internal-link" target="_self" rel="noopener nofollow">모듈</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Event Dispatcher" data-href="0 발행완료/언리얼 엔진/엔진 지식/Event Dispatcher" href="0-발행완료/언리얼-엔진/엔진-지식/event-dispatcher.html" class="internal-link" target="_self" rel="noopener nofollow">Event Dispatcher</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/팁과 노하우/효율적인 게임플레이 태그 구조" data-href="0 발행완료/언리얼 엔진/팁과 노하우/효율적인 게임플레이 태그 구조" href="0-발행완료/언리얼-엔진/팁과-노하우/효율적인-게임플레이-태그-구조.html" class="internal-link" target="_self" rel="noopener nofollow">효율적인 게임플레이 태그 구조</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼의 라이트" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼의 라이트" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼의-라이트.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼의 라이트</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/텍스쳐 스트리밍 풀" data-href="0 발행완료/언리얼 엔진/엔진 지식/텍스쳐 스트리밍 풀" href="0-발행완료/언리얼-엔진/엔진-지식/텍스쳐-스트리밍-풀.html" class="internal-link" target="_self" rel="noopener nofollow">텍스쳐 스트리밍 풀</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/플러그인" data-href="0 발행완료/언리얼 엔진/엔진 지식/플러그인" href="0-발행완료/언리얼-엔진/엔진-지식/플러그인.html" class="internal-link" target="_self" rel="noopener nofollow">플러그인</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/현지화" data-href="0 발행완료/언리얼 엔진/엔진 지식/현지화" href="0-발행완료/언리얼-엔진/엔진-지식/현지화.html" class="internal-link" target="_self" rel="noopener nofollow">현지화</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/디테일 창에서 열거형 복수 선택하기" data-href="0 발행완료/언리얼 엔진/엔진 지식/디테일 창에서 열거형 복수 선택하기" href="0-발행완료/언리얼-엔진/엔진-지식/디테일-창에서-열거형-복수-선택하기.html" class="internal-link" target="_self" rel="noopener nofollow">디테일 창에서 열거형 복수 선택하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/메타휴먼 에디터 사용법" data-href="0 발행완료/언리얼 엔진/엔진 지식/메타휴먼 에디터 사용법" href="0-발행완료/언리얼-엔진/엔진-지식/메타휴먼-에디터-사용법.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼 에디터 사용법</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 비헤이비어 트리" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 비헤이비어 트리" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-비헤이비어-트리.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 비헤이비어 트리</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/에셋 리디렉션(Unreal Redirector)" data-href="0 발행완료/언리얼 엔진/엔진 지식/에셋 리디렉션(Unreal Redirector)" href="0-발행완료/언리얼-엔진/엔진-지식/에셋-리디렉션(unreal-redirector).html" class="internal-link" target="_self" rel="noopener nofollow">에셋 리디렉션(Unreal Redirector)</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Cooking" data-href="0 발행완료/언리얼 엔진/엔진 지식/Cooking" href="0-발행완료/언리얼-엔진/엔진-지식/cooking.html" class="internal-link" target="_self" rel="noopener nofollow">Cooking</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/루트 모션" data-href="0 발행완료/언리얼 엔진/엔진 지식/루트 모션" href="0-발행완료/언리얼-엔진/엔진-지식/루트-모션.html" class="internal-link" target="_self" rel="noopener nofollow">루트 모션</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/애니메이션 리타게팅" data-href="0 발행완료/언리얼 엔진/엔진 지식/애니메이션 리타게팅" href="0-발행완료/언리얼-엔진/엔진-지식/애니메이션-리타게팅.html" class="internal-link" target="_self" rel="noopener nofollow">애니메이션 리타게팅</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Widget Reflector" data-href="0 발행완료/언리얼 엔진/엔진 지식/Widget Reflector" href="0-발행완료/언리얼-엔진/엔진-지식/widget-reflector.html" class="internal-link" target="_self" rel="noopener nofollow">Widget Reflector</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/UI(UMG)" data-href="0 발행완료/언리얼 엔진/엔진 지식/UI(UMG)" href="0-발행완료/언리얼-엔진/엔진-지식/ui(umg).html" class="internal-link" target="_self" rel="noopener nofollow">UI(UMG)</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/UMG UPROPERTY 바인딩 방식" data-href="0 발행완료/언리얼 엔진/엔진 지식/UMG UPROPERTY 바인딩 방식" href="0-발행완료/언리얼-엔진/엔진-지식/umg-uproperty-바인딩-방식.html" class="internal-link" target="_self" rel="noopener nofollow">UMG UPROPERTY 바인딩 방식</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Blueprint Pure 함수" data-href="0 발행완료/언리얼 엔진/엔진 지식/Blueprint Pure 함수" href="0-발행완료/언리얼-엔진/엔진-지식/blueprint-pure-함수.html" class="internal-link" target="_self" rel="noopener nofollow">Blueprint Pure 함수</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Assertion, Logging" data-href="0 발행완료/언리얼 엔진/엔진 지식/Assertion, Logging" href="0-발행완료/언리얼-엔진/엔진-지식/assertion,-logging.html" class="internal-link" target="_self" rel="noopener nofollow">Assertion, Logging</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/ConstructorHelpers" data-href="0 발행완료/언리얼 엔진/엔진 지식/ConstructorHelpers" href="0-발행완료/언리얼-엔진/엔진-지식/constructorhelpers.html" class="internal-link" target="_self" rel="noopener nofollow">ConstructorHelpers</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Delegate" data-href="0 발행완료/언리얼 엔진/엔진 지식/Delegate" href="0-발행완료/언리얼-엔진/엔진-지식/delegate.html" class="internal-link" target="_self" rel="noopener nofollow">Delegate</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/액터 생성과 동시에 값 초기화하기" data-href="0 발행완료/언리얼 엔진/엔진 지식/액터 생성과 동시에 값 초기화하기" href="0-발행완료/언리얼-엔진/엔진-지식/액터-생성과-동시에-값-초기화하기.html" class="internal-link" target="_self" rel="noopener nofollow">액터 생성과 동시에 값 초기화하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 스마트 포인터 타입" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 스마트 포인터 타입" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-스마트-포인터-타입.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 스마트 포인터 타입</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 오브젝트(UObject)의 이해" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 오브젝트(UObject)의 이해" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-오브젝트(uobject)의-이해.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 오브젝트(UObject)의 이해</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 타입" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 타입" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-타입.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 타입</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Multiplayer in Unreal Engine How to Understand Network Replication by Alex Forsythe" data-href="0 발행완료/언리얼 엔진/엔진 지식/Multiplayer in Unreal Engine How to Understand Network Replication by Alex Forsythe" href="0-발행완료/언리얼-엔진/엔진-지식/multiplayer-in-unreal-engine-how-to-understand-network-replication-by-alex-forsythe.html" class="internal-link" target="_self" rel="noopener nofollow">Multiplayer in Unreal Engine How to Understand Network Replication by Alex Forsythe</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Seamless Travel vs Non-Seamless Travel" data-href="0 발행완료/언리얼 엔진/엔진 지식/Seamless Travel vs Non-Seamless Travel" href="0-발행완료/언리얼-엔진/엔진-지식/seamless-travel-vs-non-seamless-travel.html" class="internal-link" target="_self" rel="noopener nofollow">Seamless Travel vs Non-Seamless Travel</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/SteamWorks SDK" data-href="0 발행완료/언리얼 엔진/엔진 지식/SteamWorks SDK" href="0-발행완료/언리얼-엔진/엔진-지식/steamworks-sdk.html" class="internal-link" target="_self" rel="noopener nofollow">SteamWorks SDK</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/USTRUCT 리플리케이트" data-href="0 발행완료/언리얼 엔진/엔진 지식/USTRUCT 리플리케이트" href="0-발행완료/언리얼-엔진/엔진-지식/ustruct-리플리케이트.html" class="internal-link" target="_self" rel="noopener nofollow">USTRUCT 리플리케이트</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/프로파일링/언리얼 인사이트(Insight)" data-href="0 발행완료/언리얼 엔진/프로파일링/언리얼 인사이트(Insight)" href="0-발행완료/언리얼-엔진/프로파일링/언리얼-인사이트(insight).html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 인사이트(Insight)</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 해부하기/언리얼 초기화, 액터 스폰, 클라 접속시 동작 순서" data-href="0 발행완료/언리얼 엔진/엔진 해부하기/언리얼 초기화, 액터 스폰, 클라 접속시 동작 순서" href="0-발행완료/언리얼-엔진/엔진-해부하기/언리얼-초기화,-액터-스폰,-클라-접속시-동작-순서.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 초기화, 액터 스폰, 클라 접속시 동작 순서</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 해부하기/The Unreal Engine Game Framework - From int main to BeginPlay (by Alex Forsythe)" data-href="0 발행완료/언리얼 엔진/엔진 해부하기/The Unreal Engine Game Framework - From int main to BeginPlay (by Alex Forsythe)" href="0-발행완료/언리얼-엔진/엔진-해부하기/the-unreal-engine-game-framework-from-int-main-to-beginplay-(by-alex-forsythe).html" class="internal-link" target="_self" rel="noopener nofollow">The Unreal Engine Game Framework - From int main to BeginPlay (by Alex Forsythe)</a>]]></description><link>0-발행완료/언리얼-엔진/언리얼-엔진-공부-기록-인덱스.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/언리얼 엔진 공부 기록 인덱스.md</guid><pubDate>Thu, 11 Dec 2025 05:03:51 GMT</pubDate></item><item><title><![CDATA[(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20251015182408.png" src="♣vaultstorage/attachment/pasted-image-20251015182408.png" target="_self" style="width: 350px; max-width: 100%;">
게이트에서 밤로비로 이동할 때 혹은 밤로비에서 낮로비로 이동할 때 발생.
아마도? PlayerCameraManager-&gt;SetViewTarget 함수에 원인이 있지 않을까 싶음
콘솔에 showdebug camera 쳐서 Default main viewtarget 플레이어 맞는지 확인정상일 때 이런 모양<br><img alt="♣VaultStorage/attachment/Pasted image 20251015185849.png" src="♣vaultstorage/attachment/pasted-image-20251015185849.png" target="_self" style="width: 500px; max-width: 100%;">고간뷰일 때 이런 모양<br><img alt="♣VaultStorage/attachment/Pasted image 20251017143937.png" src="♣vaultstorage/attachment/pasted-image-20251017143937.png" target="_self" style="width: 475px; max-width: 100%;">Z = 92.6으로 동일한 걸 보면 카메라는 제대로 머리에 달려있다.더 테스트해본 결과 메타휴먼 BP로부터 스켈레탈 메쉬를 가져오는 ChangeMetahuman 함수와 관련이 있는 것으로 보인다.
게임을 시작하고 ChangeMetahuman 호출 전 이런 에러가 뜰 때 고간뷰로 이동하는 것으로 보인다.Blueprint Runtime Error: "Accessed None trying to read (real) property K2Node_DynamicCast_AsBP_Player in not an UClass". Node: ChangeMetahuman Graph: EventGraph Function: Execute Ubergraph BP FHPlayer State Blueprint: BP_FHPlayerState
또, 레벨을 이동할 때 메타휴먼 메쉬가 선택한 게 아닌 기본 남성1 외형으로 변하는 경우가 있었는데, 이 문제와 관련이 있는 것으로 보인다.관련 로직을 쭉 따라가며 확인해보았다.<br><img alt="♣VaultStorage/attachment/Pasted image 20251017144958.png" src="♣vaultstorage/attachment/pasted-image-20251017144958.png" target="_self" style="width: 475px; max-width: 100%;">문제의 원인은 블루프린트 그래프 실수였다. 위 그래프에서 0.2초마다 클라이언트의 폰을 다시 체크하는데, Valid가 되었을 때 다시 캐스팅을 하지 않아서 null이 전달되고, set view target이 null이 되면서 캡슐 중앙으로 기본 카메라를 사용하게 되었던 것.아래와 같이 고쳐야 한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20251017145123.png" src="♣vaultstorage/attachment/pasted-image-20251017145123.png" target="_self" style="width: 500px; max-width: 100%;">블루프린트 쓰면 실수가 너무 잦다. 제대로 못 만들 거면 최대한 쓰지 말아라. 아무리 말을 해도 안 듣는다. 늘 뒷처리는 내 몫...]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1015)-클라이언트-카메라가-레벨-트레벨-후-캡슐-중앙으로-이동하는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제.md</guid><pubDate>Thu, 11 Dec 2025 04:49:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[디버깅 기록 인덱스]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0603)-dynamic-level-streaming으로-로드된-액터의-guid가-어긋나는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0605) 포인트 라이트가 벽을 뚫고 나가는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0605) 포인트 라이트가 벽을 뚫고 나가는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0605)-포인트-라이트가-벽을-뚫고-나가는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0605) 포인트 라이트가 벽을 뚫고 나가는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0616) 위젯 델리게이트 중복 등록 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0616) 위젯 델리게이트 중복 등록 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0616)-위젯-델리게이트-중복-등록-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0616) 위젯 델리게이트 중복 등록 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0617)-동적-스트리밍되는-룸-레벨-안에-움직이는-액터가-있을-때-onnavigationgenerationfinisheddelegate-이벤트가-발생하지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) 던전 안에서 크리쳐 AI가 비활성화되는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) 던전 안에서 크리쳐 AI가 비활성화되는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0626)-던전-안에서-크리쳐-ai가-비활성화되는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0626) 던전 안에서 크리쳐 AI가 비활성화되는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0626)-tsoftobjectptr로-서버와-클라가-각각-비동기로-에셋을-로드할-때,-리플리케이트-과정에서-guid-불일치-경고에-걸리는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0627)-애니메이션-시퀀스의-특정-포즈에-대한-애님-시퀀스를-만들었더니-스켈레탈-메쉬의-모양이-이상해지는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-메타휴먼-옷-메쉬가-특정-lod에서-움직이지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-메타휴먼의-특정-파츠만-바디-애니메이션을-상속하지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0704)-같은-스켈레톤을-사용하는-캐릭터와-애니메이션-간의-본-translation-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0707) ‘GEngine not initialized!’ 패키징 에러" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0707) ‘GEngine not initialized!’ 패키징 에러" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0707)-‘gengine-not-initialized!’-패키징-에러.html" class="internal-link" target="_self" rel="noopener nofollow">(0707) ‘GEngine not initialized!’ 패키징 에러</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0721)-tracesingle론-안-되고-tracemult로만-감지되는-액터.html" class="internal-link" target="_self" rel="noopener nofollow">(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0730)-스트리밍된-레벨이-있을-때-서버가-먼저-travel을-하면-클라이언트에서-worldsettings가-nullptr로-바뀌는-현상.html" class="internal-link" target="_self" rel="noopener nofollow">(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0731) DX12 GroomComponent 렌더링 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0731) DX12 GroomComponent 렌더링 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0731)-dx12-groomcomponent-렌더링-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0731) DX12 GroomComponent 렌더링 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0801) 프로젝트와 언리얼 엔진 연동 실패 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0801) 프로젝트와 언리얼 엔진 연동 실패 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0801)-프로젝트와-언리얼-엔진-연동-실패-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0801) 프로젝트와 언리얼 엔진 연동 실패 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0805)-메쉬의-머터리얼로-위젯-렌더-타겟을-입혔는데-일부가-잘리는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible' 경고가 뜨는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible' 경고가 뜨는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0805)-플레이어가-래그돌이-됐다가-복구될-때-‘body-is-set-to-stimulate-physics-but-collision-enabled-is-incompatible'-경고가-뜨는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible' 경고가 뜨는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0806)-카메라를-따라가는-비네트-쿼드가-렉이-걸린-것처럼-뒤늦게-따라오는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0806)-클라이언트에서-자식-uobject에-접근할-때-nullptr참조-발생.html" class="internal-link" target="_self" rel="noopener nofollow">(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0815) 에디터에서 모든 텍스쳐에 'Preview' 라벨이 붙는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0815) 에디터에서 모든 텍스쳐에 'Preview' 라벨이 붙는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0815)-에디터에서-모든-텍스쳐에-'preview'-라벨이-붙는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0815) 에디터에서 모든 텍스쳐에 'Preview' 라벨이 붙는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0923) 나선형 계단 Nav Mesh 베이킹 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0923) 나선형 계단 Nav Mesh 베이킹 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0923)-나선형-계단-nav-mesh-베이킹-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0923) 나선형 계단 Nav Mesh 베이킹 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0924) Failed to load Outer for resource, 레벨 내 메쉬와 마터리얼 로드 실패" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0924) Failed to load Outer for resource, 레벨 내 메쉬와 마터리얼 로드 실패" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0924)-failed-to-load-outer-for-resource,-레벨-내-메쉬와-마터리얼-로드-실패.html" class="internal-link" target="_self" rel="noopener nofollow">(0924) Failed to load Outer for resource, 레벨 내 메쉬와 마터리얼 로드 실패</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0925) GA에서 PlayMontageAndWait Task를 사용할 때, 클라이언트 당사자만 동작하지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0925) GA에서 PlayMontageAndWait Task를 사용할 때, 클라이언트 당사자만 동작하지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0925)-ga에서-playmontageandwait-task를-사용할-때,-클라이언트-당사자만-동작하지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0925) GA에서 PlayMontageAndWait Task를 사용할 때, 클라이언트 당사자만 동작하지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1015)-클라이언트-카메라가-레벨-트레벨-후-캡슐-중앙으로-이동하는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1017)-터미널-메쉬에-위젯이-그려지지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1018)-클라이언트에서-몽타쥬-재생-중에-이동이-멈추는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 투척된 아이템의 Jittering 현상" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 투척된 아이템의 Jittering 현상" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1018)-클라이언트에서-투척된-아이템의-jittering-현상.html" class="internal-link" target="_self" rel="noopener nofollow">(1018) 클라이언트에서 투척된 아이템의 Jittering 현상</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1029) VOIP Talker Seamless Travel 크래쉬" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1029) VOIP Talker Seamless Travel 크래쉬" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1029)-voip-talker-seamless-travel-크래쉬.html" class="internal-link" target="_self" rel="noopener nofollow">(1029) VOIP Talker Seamless Travel 크래쉬</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1106) 일반 람다 내부에서 멤버 함수 실행 후 캡쳐된 this가 null이 되는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1106) 일반 람다 내부에서 멤버 함수 실행 후 캡쳐된 this가 null이 되는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1106)-일반-람다-내부에서-멤버-함수-실행-후-캡쳐된-this가-null이-되는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1106) 일반 람다 내부에서 멤버 함수 실행 후 캡쳐된 this가 null이 되는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1111) 일반, 관전 HUD가 둘 다 뜨는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1111) 일반, 관전 HUD가 둘 다 뜨는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1111)-일반,-관전-hud가-둘-다-뜨는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1111) 일반, 관전 HUD가 둘 다 뜨는 문제</a><br><a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 네트워크" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-네트워크.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 네트워크</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 렌더링" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-렌더링.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 렌더링</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 애니메이션" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-애니메이션.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 애니메이션</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 엔진, 에디터, 빌드" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-엔진,-에디터,-빌드.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 엔진, 에디터, 빌드</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 외부 플러그인" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-외부-플러그인.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 외부 플러그인</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 주요 언리얼 빌드 에러별 대처 방안" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-주요-언리얼-빌드-에러별-대처-방안.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 주요 언리얼 빌드 에러별 대처 방안</a>]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/디버깅-기록-인덱스.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/디버깅 기록 인덱스.md</guid><pubDate>Thu, 11 Dec 2025 04:49:25 GMT</pubDate></item><item><title><![CDATA[Procedural Dungeon 플러그인 분석]]></title><description><![CDATA[Note
BenPython님의 Procedural Dungeon 플러그인을 분석한 글입니다.
Github: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/BenPyton/ProceduralDungeon" target="_self">https://github.com/BenPyton/ProceduralDungeon</a>
※ 버전 3.6.0부터 MIT 라이센스를 사용하지 않기 때문에 분석은 3.5.1 버전 기준임.
언리얼 에디터에 추가될 기능들이 정의되어 있다.에디터 모듈의 메인 엔트리를 정의하며, 언리얼 에디터 및 세팅 모듈에 변경사항을 적용한다.
에셋 카테고리에 타입 추가 (StartupModule)
// 에셋 툴즈 모듈
IAssetTools&amp; AssetToolsModule = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;("AssetTools").Get();
// 새 에셋 카테고리를 등록한다.
AssetTypeCategory = AssetToolsModule.RegisterAdvancedAssetCategory(...);
// 새 에셋 타입을 등록한다.
TSharedPtr&lt;FAssetTypeActions_RoomData&gt; RoomDataAction = ...;
AssetToolsModule.RegisterAssetTypeActions(RoomDataAction.ToSharedRef()); 디테일 패널 레이아웃 추가 (StartupModule)
// 프로퍼티 에디터 모듈
FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;("PropertyEditor");
// 커스텀 타입에 대한 커스텀 프로퍼티 타입 레이아웃을 추가한다.
PropertyModule.RegisterCustomPropertyTypeLayout(...);
// Mark dirty
PropertyModule.NotifyCustomizationModuleChanged(); 프로젝트 설정 추가 (RegisterSettings)
// 세팅 모듈
ISettingsModule* SettingsModule = FModuleManager::GetModulePtr&lt;ISettingsModule&gt;("Settings"));
// 새 설정 카테고리 추가
ISettingsSectionPtr SettingsSection = SettingsModule-&gt;RegisterSettings(...);
프로젝트 설정의 공용 RoomUnit이 아니라 테마별로 다른 RoomUnit을 사용하게 되면서 에디터 코드도 편집할 필요가 있게 되었다.
기존의 방식은 모든 로직에서 전역적으로 설정에 있는 RoomUnit을 가져와서 사용한다. (ProceduralDungeonUtils/Dungeon::RoomUnit())
에디터 편집 / 생성 시점에서 테마별 데이터에셋에 기록된 룸 유닛을 사용해야 하므로 어쩔 수 없이 전부 검색해서 로직을 수정해주는 방법밖에 없다. 눈물이 나온다.메인 모듈.
ADungeonGeneratorBase, ADungeonGenerator : 생성을 담당하는 메인 액터.
UDungeonGraph : 룸들로 구성된 그래프. 룸을 관리하고 Level streaming 명령을 내리는 주체라 제일 중요해보임.
URoom : 개별 룸 객체. Level Streaming을 수행하는 단위가 된다.
던전 생성기 베이스 클래스. 주요 동작은 다음과 같다.
생성자에서 시드(ADungeonGeneratorBase::Seed) 초기화 / UDungeonGraph 객체 (ADungeonGeneratorBase::Graph) 생성
EndPlay에서 Graph-&gt;UnloadAllRooms() -&gt; Each ARoom-&gt;Destroy() 호출
Tick에서 OnStateTick()을 호출하여 상태 전환 및 페이즈 전환
Generate()를 호출할 경우 EGeneratorFlags::Generating을 켜서 OnStateTick에서 Idle 페이즈 -&gt; Generation 페이즈로 전환 / OnPreGeneration() 호출 -&gt; Navigation System 빌딩 락 -&gt; Graph 클리어 -&gt; OnStateBegin()의 EGenerationState::Generation 케이스에서 CreateDungeon() 호출 -&gt; Initialization 페이즈로 전환.
OnStateTick의 EGenerationState::Initialization 케이스에서 Graph의 모든 룸에 대해 RoomData의 구성이 완료되었는지 확인 (Graph-&gt;AreRoomsReady() -&gt; Each ARoom-&gt;IsRoomReady()) -&gt; 완료되었을 때 Load 페이즈로 전환 / Graph-&gt;LoadAllRooms() 호출
CreateRoomInstance() 에서 새 URoom 객체 생성
AddRoomToDungeon() 에서 URoom을 부모 노드의 자식으로 연결 (Graph-&gt;TryConnectDoor(), Graph-&gt;AddRoom()) -&gt; OnRoomAdded() 호출
여기서 CreateDungeon()을 호출하는 부분과 Graph-&gt;LoadAllRooms()를 호출하는 부분이 핵심이다.
CreateDungeon_Implementation
던전 생성 메인 로직이 여기 들어있다. StartNewDungeon() -&gt; OnGenerationInit()
ChooseFirstRoomData() -&gt; 선택된 URoomData를 그래프 루트로 설정.
DFS/BFS 로직 돌면서 AddNewRooms() 호출 -&gt; false, 즉 더는 추가를 못 하면 탈출.
FinalizeDungeon() -&gt; 그래프에게 UDungeonGraph::InitRooms() 호출 명령 / InitializeDungeon()
기타 주요 함수 목록
AddNewRooms() ChooseNextRoomData() (유저가 오버라이드 해야 되는 함수) 호출 -&gt; 선택된 룸 기준으로 부모 룸과 호환 가능한 Connection이 있는지 체크 (FDoorDef::AreCompatible())
유효한 룸이면 CreateRoomInstance() 호출하여 임시 URoom객체 생성.
TryPlaceRoom() 호출하여 다른 룸들과 오버랩 체크
일정 트라이 안에(Dungeon::MaxRoomPlacementTryBeforeGivingUp()) 성공하면 AddRoomToDungeon() 호출 -&gt; OnRoomAdded / 실패하면 OnFailedToAddRoom() 호출 룸들로 구성된 그래프. 룸을 관리하고 Level streaming 명령을 내리는 주체다.
주요 동작은 다음과 같다.
LoadAllRooms() 에서 그래프를 이루는 모든 룸에 대해 URoom::Instantiate()를 호출한다.
InitRooms() : 던전 그래프 구성이 완료된 후 호출된다. 룸들 간의 Connection 정보를 기반으로 DungeonGraph 내의 RoomConnections 배열 구성 개별 룸 객체. Level Streaming을 수행하는 단위가 된다.
주요 동작은 다음과 같다.// 던전 그래프 구성 관련
Init() 로컬 위치, 방향 영 초기화 후 전달된 RoomData로 Connections 개수 초기화 // 레벨 스트리밍 관련
Instantiate() RoomData에서 UWorld 경로를 구한다.
그래프 상의 로컬 위치를 기준으로 레벨 스트리밍을 진행할 위치, 회전값 초기화
LoadInstance() 호출, ULevelStreamingDynamic* Instance 주소 저장. LoadInstance() ULevelStreamingDynamic::LoadLevelInstanceBySoftObjectPtr() 호출. IsInstanceLoaded() ULevelStreamingDynamic* Instance가 nullptr가 아니라면 Instance-&gt;GetLevelStreamingState()를 통해 비동기 레벨 스트리밍 상태를 얻을 수 있다.
ELevelStreamingState는 Removed, Unloaded, FailedToLoad, Loading, LoadedNotVisible, MakingVisible, LoadedVisible, MakingInvisible로 구분되며, Loading보다 높은 값이면 로딩이 끝났다고 취급할 수 있다. (쩐다) ]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/참고자료/procedural-dungeon-플러그인-분석.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/참고자료/Procedural Dungeon 플러그인 분석.md</guid><pubDate>Thu, 11 Dec 2025 04:26:47 GMT</pubDate></item><item><title><![CDATA[if vs switch]]></title><description><![CDATA[if는 최적화가 들어가긴 하지만 기본적으로 모든 조건을 판별하는 방식으로 동작한다.
반면 switch 문은 점프테이블(해시테이블)을 만들어 O(1)의 비용을 보장한다. 모든 case가 정수형(또는 정수형으로 캐스팅이 가능한 열거형)이어야 하는 이유도 컴파일 단계에서 점프 테이블을 만들어야 하기 때문이다.]]></description><link>0-발행완료/c,-c++/기타/if-vs-switch.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/if vs switch.md</guid><pubDate>Tue, 09 Dec 2025 13:54:11 GMT</pubDate></item><item><title><![CDATA[포인터]]></title><description><![CDATA[메모리 주소를 저장하는 변수. 64비트 환경에선 일반적으로 8바이트 크기를 사용한다.int* p; // int형 변수의 주소를 저장하는 int형 포인터
int *p, int * p, int* p 뭘로 해도 상관 없지만 '이 타입은 int형 포인터 타입이다'라는 의미 전달에 있어서나, 역참조 연산자와의 구별을 위해서나 int* 형태로 타입에 붙여 쓰는 편이 가독성이 좋다.
단 배열 포인터나 함수 포인터를 선언할 땐 이름과 * 연산자를 괄호로 묶어야 하므로, 이럴 땐 int (*p) 처럼 쓰거나 아예 int(*p) 또는 int(* p) 라고 붙여 쓴다.const 속성은 기본적으로 좌측에 있는 요소에 상수성을 부여하지만, 선언할 타입에 대해 부여할 땐 예외적으로 const가 좌측에 놓이는 걸 허용한다.const int*는 선언된 int 타입에 대한 상수성을 의미한다. 따라서 이 포인터의 값을 계속 바꿀 수는 있지만, 이 포인터를 역참조하여 값을 바꿀 수는 없다.만약 '포인터' 자체에 상수성을 부여하고 싶다면 int* const 라고 써야한다. 이러면 초기화할 때 저장된 주소에서 값을 바꿀 수 없다.함수의 주소를 담는 포인터. std::function 이나 delegate 등의 원형이다.
T(*name)(params) 형태로 선언한다.함수명을 통해 호출하는 것과 함수 포인터를 통해 호출하는 건 본질적으로 코드 영역에 특정 주소로 가 스택프레임을 스택에 올리는 동일한 동작이다. 예컨대int Func(int x) { ... }; int main()
{ // 이 동작과 Func(10); // 이 동작은 본질적으로 같다. int(*fp)(int) = Func; fp(10);
}
가리키는 자료형이 정해지지 않은 포인터. 타입 정보가 없으므로 역참조할 수 없다. C에는 박싱/언박싱의 개념이 없으므로 사용할 땐 형변환해야 한다.void* vp; int x = 10;
vp = &amp;x; cout &lt;&lt; *(int*)vp
]]></description><link>0-발행완료/c,-c++/문법/포인터.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/포인터.md</guid><pubDate>Tue, 09 Dec 2025 13:47:36 GMT</pubDate></item><item><title><![CDATA[포인터와 배열]]></title><description><![CDATA[Note
C++에선 훨씬 쉽고 편리하며 직관적인 가변 길이 배열 STL 컨테이너를 사용하도록 하자.
C/C++에서 배열은 특정한 크기의 할당된 메모리 블록을 의미한다. 이 때 배열명은 특별한 의미를 가진다.
배열명 arr은 &amp;arr[0], 즉 배열의 첫 번째 요소의 주소를 가리키는 포인터로 암시적으로 변환될 수 있다. 암시적으로 변환될 수 있을 뿐이지 배열명이 포인터라는 소리는 아니다.
단, sizeof(arr)은 예외적으로 배열의 전체 크기를 반환한다.
이외의 경우엔 '배열 전체의 시작주소'를 의미하려면 &amp;arr을 사용해야 한다. 실제로 arr + 1은 &amp;arr[0] + 1로 암시적으로 변환되므로 두 번째 요소의 시작 주소이며, &amp;arr + 1은 배열 전체의 크기 다음의 주소를 반환한다.
sizeof(&amp;arr)에서는 sizeof에 배열의 시작주소가 담겨 일반 포인터로 취급되어 포인터의 크기(8바이트)를 반환함에 주의하자.
이 차이 때문에 다소 헷갈리는 문법이 된다. 다음은 배열명에 대한 주소 연산이 가지는 의미이다.// int arr[4]; arr -&gt; 첫 번째 요소의 주소 (&amp;arr[0])
&amp;arr -&gt; 배열의 시작 주소 arr + 1 -&gt; 두 번째 요소의 주소 (&amp;arr[1])
&amp;arr + 1 -&gt; 배열의 크기(16바이트)만큼 이동한 주소
T(*name)[size] 꼴로 선언되는 포인터는 해당 크기의 배열만 가리킬 수 있는 배열 포인터이다.int arr[5]; // 일반 포인터로 arr의 첫번째 요소 하나를 가리킬 수 있다.
int* p1 = arr; // 배열 포인터로 arr 전체를 가리킬 수 있다.
int (*pArr)[5] = &amp;arr;
배열 포인터의 의의는 배열의 크기 정보를 유지하면서 가리킬 수 있다는 데에 있다. 배열을 일반 포인터로 가리키게 되면, 그냥 시작 요소의 주소만 저장될 뿐 크기 정보는 잃어버리게 된다.다음과 같은 경우에 사용한다.
다차원 배열을 포인터로 가리킬 때. 저차원 배열의 크기를 알아야 다음 요소가 어디서부터 시작하는 지 알 수 있으므로 접근이 가능하다.
함수의 인자로 배열을 전달할 때. 배열 포인터를 사용하면 크기 정보를 잃지 않고 전달할 수 있으며, 버퍼 오버런을 방지할 수 있다. 만약 배열 포인터를 사용하지 않으면, 별도로 요소의 개수를 인자로 전달해서 사용해야 한다.
첨자 연산 [n]은 사실 *(arr + n)과 동일하다.
즉, 시작 주소로부터 (요소의 크기 x n) 만큼 이동한 뒤 역참조하는 연산이다.3x4 크기의 int형 배열을 담으려면 int[4] 크기의 배열 포인터에 시작 요소(int[4] 배열)의 주소를 담거나, int[3][4] 크기의 배열 포인터에 배열 전체를 담으면 된다.int arr[3][4] = { { 0, 1, 2, 3 }, { 4, 5, 6, 7 }, { 8, 9, 10, 11 } };
int(*pArr1)[4] = arr;
int(*pArr2)[3][4] = &amp;arr;
전자의 경우엔 크기 4 배열이 '3개 있다는' 정보는 소실된다. 이는 1차원 배열을 일반 포인터로 가리키게 했을 때 배열의 크기 정보가 소실되는 것과 똑같은 상황이다.접근할 땐 똑같이 첨자 연산자를 이용하면 된다.pArr1[1][3]; // 2번째 요소의 4번째 요소, arr[1][3]
// = *(*(pArr1 + 1) + 3); // 동일한 크기의 배열 포인터를 통해 접근할 땐 첫 번쨰 요소만 존재한다.
pArr2[0][1][3]; // 첫 번째 요소의 2번째 요소의 4번째 요소, arr[1][3]
// = *(*(*(pArr2 + 0) + 1) + 3);
pArr1은 int[4] 크기를, pArr2는 int[3][4] 크기를 가리키는 포인터이므로, 주소연산을 했을 때 그 크기만큼 이동하는 것을 볼 수 있다.다차원 배열도 똑같다.int arr[2][3][4] = { { { 11, 22, 33, 44 }, { 55, 66, 77, 88 }, { 99, 110, 121, 132 } }, { { 111, 122, 133, 144 }, { 155, 166, 177, 188 }, { 199, 1110, 1121, 1132 } }
}; int(*pArr1)[3][4] = arr; // 첫 번째 요소 (int[3][4])를 가리키는 포인터
int(*pArr2)[2][3][4] = &amp;arr; // 배열 전체를 가리키는 포인터 cout &lt;&lt; pArr1[0][2][1] &lt;&lt; endl;
cout &lt;&lt; *( *( *(pArr1 + 0) + 2) + 1);
]]></description><link>0-발행완료/c,-c++/문법/포인터와-배열.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/포인터와 배열.md</guid><pubDate>Tue, 09 Dec 2025 13:41:16 GMT</pubDate></item><item><title><![CDATA[변수의 종류]]></title><description><![CDATA[함수 스코프 내에서 생성되고, 함수의 스택 프레임과 함께 제거되는 스택 메모리 영역의 변수.
키워드는 auto. 생략할 수 있다.void Func()
{ auto int x = 10;
}
함수 스코프 외부에서 생성되어, 프로그램의 실행과 함께 생성되고 종료될 때 해제되는 데이터 영역의 변수. 정적 변수와 달리 모든 목적 파일에서 유일하다. 다른 목적파일에서 선언된 전역 변수에 접근하려면 extern 키워드를 사용한다.
초기화되지 않고 선언되면 데이터 영역의 bss 영역에 생성되어 0 초기화된다.자신의 스코프 내에서 해제되지 않고 사용되는 데이터 영역의 변수. 함수 스코프 안에서 선언되면 해당 함수 내부에서 호출자가 누구냐와 상관없이 고유하게 사용되며, 함수 스코프 외부에서 선언되면 현재 목적 파일 안에서 고유하게 사용된다.
키워드는 static.
초기화되지 않고 선언되면 데이터 영역의 bss 영역에 생성되어 0 초기화된다.static int x; void Func()
{ static int y;
}
CPU 레지스터에 직접 생성되는 변수. 처리 속도가 매우 빠르지만 관리가 어렵고 주소 접근도 불가능하며 전역변수는 애초에 레지스터에 생성할 수 없고 생성을 시도한다고 매번 생성을 해주는 것도 아니다. 하드웨어 레벨이 아니라면 쓸 일은 없다.
키워드는 register.]]></description><link>0-발행완료/c,-c++/문법/변수의-종류.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/변수의 종류.md</guid><pubDate>Tue, 09 Dec 2025 13:29:40 GMT</pubDate></item><item><title><![CDATA[용어 정리]]></title><description><![CDATA[ 예약어와 식별자
int age;에서, int와 같이 미리 약속된 키워드가 예약어, age와 같이 임의로 붙인 이름을 식별자라고 한다. 연산자
new 나 &gt; 등과 같이 컴파일러가 특수하게 처리하는 예약어. 단항(단방향), 이항(양방향), 삼항 연산자로 나뉜다. Short circuit rule
일부 이항 연산자에서 '한 쪽을 검사하는 것만으로도 true/false라는 결론이 도출되어' 다른 쪽의 검사를 생략하는 최적화 기법.
예컨대 if ( true || false ) 에서 좌항이 true면 or 연산은 무조건 true이므로 우항은 검사하지 않는다. ]]></description><link>0-발행완료/c,-c++/기타/용어-정리.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/용어 정리.md</guid><pubDate>Tue, 09 Dec 2025 13:11:04 GMT</pubDate></item><item><title><![CDATA[문자열 Formatting]]></title><description><![CDATA[printf("%08.2f", 3.141592f); // 00003.14
#include &lt;iomanip&gt; cout &lt;&lt; setprecision(3) &lt;&lt; setw(8) &lt;&lt; setfill('0') &lt;&lt; 3.141592f; // 00003.14
cout &lt;&lt; std::format("{:&gt;10}", 123) &lt;&lt; "\n"; // " 123"
cout &lt;&lt; std::format("{:^10}", "hi") &lt;&lt; "\n"; // " hi "
cout &lt;&lt; std::format("{:08X}", 255) &lt;&lt; "\n"; // 000000FF
]]></description><link>0-발행완료/c,-c++/문법/문자열-formatting.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/문자열 Formatting.md</guid><pubDate>Tue, 09 Dec 2025 13:04:34 GMT</pubDate></item><item><title><![CDATA[Drawing 2025-12-02 23.13.50]]></title><description><![CDATA[동적 생성 미니맵에디터 디테일창편집하기메타휴먼에Dissolving 이펙트입히기상호작용과InteractableComponent]]></description><link>excalidraw/drawing-2025-12-02-23.13.50.excalidraw.html</link><guid isPermaLink="false">Excalidraw/Drawing 2025-12-02 23.13.50.excalidraw.md</guid><pubDate>Tue, 02 Dec 2025 14:36:28 GMT</pubDate></item></channel></rss>