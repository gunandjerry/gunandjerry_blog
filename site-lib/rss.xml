<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[건제리의 블로그]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>건제리의 블로그</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 11 Dec 2025 05:06:44 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 11 Dec 2025 05:06:37 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[index]]></title><description><![CDATA[안녕하세요. 게임 개발자 지망생 이건제입니다.포트폴리오 페이지 링크를 목적으로 작성했던 문서들중 일부를 온라인으로 발행한 블로그입니다.포트폴리오 페이지는 아래 주소에서 보실 수 있습니다.
<a data-tooltip-position="top" aria-label="https://gunandjerry.github.io/" rel="noopener nofollow" class="external-link is-unresolved" href="https://gunandjerry.github.io/" target="_self">gunandjerry의 포트폴리오</a>프로젝트 관련 문서들은 쉽게 찾아보실 수 있게 인덱스 문서를 통해 정리해두었습니다.<br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/언리얼 엔진 공부 기록 인덱스" data-href="0 발행완료/언리얼 엔진/언리얼 엔진 공부 기록 인덱스" href="0-발행완료/언리얼-엔진/언리얼-엔진-공부-기록-인덱스.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 엔진 공부 기록 인덱스</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 기록 인덱스" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 기록 인덱스" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-기록-인덱스.html" class="internal-link" target="_self" rel="noopener nofollow">2504_F급헌터생존기/구현 기록 인덱스</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/디버깅 기록 인덱스" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/디버깅 기록 인덱스" href="0-발행완료/프로젝트/2504_f급헌터생존기/디버깅-기록-인덱스.html" class="internal-link" target="_self" rel="noopener nofollow">2504_F급헌터생존기/디버깅 기록 인덱스</a>]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Thu, 11 Dec 2025 05:05:19 GMT</pubDate></item><item><title><![CDATA[언리얼 엔진 공부 기록 인덱스]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/그래픽 옵션 변경하기" data-href="0 발행완료/언리얼 엔진/엔진 지식/그래픽 옵션 변경하기" href="0-발행완료/언리얼-엔진/엔진-지식/그래픽-옵션-변경하기.html" class="internal-link" target="_self" rel="noopener nofollow">그래픽 옵션 변경하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/네비게이션 시스템" data-href="0 발행완료/언리얼 엔진/엔진 지식/네비게이션 시스템" href="0-발행완료/언리얼-엔진/엔진-지식/네비게이션-시스템.html" class="internal-link" target="_self" rel="noopener nofollow">네비게이션 시스템</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Level Travel" data-href="0 발행완료/언리얼 엔진/엔진 지식/Level Travel" href="0-발행완료/언리얼-엔진/엔진-지식/level-travel.html" class="internal-link" target="_self" rel="noopener nofollow">Level Travel</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/LevelScriptActor, WorldSettings" data-href="0 발행완료/언리얼 엔진/엔진 지식/LevelScriptActor, WorldSettings" href="0-발행완료/언리얼-엔진/엔진-지식/levelscriptactor,-worldsettings.html" class="internal-link" target="_self" rel="noopener nofollow">LevelScriptActor, WorldSettings</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/모듈" data-href="0 발행완료/언리얼 엔진/엔진 지식/모듈" href="0-발행완료/언리얼-엔진/엔진-지식/모듈.html" class="internal-link" target="_self" rel="noopener nofollow">모듈</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Event Dispatcher" data-href="0 발행완료/언리얼 엔진/엔진 지식/Event Dispatcher" href="0-발행완료/언리얼-엔진/엔진-지식/event-dispatcher.html" class="internal-link" target="_self" rel="noopener nofollow">Event Dispatcher</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/팁과 노하우/효율적인 게임플레이 태그 구조" data-href="0 발행완료/언리얼 엔진/팁과 노하우/효율적인 게임플레이 태그 구조" href="0-발행완료/언리얼-엔진/팁과-노하우/효율적인-게임플레이-태그-구조.html" class="internal-link" target="_self" rel="noopener nofollow">효율적인 게임플레이 태그 구조</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼의 라이트" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼의 라이트" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼의-라이트.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼의 라이트</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/텍스쳐 스트리밍 풀" data-href="0 발행완료/언리얼 엔진/엔진 지식/텍스쳐 스트리밍 풀" href="0-발행완료/언리얼-엔진/엔진-지식/텍스쳐-스트리밍-풀.html" class="internal-link" target="_self" rel="noopener nofollow">텍스쳐 스트리밍 풀</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/플러그인" data-href="0 발행완료/언리얼 엔진/엔진 지식/플러그인" href="0-발행완료/언리얼-엔진/엔진-지식/플러그인.html" class="internal-link" target="_self" rel="noopener nofollow">플러그인</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/현지화" data-href="0 발행완료/언리얼 엔진/엔진 지식/현지화" href="0-발행완료/언리얼-엔진/엔진-지식/현지화.html" class="internal-link" target="_self" rel="noopener nofollow">현지화</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/디테일 창에서 열거형 복수 선택하기" data-href="0 발행완료/언리얼 엔진/엔진 지식/디테일 창에서 열거형 복수 선택하기" href="0-발행완료/언리얼-엔진/엔진-지식/디테일-창에서-열거형-복수-선택하기.html" class="internal-link" target="_self" rel="noopener nofollow">디테일 창에서 열거형 복수 선택하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/메타휴먼 에디터 사용법" data-href="0 발행완료/언리얼 엔진/엔진 지식/메타휴먼 에디터 사용법" href="0-발행완료/언리얼-엔진/엔진-지식/메타휴먼-에디터-사용법.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼 에디터 사용법</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 비헤이비어 트리" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 비헤이비어 트리" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-비헤이비어-트리.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 비헤이비어 트리</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/에셋 리디렉션(Unreal Redirector)" data-href="0 발행완료/언리얼 엔진/엔진 지식/에셋 리디렉션(Unreal Redirector)" href="0-발행완료/언리얼-엔진/엔진-지식/에셋-리디렉션(unreal-redirector).html" class="internal-link" target="_self" rel="noopener nofollow">에셋 리디렉션(Unreal Redirector)</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Cooking" data-href="0 발행완료/언리얼 엔진/엔진 지식/Cooking" href="0-발행완료/언리얼-엔진/엔진-지식/cooking.html" class="internal-link" target="_self" rel="noopener nofollow">Cooking</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/루트 모션" data-href="0 발행완료/언리얼 엔진/엔진 지식/루트 모션" href="0-발행완료/언리얼-엔진/엔진-지식/루트-모션.html" class="internal-link" target="_self" rel="noopener nofollow">루트 모션</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/애니메이션 리타게팅" data-href="0 발행완료/언리얼 엔진/엔진 지식/애니메이션 리타게팅" href="0-발행완료/언리얼-엔진/엔진-지식/애니메이션-리타게팅.html" class="internal-link" target="_self" rel="noopener nofollow">애니메이션 리타게팅</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Widget Reflector" data-href="0 발행완료/언리얼 엔진/엔진 지식/Widget Reflector" href="0-발행완료/언리얼-엔진/엔진-지식/widget-reflector.html" class="internal-link" target="_self" rel="noopener nofollow">Widget Reflector</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/UI(UMG)" data-href="0 발행완료/언리얼 엔진/엔진 지식/UI(UMG)" href="0-발행완료/언리얼-엔진/엔진-지식/ui(umg).html" class="internal-link" target="_self" rel="noopener nofollow">UI(UMG)</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/UMG UPROPERTY 바인딩 방식" data-href="0 발행완료/언리얼 엔진/엔진 지식/UMG UPROPERTY 바인딩 방식" href="0-발행완료/언리얼-엔진/엔진-지식/umg-uproperty-바인딩-방식.html" class="internal-link" target="_self" rel="noopener nofollow">UMG UPROPERTY 바인딩 방식</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Blueprint Pure 함수" data-href="0 발행완료/언리얼 엔진/엔진 지식/Blueprint Pure 함수" href="0-발행완료/언리얼-엔진/엔진-지식/blueprint-pure-함수.html" class="internal-link" target="_self" rel="noopener nofollow">Blueprint Pure 함수</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Assertion, Logging" data-href="0 발행완료/언리얼 엔진/엔진 지식/Assertion, Logging" href="0-발행완료/언리얼-엔진/엔진-지식/assertion,-logging.html" class="internal-link" target="_self" rel="noopener nofollow">Assertion, Logging</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/ConstructorHelpers" data-href="0 발행완료/언리얼 엔진/엔진 지식/ConstructorHelpers" href="0-발행완료/언리얼-엔진/엔진-지식/constructorhelpers.html" class="internal-link" target="_self" rel="noopener nofollow">ConstructorHelpers</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Delegate" data-href="0 발행완료/언리얼 엔진/엔진 지식/Delegate" href="0-발행완료/언리얼-엔진/엔진-지식/delegate.html" class="internal-link" target="_self" rel="noopener nofollow">Delegate</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/액터 생성과 동시에 값 초기화하기" data-href="0 발행완료/언리얼 엔진/엔진 지식/액터 생성과 동시에 값 초기화하기" href="0-발행완료/언리얼-엔진/엔진-지식/액터-생성과-동시에-값-초기화하기.html" class="internal-link" target="_self" rel="noopener nofollow">액터 생성과 동시에 값 초기화하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 스마트 포인터 타입" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 스마트 포인터 타입" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-스마트-포인터-타입.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 스마트 포인터 타입</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 오브젝트(UObject)의 이해" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 오브젝트(UObject)의 이해" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-오브젝트(uobject)의-이해.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 오브젝트(UObject)의 이해</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/언리얼 타입" data-href="0 발행완료/언리얼 엔진/엔진 지식/언리얼 타입" href="0-발행완료/언리얼-엔진/엔진-지식/언리얼-타입.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 타입</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Multiplayer in Unreal Engine How to Understand Network Replication by Alex Forsythe" data-href="0 발행완료/언리얼 엔진/엔진 지식/Multiplayer in Unreal Engine How to Understand Network Replication by Alex Forsythe" href="0-발행완료/언리얼-엔진/엔진-지식/multiplayer-in-unreal-engine-how-to-understand-network-replication-by-alex-forsythe.html" class="internal-link" target="_self" rel="noopener nofollow">Multiplayer in Unreal Engine How to Understand Network Replication by Alex Forsythe</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/Seamless Travel vs Non-Seamless Travel" data-href="0 발행완료/언리얼 엔진/엔진 지식/Seamless Travel vs Non-Seamless Travel" href="0-발행완료/언리얼-엔진/엔진-지식/seamless-travel-vs-non-seamless-travel.html" class="internal-link" target="_self" rel="noopener nofollow">Seamless Travel vs Non-Seamless Travel</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/SteamWorks SDK" data-href="0 발행완료/언리얼 엔진/엔진 지식/SteamWorks SDK" href="0-발행완료/언리얼-엔진/엔진-지식/steamworks-sdk.html" class="internal-link" target="_self" rel="noopener nofollow">SteamWorks SDK</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/USTRUCT 리플리케이트" data-href="0 발행완료/언리얼 엔진/엔진 지식/USTRUCT 리플리케이트" href="0-발행완료/언리얼-엔진/엔진-지식/ustruct-리플리케이트.html" class="internal-link" target="_self" rel="noopener nofollow">USTRUCT 리플리케이트</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/프로파일링/언리얼 인사이트(Insight)" data-href="0 발행완료/언리얼 엔진/프로파일링/언리얼 인사이트(Insight)" href="0-발행완료/언리얼-엔진/프로파일링/언리얼-인사이트(insight).html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 인사이트(Insight)</a><br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 해부하기/언리얼 초기화, 액터 스폰, 클라 접속시 동작 순서" data-href="0 발행완료/언리얼 엔진/엔진 해부하기/언리얼 초기화, 액터 스폰, 클라 접속시 동작 순서" href="0-발행완료/언리얼-엔진/엔진-해부하기/언리얼-초기화,-액터-스폰,-클라-접속시-동작-순서.html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 초기화, 액터 스폰, 클라 접속시 동작 순서</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 해부하기/The Unreal Engine Game Framework - From int main to BeginPlay (by Alex Forsythe)" data-href="0 발행완료/언리얼 엔진/엔진 해부하기/The Unreal Engine Game Framework - From int main to BeginPlay (by Alex Forsythe)" href="0-발행완료/언리얼-엔진/엔진-해부하기/the-unreal-engine-game-framework-from-int-main-to-beginplay-(by-alex-forsythe).html" class="internal-link" target="_self" rel="noopener nofollow">The Unreal Engine Game Framework - From int main to BeginPlay (by Alex Forsythe)</a>]]></description><link>0-발행완료/언리얼-엔진/언리얼-엔진-공부-기록-인덱스.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/언리얼 엔진 공부 기록 인덱스.md</guid><pubDate>Thu, 11 Dec 2025 05:03:51 GMT</pubDate></item><item><title><![CDATA[(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20251015182408.png" src="♣vaultstorage/attachment/pasted-image-20251015182408.png" target="_self" style="width: 350px; max-width: 100%;">
게이트에서 밤로비로 이동할 때 혹은 밤로비에서 낮로비로 이동할 때 발생.
아마도? PlayerCameraManager-&gt;SetViewTarget 함수에 원인이 있지 않을까 싶음
콘솔에 showdebug camera 쳐서 Default main viewtarget 플레이어 맞는지 확인정상일 때 이런 모양<br><img alt="♣VaultStorage/attachment/Pasted image 20251015185849.png" src="♣vaultstorage/attachment/pasted-image-20251015185849.png" target="_self" style="width: 500px; max-width: 100%;">고간뷰일 때 이런 모양<br><img alt="♣VaultStorage/attachment/Pasted image 20251017143937.png" src="♣vaultstorage/attachment/pasted-image-20251017143937.png" target="_self" style="width: 475px; max-width: 100%;">Z = 92.6으로 동일한 걸 보면 카메라는 제대로 머리에 달려있다.더 테스트해본 결과 메타휴먼 BP로부터 스켈레탈 메쉬를 가져오는 ChangeMetahuman 함수와 관련이 있는 것으로 보인다.
게임을 시작하고 ChangeMetahuman 호출 전 이런 에러가 뜰 때 고간뷰로 이동하는 것으로 보인다.Blueprint Runtime Error: "Accessed None trying to read (real) property K2Node_DynamicCast_AsBP_Player in not an UClass". Node: ChangeMetahuman Graph: EventGraph Function: Execute Ubergraph BP FHPlayer State Blueprint: BP_FHPlayerState
또, 레벨을 이동할 때 메타휴먼 메쉬가 선택한 게 아닌 기본 남성1 외형으로 변하는 경우가 있었는데, 이 문제와 관련이 있는 것으로 보인다.관련 로직을 쭉 따라가며 확인해보았다.<br><img alt="♣VaultStorage/attachment/Pasted image 20251017144958.png" src="♣vaultstorage/attachment/pasted-image-20251017144958.png" target="_self" style="width: 475px; max-width: 100%;">문제의 원인은 블루프린트 그래프 실수였다. 위 그래프에서 0.2초마다 클라이언트의 폰을 다시 체크하는데, Valid가 되었을 때 다시 캐스팅을 하지 않아서 null이 전달되고, set view target이 null이 되면서 캡슐 중앙으로 기본 카메라를 사용하게 되었던 것.아래와 같이 고쳐야 한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20251017145123.png" src="♣vaultstorage/attachment/pasted-image-20251017145123.png" target="_self" style="width: 500px; max-width: 100%;">블루프린트 쓰면 실수가 너무 잦다. 제대로 못 만들 거면 최대한 쓰지 말아라. 아무리 말을 해도 안 듣는다. 늘 뒷처리는 내 몫...]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1015)-클라이언트-카메라가-레벨-트레벨-후-캡슐-중앙으로-이동하는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제.md</guid><pubDate>Thu, 11 Dec 2025 04:49:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[디버깅 기록 인덱스]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0603)-dynamic-level-streaming으로-로드된-액터의-guid가-어긋나는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0605) 포인트 라이트가 벽을 뚫고 나가는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0605) 포인트 라이트가 벽을 뚫고 나가는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0605)-포인트-라이트가-벽을-뚫고-나가는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0605) 포인트 라이트가 벽을 뚫고 나가는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0616) 위젯 델리게이트 중복 등록 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0616) 위젯 델리게이트 중복 등록 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0616)-위젯-델리게이트-중복-등록-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0616) 위젯 델리게이트 중복 등록 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0617)-동적-스트리밍되는-룸-레벨-안에-움직이는-액터가-있을-때-onnavigationgenerationfinisheddelegate-이벤트가-발생하지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) 던전 안에서 크리쳐 AI가 비활성화되는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) 던전 안에서 크리쳐 AI가 비활성화되는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0626)-던전-안에서-크리쳐-ai가-비활성화되는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0626) 던전 안에서 크리쳐 AI가 비활성화되는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0626)-tsoftobjectptr로-서버와-클라가-각각-비동기로-에셋을-로드할-때,-리플리케이트-과정에서-guid-불일치-경고에-걸리는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0627)-애니메이션-시퀀스의-특정-포즈에-대한-애님-시퀀스를-만들었더니-스켈레탈-메쉬의-모양이-이상해지는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-메타휴먼-옷-메쉬가-특정-lod에서-움직이지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-메타휴먼의-특정-파츠만-바디-애니메이션을-상속하지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0704)-같은-스켈레톤을-사용하는-캐릭터와-애니메이션-간의-본-translation-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0707) ‘GEngine not initialized!’ 패키징 에러" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0707) ‘GEngine not initialized!’ 패키징 에러" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0707)-‘gengine-not-initialized!’-패키징-에러.html" class="internal-link" target="_self" rel="noopener nofollow">(0707) ‘GEngine not initialized!’ 패키징 에러</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0721)-tracesingle론-안-되고-tracemult로만-감지되는-액터.html" class="internal-link" target="_self" rel="noopener nofollow">(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0730)-스트리밍된-레벨이-있을-때-서버가-먼저-travel을-하면-클라이언트에서-worldsettings가-nullptr로-바뀌는-현상.html" class="internal-link" target="_self" rel="noopener nofollow">(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0731) DX12 GroomComponent 렌더링 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0731) DX12 GroomComponent 렌더링 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0731)-dx12-groomcomponent-렌더링-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0731) DX12 GroomComponent 렌더링 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0801) 프로젝트와 언리얼 엔진 연동 실패 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0801) 프로젝트와 언리얼 엔진 연동 실패 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0801)-프로젝트와-언리얼-엔진-연동-실패-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0801) 프로젝트와 언리얼 엔진 연동 실패 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0805)-메쉬의-머터리얼로-위젯-렌더-타겟을-입혔는데-일부가-잘리는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible' 경고가 뜨는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible' 경고가 뜨는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0805)-플레이어가-래그돌이-됐다가-복구될-때-‘body-is-set-to-stimulate-physics-but-collision-enabled-is-incompatible'-경고가-뜨는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible' 경고가 뜨는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0806)-카메라를-따라가는-비네트-쿼드가-렉이-걸린-것처럼-뒤늦게-따라오는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0806)-클라이언트에서-자식-uobject에-접근할-때-nullptr참조-발생.html" class="internal-link" target="_self" rel="noopener nofollow">(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0815) 에디터에서 모든 텍스쳐에 'Preview' 라벨이 붙는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0815) 에디터에서 모든 텍스쳐에 'Preview' 라벨이 붙는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0815)-에디터에서-모든-텍스쳐에-'preview'-라벨이-붙는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0815) 에디터에서 모든 텍스쳐에 'Preview' 라벨이 붙는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0923) 나선형 계단 Nav Mesh 베이킹 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0923) 나선형 계단 Nav Mesh 베이킹 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0923)-나선형-계단-nav-mesh-베이킹-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0923) 나선형 계단 Nav Mesh 베이킹 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0924) Failed to load Outer for resource, 레벨 내 메쉬와 마터리얼 로드 실패" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0924) Failed to load Outer for resource, 레벨 내 메쉬와 마터리얼 로드 실패" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0924)-failed-to-load-outer-for-resource,-레벨-내-메쉬와-마터리얼-로드-실패.html" class="internal-link" target="_self" rel="noopener nofollow">(0924) Failed to load Outer for resource, 레벨 내 메쉬와 마터리얼 로드 실패</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0925) GA에서 PlayMontageAndWait Task를 사용할 때, 클라이언트 당사자만 동작하지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0925) GA에서 PlayMontageAndWait Task를 사용할 때, 클라이언트 당사자만 동작하지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0925)-ga에서-playmontageandwait-task를-사용할-때,-클라이언트-당사자만-동작하지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(0925) GA에서 PlayMontageAndWait Task를 사용할 때, 클라이언트 당사자만 동작하지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1015)-클라이언트-카메라가-레벨-트레벨-후-캡슐-중앙으로-이동하는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1015) 클라이언트 카메라가 레벨 트레벨 후 캡슐 중앙으로 이동하는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1017)-터미널-메쉬에-위젯이-그려지지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1018)-클라이언트에서-몽타쥬-재생-중에-이동이-멈추는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 투척된 아이템의 Jittering 현상" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 투척된 아이템의 Jittering 현상" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1018)-클라이언트에서-투척된-아이템의-jittering-현상.html" class="internal-link" target="_self" rel="noopener nofollow">(1018) 클라이언트에서 투척된 아이템의 Jittering 현상</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1029) VOIP Talker Seamless Travel 크래쉬" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1029) VOIP Talker Seamless Travel 크래쉬" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1029)-voip-talker-seamless-travel-크래쉬.html" class="internal-link" target="_self" rel="noopener nofollow">(1029) VOIP Talker Seamless Travel 크래쉬</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1106) 일반 람다 내부에서 멤버 함수 실행 후 캡쳐된 this가 null이 되는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1106) 일반 람다 내부에서 멤버 함수 실행 후 캡쳐된 this가 null이 되는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1106)-일반-람다-내부에서-멤버-함수-실행-후-캡쳐된-this가-null이-되는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1106) 일반 람다 내부에서 멤버 함수 실행 후 캡쳐된 this가 null이 되는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1111) 일반, 관전 HUD가 둘 다 뜨는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1111) 일반, 관전 HUD가 둘 다 뜨는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1111)-일반,-관전-hud가-둘-다-뜨는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">(1111) 일반, 관전 HUD가 둘 다 뜨는 문제</a><br><a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 네트워크" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-네트워크.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 네트워크</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 렌더링" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-렌더링.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 렌더링</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 애니메이션" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-애니메이션.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 애니메이션</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 엔진, 에디터, 빌드" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-엔진,-에디터,-빌드.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 엔진, 에디터, 빌드</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 외부 플러그인" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-외부-플러그인.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 외부 플러그인</a><br>
<a data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 주요 언리얼 빌드 에러별 대처 방안" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-주요-언리얼-빌드-에러별-대처-방안.html" class="internal-link" target="_self" rel="noopener nofollow">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 주요 언리얼 빌드 에러별 대처 방안</a>]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/디버깅-기록-인덱스.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/디버깅 기록 인덱스.md</guid><pubDate>Thu, 11 Dec 2025 04:49:25 GMT</pubDate></item><item><title><![CDATA[구현 기록 인덱스]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/커스텀 어빌리티 태스크" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/커스텀 어빌리티 태스크" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/커스텀-어빌리티-태스크.html" class="internal-link" target="_self" rel="noopener nofollow">커스텀 어빌리티 태스크</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/초기화시 자동으로 GA를 부여하고 태그를 부착하는 커스텀 ASC 만들기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/초기화시 자동으로 GA를 부여하고 태그를 부착하는 커스텀 ASC 만들기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/초기화시-자동으로-ga를-부여하고-태그를-부착하는-커스텀-asc-만들기.html" class="internal-link" target="_self" rel="noopener nofollow">초기화시 자동으로 GA를 부여하고 태그를 부착하는 커스텀 ASC 만들기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/PlayMontageGameplayCue" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/PlayMontageGameplayCue" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/playmontagegameplaycue.html" class="internal-link" target="_self" rel="noopener nofollow">PlayMontageGameplayCue</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 플레이어 스탯 관리" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 플레이어 스탯 관리" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-플레이어-스탯-관리.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 플레이어 스탯 관리</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/상호작용, Interactable Component" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/상호작용, Interactable Component" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/상호작용,-interactable-component.html" class="internal-link" target="_self" rel="noopener nofollow">상호작용, Interactable Component</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼에 Dissolving 이펙트 입히기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼에 Dissolving 이펙트 입히기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼에-dissolving-이펙트-입히기.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼에 Dissolving 이펙트 입히기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼을 플레이어 캐릭터로 사용하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼을 플레이어 캐릭터로 사용하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼을-플레이어-캐릭터로-사용하기.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼을 플레이어 캐릭터로 사용하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼 페이셜 애니메이션" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼 페이셜 애니메이션" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼-페이셜-애니메이션.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼 페이셜 애니메이션</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/공격 반응성 개선하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/공격 반응성 개선하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/공격-반응성-개선하기.html" class="internal-link" target="_self" rel="noopener nofollow">공격 반응성 개선하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 장비 스왑, 착용 모션 동기화" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 장비 스왑, 착용 모션 동기화" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-장비-스왑,-착용-모션-동기화.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 장비 스왑, 착용 모션 동기화</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/참고자료/Procedural Dungeon 플러그인 분석" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/참고자료/Procedural Dungeon 플러그인 분석" href="0-발행완료/프로젝트/2504_f급헌터생존기/참고자료/procedural-dungeon-플러그인-분석.html" class="internal-link" target="_self" rel="noopener nofollow">Procedural Dungeon 플러그인 분석</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/동적 생성 미니맵" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/동적 생성 미니맵" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/동적-생성-미니맵.html" class="internal-link" target="_self" rel="noopener nofollow">동적 생성 미니맵</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 절차적 던전 생성" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 절차적 던전 생성" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-절차적-던전-생성.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 절차적 던전 생성</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Camera Shake Pattern" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Camera Shake Pattern" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/custom-camera-shake-pattern.html" class="internal-link" target="_self" rel="noopener nofollow">Custom Camera Shake Pattern</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Chaos Destruction을 사용한 오브젝트 부수기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Chaos Destruction을 사용한 오브젝트 부수기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/chaos-destruction을-사용한-오브젝트-부수기.html" class="internal-link" target="_self" rel="noopener nofollow">Chaos Destruction을 사용한 오브젝트 부수기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기)" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기)" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/플레이어-주변-액터-외곽선으로-강조하기-(custom-stencil로-외곽선-그리기).html" class="internal-link" target="_self" rel="noopener nofollow">플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기)</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Vignette Effect 매니저" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Vignette Effect 매니저" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/vignette-effect-매니저.html" class="internal-link" target="_self" rel="noopener nofollow">Vignette Effect 매니저</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Stencil Buffer 사용하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Stencil Buffer 사용하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/custom-stencil-buffer-사용하기.html" class="internal-link" target="_self" rel="noopener nofollow">Custom Stencil Buffer 사용하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 스턴 홀로그램 이펙트" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(작성중..) 스턴 홀로그램 이펙트" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(작성중..)-스턴-홀로그램-이펙트.html" class="internal-link" target="_self" rel="noopener nofollow">(작성중..) 스턴 홀로그램 이펙트</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Details Property Customization" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Details Property Customization" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/details-property-customization.html" class="internal-link" target="_self" rel="noopener nofollow">Details Property Customization</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Clothing Physics, 깃발" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Clothing Physics, 깃발" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/clothing-physics,-깃발.html" class="internal-link" target="_self" rel="noopener nofollow">Clothing Physics, 깃발</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Physics Swing Door, Chest" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Physics Swing Door, Chest" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/physics-swing-door,-chest.html" class="internal-link" target="_self" rel="noopener nofollow">Physics Swing Door, Chest</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/PhysicsConstraints 문, 상자" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/PhysicsConstraints 문, 상자" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/physicsconstraints-문,-상자.html" class="internal-link" target="_self" rel="noopener nofollow">PhysicsConstraints 문, 상자</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/프롭 스폰 포인트, 스폰될 액터 미리보기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/프롭 스폰 포인트, 스폰될 액터 미리보기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/프롭-스폰-포인트,-스폰될-액터-미리보기.html" class="internal-link" target="_self" rel="noopener nofollow">프롭 스폰 포인트, 스폰될 액터 미리보기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/입력 가능한 텍스트보드 액터" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/입력 가능한 텍스트보드 액터" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/입력-가능한-텍스트보드-액터.html" class="internal-link" target="_self" rel="noopener nofollow">입력 가능한 텍스트보드 액터</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/스켈레탈 메쉬에 화살 박기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/스켈레탈 메쉬에 화살 박기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/스켈레탈-메쉬에-화살-박기.html" class="internal-link" target="_self" rel="noopener nofollow">스켈레탈 메쉬에 화살 박기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메쉬 위에 비디오 재생하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메쉬 위에 비디오 재생하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메쉬-위에-비디오-재생하기.html" class="internal-link" target="_self" rel="noopener nofollow">메쉬 위에 비디오 재생하기</a><br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/바닥 메쉬에 Surface Type 추가하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/바닥 메쉬에 Surface Type 추가하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/기능-설명서/바닥-메쉬에-surface-type-추가하기.html" class="internal-link" target="_self" rel="noopener nofollow">바닥 메쉬에 Surface Type 추가하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기" href="0-발행완료/프로젝트/2504_f급헌터생존기/기능-설명서/treasurebookshelf-액터를-통해-랜덤-아이템-스폰하기.html" class="internal-link" target="_self" rel="noopener nofollow">TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기</a>]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-기록-인덱스.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 기록 인덱스.md</guid><pubDate>Thu, 11 Dec 2025 04:33:18 GMT</pubDate></item><item><title><![CDATA[Procedural Dungeon 플러그인 분석]]></title><description><![CDATA[Note
BenPython님의 Procedural Dungeon 플러그인을 분석한 글입니다.
Github: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/BenPyton/ProceduralDungeon" target="_self">https://github.com/BenPyton/ProceduralDungeon</a>
※ 버전 3.6.0부터 MIT 라이센스를 사용하지 않기 때문에 분석은 3.5.1 버전 기준임.
언리얼 에디터에 추가될 기능들이 정의되어 있다.에디터 모듈의 메인 엔트리를 정의하며, 언리얼 에디터 및 세팅 모듈에 변경사항을 적용한다.
에셋 카테고리에 타입 추가 (StartupModule)
// 에셋 툴즈 모듈
IAssetTools&amp; AssetToolsModule = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;("AssetTools").Get();
// 새 에셋 카테고리를 등록한다.
AssetTypeCategory = AssetToolsModule.RegisterAdvancedAssetCategory(...);
// 새 에셋 타입을 등록한다.
TSharedPtr&lt;FAssetTypeActions_RoomData&gt; RoomDataAction = ...;
AssetToolsModule.RegisterAssetTypeActions(RoomDataAction.ToSharedRef()); 디테일 패널 레이아웃 추가 (StartupModule)
// 프로퍼티 에디터 모듈
FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;("PropertyEditor");
// 커스텀 타입에 대한 커스텀 프로퍼티 타입 레이아웃을 추가한다.
PropertyModule.RegisterCustomPropertyTypeLayout(...);
// Mark dirty
PropertyModule.NotifyCustomizationModuleChanged(); 프로젝트 설정 추가 (RegisterSettings)
// 세팅 모듈
ISettingsModule* SettingsModule = FModuleManager::GetModulePtr&lt;ISettingsModule&gt;("Settings"));
// 새 설정 카테고리 추가
ISettingsSectionPtr SettingsSection = SettingsModule-&gt;RegisterSettings(...);
프로젝트 설정의 공용 RoomUnit이 아니라 테마별로 다른 RoomUnit을 사용하게 되면서 에디터 코드도 편집할 필요가 있게 되었다.
기존의 방식은 모든 로직에서 전역적으로 설정에 있는 RoomUnit을 가져와서 사용한다. (ProceduralDungeonUtils/Dungeon::RoomUnit())
에디터 편집 / 생성 시점에서 테마별 데이터에셋에 기록된 룸 유닛을 사용해야 하므로 어쩔 수 없이 전부 검색해서 로직을 수정해주는 방법밖에 없다. 눈물이 나온다.메인 모듈.
ADungeonGeneratorBase, ADungeonGenerator : 생성을 담당하는 메인 액터.
UDungeonGraph : 룸들로 구성된 그래프. 룸을 관리하고 Level streaming 명령을 내리는 주체라 제일 중요해보임.
URoom : 개별 룸 객체. Level Streaming을 수행하는 단위가 된다.
던전 생성기 베이스 클래스. 주요 동작은 다음과 같다.
생성자에서 시드(ADungeonGeneratorBase::Seed) 초기화 / UDungeonGraph 객체 (ADungeonGeneratorBase::Graph) 생성
EndPlay에서 Graph-&gt;UnloadAllRooms() -&gt; Each ARoom-&gt;Destroy() 호출
Tick에서 OnStateTick()을 호출하여 상태 전환 및 페이즈 전환
Generate()를 호출할 경우 EGeneratorFlags::Generating을 켜서 OnStateTick에서 Idle 페이즈 -&gt; Generation 페이즈로 전환 / OnPreGeneration() 호출 -&gt; Navigation System 빌딩 락 -&gt; Graph 클리어 -&gt; OnStateBegin()의 EGenerationState::Generation 케이스에서 CreateDungeon() 호출 -&gt; Initialization 페이즈로 전환.
OnStateTick의 EGenerationState::Initialization 케이스에서 Graph의 모든 룸에 대해 RoomData의 구성이 완료되었는지 확인 (Graph-&gt;AreRoomsReady() -&gt; Each ARoom-&gt;IsRoomReady()) -&gt; 완료되었을 때 Load 페이즈로 전환 / Graph-&gt;LoadAllRooms() 호출
CreateRoomInstance() 에서 새 URoom 객체 생성
AddRoomToDungeon() 에서 URoom을 부모 노드의 자식으로 연결 (Graph-&gt;TryConnectDoor(), Graph-&gt;AddRoom()) -&gt; OnRoomAdded() 호출
여기서 CreateDungeon()을 호출하는 부분과 Graph-&gt;LoadAllRooms()를 호출하는 부분이 핵심이다.
CreateDungeon_Implementation
던전 생성 메인 로직이 여기 들어있다. StartNewDungeon() -&gt; OnGenerationInit()
ChooseFirstRoomData() -&gt; 선택된 URoomData를 그래프 루트로 설정.
DFS/BFS 로직 돌면서 AddNewRooms() 호출 -&gt; false, 즉 더는 추가를 못 하면 탈출.
FinalizeDungeon() -&gt; 그래프에게 UDungeonGraph::InitRooms() 호출 명령 / InitializeDungeon()
기타 주요 함수 목록
AddNewRooms() ChooseNextRoomData() (유저가 오버라이드 해야 되는 함수) 호출 -&gt; 선택된 룸 기준으로 부모 룸과 호환 가능한 Connection이 있는지 체크 (FDoorDef::AreCompatible())
유효한 룸이면 CreateRoomInstance() 호출하여 임시 URoom객체 생성.
TryPlaceRoom() 호출하여 다른 룸들과 오버랩 체크
일정 트라이 안에(Dungeon::MaxRoomPlacementTryBeforeGivingUp()) 성공하면 AddRoomToDungeon() 호출 -&gt; OnRoomAdded / 실패하면 OnFailedToAddRoom() 호출 룸들로 구성된 그래프. 룸을 관리하고 Level streaming 명령을 내리는 주체다.
주요 동작은 다음과 같다.
LoadAllRooms() 에서 그래프를 이루는 모든 룸에 대해 URoom::Instantiate()를 호출한다.
InitRooms() : 던전 그래프 구성이 완료된 후 호출된다. 룸들 간의 Connection 정보를 기반으로 DungeonGraph 내의 RoomConnections 배열 구성 개별 룸 객체. Level Streaming을 수행하는 단위가 된다.
주요 동작은 다음과 같다.// 던전 그래프 구성 관련
Init() 로컬 위치, 방향 영 초기화 후 전달된 RoomData로 Connections 개수 초기화 // 레벨 스트리밍 관련
Instantiate() RoomData에서 UWorld 경로를 구한다.
그래프 상의 로컬 위치를 기준으로 레벨 스트리밍을 진행할 위치, 회전값 초기화
LoadInstance() 호출, ULevelStreamingDynamic* Instance 주소 저장. LoadInstance() ULevelStreamingDynamic::LoadLevelInstanceBySoftObjectPtr() 호출. IsInstanceLoaded() ULevelStreamingDynamic* Instance가 nullptr가 아니라면 Instance-&gt;GetLevelStreamingState()를 통해 비동기 레벨 스트리밍 상태를 얻을 수 있다.
ELevelStreamingState는 Removed, Unloaded, FailedToLoad, Loading, LoadedNotVisible, MakingVisible, LoadedVisible, MakingInvisible로 구분되며, Loading보다 높은 값이면 로딩이 끝났다고 취급할 수 있다. (쩐다) ]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/참고자료/procedural-dungeon-플러그인-분석.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/참고자료/Procedural Dungeon 플러그인 분석.md</guid><pubDate>Thu, 11 Dec 2025 04:26:47 GMT</pubDate></item><item><title><![CDATA[if vs switch]]></title><description><![CDATA[if는 최적화가 들어가긴 하지만 기본적으로 모든 조건을 판별하는 방식으로 동작한다.
반면 switch 문은 점프테이블(해시테이블)을 만들어 O(1)의 비용을 보장한다. 모든 case가 정수형(또는 정수형으로 캐스팅이 가능한 열거형)이어야 하는 이유도 컴파일 단계에서 점프 테이블을 만들어야 하기 때문이다.]]></description><link>0-발행완료/c,-c++/기타/if-vs-switch.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/if vs switch.md</guid><pubDate>Tue, 09 Dec 2025 13:54:11 GMT</pubDate></item><item><title><![CDATA[포인터]]></title><description><![CDATA[메모리 주소를 저장하는 변수. 64비트 환경에선 일반적으로 8바이트 크기를 사용한다.int* p; // int형 변수의 주소를 저장하는 int형 포인터
int *p, int * p, int* p 뭘로 해도 상관 없지만 '이 타입은 int형 포인터 타입이다'라는 의미 전달에 있어서나, 역참조 연산자와의 구별을 위해서나 int* 형태로 타입에 붙여 쓰는 편이 가독성이 좋다.
단 배열 포인터나 함수 포인터를 선언할 땐 이름과 * 연산자를 괄호로 묶어야 하므로, 이럴 땐 int (*p) 처럼 쓰거나 아예 int(*p) 또는 int(* p) 라고 붙여 쓴다.const 속성은 기본적으로 좌측에 있는 요소에 상수성을 부여하지만, 선언할 타입에 대해 부여할 땐 예외적으로 const가 좌측에 놓이는 걸 허용한다.const int*는 선언된 int 타입에 대한 상수성을 의미한다. 따라서 이 포인터의 값을 계속 바꿀 수는 있지만, 이 포인터를 역참조하여 값을 바꿀 수는 없다.만약 '포인터' 자체에 상수성을 부여하고 싶다면 int* const 라고 써야한다. 이러면 초기화할 때 저장된 주소에서 값을 바꿀 수 없다.함수의 주소를 담는 포인터. std::function 이나 delegate 등의 원형이다.
T(*name)(params) 형태로 선언한다.함수명을 통해 호출하는 것과 함수 포인터를 통해 호출하는 건 본질적으로 코드 영역에 특정 주소로 가 스택프레임을 스택에 올리는 동일한 동작이다. 예컨대int Func(int x) { ... }; int main()
{ // 이 동작과 Func(10); // 이 동작은 본질적으로 같다. int(*fp)(int) = Func; fp(10);
}
가리키는 자료형이 정해지지 않은 포인터. 타입 정보가 없으므로 역참조할 수 없다. C에는 박싱/언박싱의 개념이 없으므로 사용할 땐 형변환해야 한다.void* vp; int x = 10;
vp = &amp;x; cout &lt;&lt; *(int*)vp
]]></description><link>0-발행완료/c,-c++/문법/포인터.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/포인터.md</guid><pubDate>Tue, 09 Dec 2025 13:47:36 GMT</pubDate></item><item><title><![CDATA[포인터와 배열]]></title><description><![CDATA[Note
C++에선 훨씬 쉽고 편리하며 직관적인 가변 길이 배열 STL 컨테이너를 사용하도록 하자.
C/C++에서 배열은 특정한 크기의 할당된 메모리 블록을 의미한다. 이 때 배열명은 특별한 의미를 가진다.
배열명 arr은 &amp;arr[0], 즉 배열의 첫 번째 요소의 주소를 가리키는 포인터로 암시적으로 변환될 수 있다. 암시적으로 변환될 수 있을 뿐이지 배열명이 포인터라는 소리는 아니다.
단, sizeof(arr)은 예외적으로 배열의 전체 크기를 반환한다.
이외의 경우엔 '배열 전체의 시작주소'를 의미하려면 &amp;arr을 사용해야 한다. 실제로 arr + 1은 &amp;arr[0] + 1로 암시적으로 변환되므로 두 번째 요소의 시작 주소이며, &amp;arr + 1은 배열 전체의 크기 다음의 주소를 반환한다.
sizeof(&amp;arr)에서는 sizeof에 배열의 시작주소가 담겨 일반 포인터로 취급되어 포인터의 크기(8바이트)를 반환함에 주의하자.
이 차이 때문에 다소 헷갈리는 문법이 된다. 다음은 배열명에 대한 주소 연산이 가지는 의미이다.// int arr[4]; arr -&gt; 첫 번째 요소의 주소 (&amp;arr[0])
&amp;arr -&gt; 배열의 시작 주소 arr + 1 -&gt; 두 번째 요소의 주소 (&amp;arr[1])
&amp;arr + 1 -&gt; 배열의 크기(16바이트)만큼 이동한 주소
T(*name)[size] 꼴로 선언되는 포인터는 해당 크기의 배열만 가리킬 수 있는 배열 포인터이다.int arr[5]; // 일반 포인터로 arr의 첫번째 요소 하나를 가리킬 수 있다.
int* p1 = arr; // 배열 포인터로 arr 전체를 가리킬 수 있다.
int (*pArr)[5] = &amp;arr;
배열 포인터의 의의는 배열의 크기 정보를 유지하면서 가리킬 수 있다는 데에 있다. 배열을 일반 포인터로 가리키게 되면, 그냥 시작 요소의 주소만 저장될 뿐 크기 정보는 잃어버리게 된다.다음과 같은 경우에 사용한다.
다차원 배열을 포인터로 가리킬 때. 저차원 배열의 크기를 알아야 다음 요소가 어디서부터 시작하는 지 알 수 있으므로 접근이 가능하다.
함수의 인자로 배열을 전달할 때. 배열 포인터를 사용하면 크기 정보를 잃지 않고 전달할 수 있으며, 버퍼 오버런을 방지할 수 있다. 만약 배열 포인터를 사용하지 않으면, 별도로 요소의 개수를 인자로 전달해서 사용해야 한다.
첨자 연산 [n]은 사실 *(arr + n)과 동일하다.
즉, 시작 주소로부터 (요소의 크기 x n) 만큼 이동한 뒤 역참조하는 연산이다.3x4 크기의 int형 배열을 담으려면 int[4] 크기의 배열 포인터에 시작 요소(int[4] 배열)의 주소를 담거나, int[3][4] 크기의 배열 포인터에 배열 전체를 담으면 된다.int arr[3][4] = { { 0, 1, 2, 3 }, { 4, 5, 6, 7 }, { 8, 9, 10, 11 } };
int(*pArr1)[4] = arr;
int(*pArr2)[3][4] = &amp;arr;
전자의 경우엔 크기 4 배열이 '3개 있다는' 정보는 소실된다. 이는 1차원 배열을 일반 포인터로 가리키게 했을 때 배열의 크기 정보가 소실되는 것과 똑같은 상황이다.접근할 땐 똑같이 첨자 연산자를 이용하면 된다.pArr1[1][3]; // 2번째 요소의 4번째 요소, arr[1][3]
// = *(*(pArr1 + 1) + 3); // 동일한 크기의 배열 포인터를 통해 접근할 땐 첫 번쨰 요소만 존재한다.
pArr2[0][1][3]; // 첫 번째 요소의 2번째 요소의 4번째 요소, arr[1][3]
// = *(*(*(pArr2 + 0) + 1) + 3);
pArr1은 int[4] 크기를, pArr2는 int[3][4] 크기를 가리키는 포인터이므로, 주소연산을 했을 때 그 크기만큼 이동하는 것을 볼 수 있다.다차원 배열도 똑같다.int arr[2][3][4] = { { { 11, 22, 33, 44 }, { 55, 66, 77, 88 }, { 99, 110, 121, 132 } }, { { 111, 122, 133, 144 }, { 155, 166, 177, 188 }, { 199, 1110, 1121, 1132 } }
}; int(*pArr1)[3][4] = arr; // 첫 번째 요소 (int[3][4])를 가리키는 포인터
int(*pArr2)[2][3][4] = &amp;arr; // 배열 전체를 가리키는 포인터 cout &lt;&lt; pArr1[0][2][1] &lt;&lt; endl;
cout &lt;&lt; *( *( *(pArr1 + 0) + 2) + 1);
]]></description><link>0-발행완료/c,-c++/문법/포인터와-배열.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/포인터와 배열.md</guid><pubDate>Tue, 09 Dec 2025 13:41:16 GMT</pubDate></item><item><title><![CDATA[변수의 종류]]></title><description><![CDATA[함수 스코프 내에서 생성되고, 함수의 스택 프레임과 함께 제거되는 스택 메모리 영역의 변수.
키워드는 auto. 생략할 수 있다.void Func()
{ auto int x = 10;
}
함수 스코프 외부에서 생성되어, 프로그램의 실행과 함께 생성되고 종료될 때 해제되는 데이터 영역의 변수. 정적 변수와 달리 모든 목적 파일에서 유일하다. 다른 목적파일에서 선언된 전역 변수에 접근하려면 extern 키워드를 사용한다.
초기화되지 않고 선언되면 데이터 영역의 bss 영역에 생성되어 0 초기화된다.자신의 스코프 내에서 해제되지 않고 사용되는 데이터 영역의 변수. 함수 스코프 안에서 선언되면 해당 함수 내부에서 호출자가 누구냐와 상관없이 고유하게 사용되며, 함수 스코프 외부에서 선언되면 현재 목적 파일 안에서 고유하게 사용된다.
키워드는 static.
초기화되지 않고 선언되면 데이터 영역의 bss 영역에 생성되어 0 초기화된다.static int x; void Func()
{ static int y;
}
CPU 레지스터에 직접 생성되는 변수. 처리 속도가 매우 빠르지만 관리가 어렵고 주소 접근도 불가능하며 전역변수는 애초에 레지스터에 생성할 수 없고 생성을 시도한다고 매번 생성을 해주는 것도 아니다. 하드웨어 레벨이 아니라면 쓸 일은 없다.
키워드는 register.]]></description><link>0-발행완료/c,-c++/문법/변수의-종류.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/변수의 종류.md</guid><pubDate>Tue, 09 Dec 2025 13:29:40 GMT</pubDate></item><item><title><![CDATA[용어 정리]]></title><description><![CDATA[ 예약어와 식별자
int age;에서, int와 같이 미리 약속된 키워드가 예약어, age와 같이 임의로 붙인 이름을 식별자라고 한다. 연산자
new 나 &gt; 등과 같이 컴파일러가 특수하게 처리하는 예약어. 단항(단방향), 이항(양방향), 삼항 연산자로 나뉜다. Short circuit rule
일부 이항 연산자에서 '한 쪽을 검사하는 것만으로도 true/false라는 결론이 도출되어' 다른 쪽의 검사를 생략하는 최적화 기법.
예컨대 if ( true || false ) 에서 좌항이 true면 or 연산은 무조건 true이므로 우항은 검사하지 않는다. ]]></description><link>0-발행완료/c,-c++/기타/용어-정리.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/용어 정리.md</guid><pubDate>Tue, 09 Dec 2025 13:11:04 GMT</pubDate></item><item><title><![CDATA[문자열 Formatting]]></title><description><![CDATA[printf("%08.2f", 3.141592f); // 00003.14
#include &lt;iomanip&gt; cout &lt;&lt; setprecision(3) &lt;&lt; setw(8) &lt;&lt; setfill('0') &lt;&lt; 3.141592f; // 00003.14
cout &lt;&lt; std::format("{:&gt;10}", 123) &lt;&lt; "\n"; // " 123"
cout &lt;&lt; std::format("{:^10}", "hi") &lt;&lt; "\n"; // " hi "
cout &lt;&lt; std::format("{:08X}", 255) &lt;&lt; "\n"; // 000000FF
]]></description><link>0-발행완료/c,-c++/문법/문자열-formatting.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/문자열 Formatting.md</guid><pubDate>Tue, 09 Dec 2025 13:04:34 GMT</pubDate></item><item><title><![CDATA[Drawing 2025-12-02 23.13.50]]></title><description><![CDATA[동적 생성 미니맵에디터 디테일창편집하기메타휴먼에Dissolving 이펙트입히기상호작용과InteractableComponent]]></description><link>excalidraw/drawing-2025-12-02-23.13.50.excalidraw.html</link><guid isPermaLink="false">Excalidraw/Drawing 2025-12-02 23.13.50.excalidraw.md</guid><pubDate>Tue, 02 Dec 2025 14:36:28 GMT</pubDate></item><item><title><![CDATA[가상 함수 (Virtual function)]]></title><description><![CDATA[OOP의 핵심인 다형성, 그 중에서도 가장 중요하다고 할 수 있는 서브타입 다형성(런타임 다형성, 오버라이딩)을 구현하기 위한 개념.C++에선 부모 클래스의 함수 서명을 자식 클래스에서 그대로 사용할 경우, 부모 클래스의 함수는 숨겨지게 된다. 예컨대 Foo() 라는 함수가 부모와 자식 모두에 존재하면, 자식 객체를 통해 Foo()를 호출하면 자식의 Foo()가 호출되게 된다.물론 그렇다고 부모의 Foo() 함수가 사라진 것은 아니다. 부모의 타입을 명시하여 접근하는 것으로 호출은 가능하다. (물론, 호출되는 위치에서 접근이 가능하다면)문제는 부모 타입 포인터가 기본적으로 부모 타입의 함수에만 접근할 수 있다는 데에 있다. 다형성을 활용하려면 부모 타입 포인터가 업캐스팅된 자식 타입 객체를 가리키게 하고, 자식 타입에서 작성한 로직을 사용하도록 해야 한다.이 때 가상 함수를 사용한다.
virtual 키워드를 붙인 멤버 함수는 가상 함수가 되며, 자식이 같은 서명으로 멤버 함수를 선언할 경우 부모의 함수를 덮어쓰게(override) 된다. 이는 부모 포인터를 통해 자식 객체를 가리키고, 자식이 override한 함수를 부모 포인터를 통해 호출하면, 포인터가 가리키는 실객체인 자식의 함수가 호출됨을 의미한다.Note
'overriding'은 어디까지나 부모-자식 간 캐스팅을 통한 실객체의 함수 호출을 가능케 한다는 의미이다. 부모의 함수와 자식의 함수가 공존하는 상태인 건 똑같다. 실제로, 가상 함수라고 해도 부모 타입을 명시적으로 써서 부모 함수에 접근하는 건 여전히 가능하다.
이게 어떻게 가능한 걸까?비밀은 가상 함수 테이블에 있다. 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해, 클래스 단위로 하나의 가상 함수 테이블을 만든다. 이 테이블은 클래스의 구조에 따라 고정된 형태로 컴파일 타임에 만들어진다.
가상 함수 테이블에는 오버라이딩 구조에 따라 현재 클래스의 타입을 통해 가상 함수를 호출했을 때 최종적으로 오버라이딩된 위치가 어디인지, 즉 클래스의 상속관계 안에서 어떤 클래스의 함수를 호출해야 하는지 기록되어 있다.가상 함수 테이블을 가진 클래스가 인스턴싱될 때, 객체는 자동적으로 '가상 함수 포인터(Virtual Pointer)'를 가지게 된다. 이 포인터는 자신의 가상 함수 테이블이 있는 위치를 가리키며, 따라서 객체의 크기는 일반 포인터 하나(64비트 OS에서 8바이트)분만큼 늘어난다.
그리고 가상함수가 호출되면 현재 vptr가 가리키고 있는 가상함수 테이블의 함수를 호출하게 됨으로써 마지막으로 오버라딩된 함수를 호출하게 된다.가상 함수 테이블과 가상 함수 포인터의 생성 시점
가상 함수 테이블은 컴파일 타임에 컴파일러에 의해 생성되지만, 실제로 그 테이블을 쓰는 것은 런타임에 인스턴스가 가상 함수 포인터를 가지고 생성될 때부터다.
또 가상 함수 포인터가 자신의 가상 함수 테이블을 가리키게 되는 건 생성자가 호출되는 시점이므로, 부모의 생성자에선 부모의 가상함수만 호출할 수 있음에 주의해야 한다. 즉, 자식 객체를 생성할 때 부모의 생성자가 먼저 호출되고, 그와 동시에 객체의 vptr는 부모의 가상 함수 테이블을 가리키며, 이후 자식의 생성자가 호출되면서 vptr가 가리키는 가상 함수 테이블이 바뀌어 그 때부터 자식이 오버라이딩한 함수의 호출이 가능해진다.
오버라이딩을 강제하는 가상 함수. virtual void Foo() = 0; 와 같이 '= 0' 키워드를 통해 선언한다. MSVC를 사용한다면 '= 0' 키워드는 MSVC가 추가한 'abstract' 키워드로 대체할 수 있다. 물론 C++ 표준이 아니므로 코드 호환성을 위해 '= 0'을 쓸 것을 권장한다.Note
순수 가상 함수는 오버라이딩을 강제하는 것이지 정의를 가지지 못 하는 게 아니다. 여전히 함수이며 정의가 있는 경우 부모 타입을 명시하여 호출하는 것도 가능하다. 물론 정의부가 없이 호출하면 찾을 수 없는 심볼 링크 에러가 발생한다.
하나 이상의 순수 가상 함수가 포함된 클래스를 추상 클래스(Abstract class)라고 부른다. 자식을 통해 구체화되어야 하는 추상 함수를 포함하는 클래스라는 뜻으로, 기본적으로 존재 자체가 상속될 것을 전제한다. 따라서 추상 클래스의 인스턴스를 만들 수는 없다.오로지 순수 가상 함수 멤버로만 이루어진 클래스는 특별히 인터페이스(Interface)라고 부른다. 말 그대로 어떠한 구현, 로직, 데이터도 가지지 않고 오직 서로 다른 객체 간의 소통을 위한 매개 레이어로만 쓰이는 클래스라고 할 수 있다.
C++ 이후의 언어들은 아예 인터페이스 클래스를 분리하고 예약어를 통해 명시적으로 선언하게 하기도 한다. 그러나 C++에선 별도의 키워드는 없다. (MSVC가 COM 프로그래밍에 쓰려고 추가한 __interface 키워드가 있긴 하지만, C++ 표준이 아니다.)class Parent
{
public: virtual void Foo() = 0 { std::cout &lt;&lt; "순수 가상 함수 역시 함수이며 정의를 가질 수 있다.\n"; }
}; class Child : public Parent
{
public: // C++11에서 오버라이드 함수임을 명시할 수 있는 override 키워드가 추가되었다. // 오버라이드 함수에만 붙일 수 있다. 그냥 사람이 오버라이드 함수임을 명확히 알 수 있도록 하는 데 쓰인다. virtual void Foo() override { std::cout &lt;&lt; "자식 클래스\n"; }
}; int main()
{ Parent* ptr = new Child; ptr-&gt;Foo(); ptr-&gt;Parent::Foo();
}
]]></description><link>0-발행완료/c,-c++/문법/가상-함수-(virtual-function).html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/가상 함수 (Virtual function).md</guid><pubDate>Tue, 02 Dec 2025 13:36:01 GMT</pubDate></item></channel></rss>