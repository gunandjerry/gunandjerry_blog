<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[건제리의 블로그]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>건제리의 블로그</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 02 Dec 2025 14:36:38 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 02 Dec 2025 14:36:36 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Drawing 2025-12-02 23.13.50]]></title><description><![CDATA[동적 생성 미니맵에디터 디테일창편집하기메타휴먼에Dissolving 이펙트입히기상호작용과InteractableComponent]]></description><link>excalidraw/drawing-2025-12-02-23.13.50.excalidraw.html</link><guid isPermaLink="false">Excalidraw/Drawing 2025-12-02 23.13.50.excalidraw.md</guid><pubDate>Tue, 02 Dec 2025 14:36:28 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[게임 개발자 지망생 이건제입니다.지금까지 공부하며 기록해온 문서들을 보여드리기 위해 하나씩 다듬어가며 온라인으로 발행하고 있습니다.
양이 많아 우선 언리얼 프로젝트 위주로 정리했으며, 아직 정리하여 발행하지 못 한 문서들이 매우 많습니다.
빠른 시일 안에 지금까지 무슨 내용들을 공부해왔는지 모두 보여드릴 수 있도록 하겠습니다.포트폴리오 페이지 바로가기: <a data-tooltip-position="top" aria-label="https://gunandjerry.github.io/" rel="noopener nofollow" class="external-link is-unresolved" href="https://gunandjerry.github.io/" target="_self">gunandjerry의 포트폴리오</a>동적 생성 미니맵에디터 디테일창편집하기메타휴먼에Dissolving 이펙트입히기상호작용과InteractableComponent<br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/동적 생성 미니맵" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/동적 생성 미니맵" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/동적-생성-미니맵.html" class="internal-link" target="_self" rel="noopener nofollow">동적 생성 미니맵</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Details Property Customization" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Details Property Customization" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/details-property-customization.html" class="internal-link" target="_self" rel="noopener nofollow">에디터 디테일창 편집하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼에 Dissolving 이펙트 입히기" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼에 Dissolving 이펙트 입히기" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼에-dissolving-이펙트-입히기.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼에 Dissolving 이펙트 입히기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/상호작용, Interactable Component" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/상호작용, Interactable Component" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/상호작용,-interactable-component.html" class="internal-link" target="_self" rel="noopener nofollow">상호작용, Interactable Component</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼 페이셜 애니메이션" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼 페이셜 애니메이션" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼-페이셜-애니메이션.html" class="internal-link" target="_self" rel="noopener nofollow">메타휴먼 페이셜 애니메이션</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/커스텀 어빌리티 태스크" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/커스텀 어빌리티 태스크" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/커스텀-어빌리티-태스크.html" class="internal-link" target="_self" rel="noopener nofollow">커스텀 어빌리티 태스크</a>
등등...<br><a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼 옷 메쉬가 특정 LOD에서 움직이지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-메타휴먼-옷-메쉬가-특정-lod에서-움직이지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">바디와 옷 메쉬의 LOD 불일치 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1017) 터미널 메쉬에 위젯이 그려지지 않는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1017)-터미널-메쉬에-위젯이-그려지지-않는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">위젯의 렌더 타겟 생성 타이밍 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1018) 클라이언트에서 몽타쥬 재생 중에 이동이 멈추는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1018)-클라이언트에서-몽타쥬-재생-중에-이동이-멈추는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">루트모션에 의해 클라이언트의 움직임이 막히는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1111) 일반, 관전 HUD가 둘 다 뜨는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(1111) 일반, 관전 HUD가 둘 다 뜨는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(1111)-일반,-관전-hud가-둘-다-뜨는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">Travel 이후 스펙테이터 폰이 생성되는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0603)-dynamic-level-streaming으로-로드된-액터의-guid가-어긋나는-문제.html" class="internal-link" target="_self" rel="noopener nofollow">Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0704) 같은 스켈레톤을 사용하는 캐릭터와 애니메이션 간의 본 Translation 문제" href="0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0704)-같은-스켈레톤을-사용하는-캐릭터와-애니메이션-간의-본-translation-문제.html" class="internal-link" target="_self" rel="noopener nofollow">스켈레탈 메쉬가 스켈레탈의 기본 골격을 따라가는 문제</a>
등등...<br><a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/프로파일링/언리얼 인사이트(Insight)" data-href="0 발행완료/언리얼 엔진/프로파일링/언리얼 인사이트(Insight)" href="0-발행완료/언리얼-엔진/프로파일링/언리얼-인사이트(insight).html" class="internal-link" target="_self" rel="noopener nofollow">언리얼 인사이트, 프로파일링</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/현지화" data-href="0 발행완료/언리얼 엔진/엔진 지식/현지화" href="0-발행완료/언리얼-엔진/엔진-지식/현지화.html" class="internal-link" target="_self" rel="noopener nofollow">현지화, poedit 사용하기</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/네비게이션 시스템" data-href="0 발행완료/언리얼 엔진/엔진 지식/네비게이션 시스템" href="0-발행완료/언리얼-엔진/엔진-지식/네비게이션-시스템.html" class="internal-link" target="_self" rel="noopener nofollow">네비게이션 시스템</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/SteamWorks SDK" data-href="0 발행완료/언리얼 엔진/엔진 지식/SteamWorks SDK" href="0-발행완료/언리얼-엔진/엔진-지식/steamworks-sdk.html" class="internal-link" target="_self" rel="noopener nofollow">SteamWorks SDK, 스팀 업적</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/애니메이션 리타게팅" data-href="0 발행완료/언리얼 엔진/엔진 지식/애니메이션 리타게팅" href="0-발행완료/언리얼-엔진/엔진-지식/애니메이션-리타게팅.html" class="internal-link" target="_self" rel="noopener nofollow">애니메이션 리타게팅</a><br>
<a data-tooltip-position="top" aria-label="0 발행완료/언리얼 엔진/엔진 지식/그래픽 옵션 변경하기" data-href="0 발행완료/언리얼 엔진/엔진 지식/그래픽 옵션 변경하기" href="0-발행완료/언리얼-엔진/엔진-지식/그래픽-옵션-변경하기.html" class="internal-link" target="_self" rel="noopener nofollow">그래픽 옵션 변경하기</a>
등등...]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Tue, 02 Dec 2025 14:14:31 GMT</pubDate></item><item><title><![CDATA[가상 함수 (Virtual function)]]></title><description><![CDATA[OOP의 핵심인 다형성, 그 중에서도 가장 중요하다고 할 수 있는 서브타입 다형성(런타임 다형성, 오버라이딩)을 구현하기 위한 개념.C++에선 부모 클래스의 함수 서명을 자식 클래스에서 그대로 사용할 경우, 부모 클래스의 함수는 숨겨지게 된다. 예컨대 Foo() 라는 함수가 부모와 자식 모두에 존재하면, 자식 객체를 통해 Foo()를 호출하면 자식의 Foo()가 호출되게 된다.물론 그렇다고 부모의 Foo() 함수가 사라진 것은 아니다. 부모의 타입을 명시하여 접근하는 것으로 호출은 가능하다. (물론, 호출되는 위치에서 접근이 가능하다면)문제는 부모 타입 포인터가 기본적으로 부모 타입의 함수에만 접근할 수 있다는 데에 있다. 다형성을 활용하려면 부모 타입 포인터가 업캐스팅된 자식 타입 객체를 가리키게 하고, 자식 타입에서 작성한 로직을 사용하도록 해야 한다.이 때 가상 함수를 사용한다.
virtual 키워드를 붙인 멤버 함수는 가상 함수가 되며, 자식이 같은 서명으로 멤버 함수를 선언할 경우 부모의 함수를 덮어쓰게(override) 된다. 이는 부모 포인터를 통해 자식 객체를 가리키고, 자식이 override한 함수를 부모 포인터를 통해 호출하면, 포인터가 가리키는 실객체인 자식의 함수가 호출됨을 의미한다.Note
'overriding'은 어디까지나 부모-자식 간 캐스팅을 통한 실객체의 함수 호출을 가능케 한다는 의미이다. 부모의 함수와 자식의 함수가 공존하는 상태인 건 똑같다. 실제로, 가상 함수라고 해도 부모 타입을 명시적으로 써서 부모 함수에 접근하는 건 여전히 가능하다.
이게 어떻게 가능한 걸까?비밀은 가상 함수 테이블에 있다. 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해, 클래스 단위로 하나의 가상 함수 테이블을 만든다. 이 테이블은 클래스의 구조에 따라 고정된 형태로 컴파일 타임에 만들어진다.
가상 함수 테이블에는 오버라이딩 구조에 따라 현재 클래스의 타입을 통해 가상 함수를 호출했을 때 최종적으로 오버라이딩된 위치가 어디인지, 즉 클래스의 상속관계 안에서 어떤 클래스의 함수를 호출해야 하는지 기록되어 있다.가상 함수 테이블을 가진 클래스가 인스턴싱될 때, 객체는 자동적으로 '가상 함수 포인터(Virtual Pointer)'를 가지게 된다. 이 포인터는 자신의 가상 함수 테이블이 있는 위치를 가리키며, 따라서 객체의 크기는 일반 포인터 하나(64비트 OS에서 8바이트)분만큼 늘어난다.
그리고 가상함수가 호출되면 현재 vptr가 가리키고 있는 가상함수 테이블의 함수를 호출하게 됨으로써 마지막으로 오버라딩된 함수를 호출하게 된다.가상 함수 테이블과 가상 함수 포인터의 생성 시점
가상 함수 테이블은 컴파일 타임에 컴파일러에 의해 생성되지만, 실제로 그 테이블을 쓰는 것은 런타임에 인스턴스가 가상 함수 포인터를 가지고 생성될 때부터다.
또 가상 함수 포인터가 자신의 가상 함수 테이블을 가리키게 되는 건 생성자가 호출되는 시점이므로, 부모의 생성자에선 부모의 가상함수만 호출할 수 있음에 주의해야 한다. 즉, 자식 객체를 생성할 때 부모의 생성자가 먼저 호출되고, 그와 동시에 객체의 vptr는 부모의 가상 함수 테이블을 가리키며, 이후 자식의 생성자가 호출되면서 vptr가 가리키는 가상 함수 테이블이 바뀌어 그 때부터 자식이 오버라이딩한 함수의 호출이 가능해진다.
오버라이딩을 강제하는 가상 함수. virtual void Foo() = 0; 와 같이 '= 0' 키워드를 통해 선언한다. MSVC를 사용한다면 '= 0' 키워드는 MSVC가 추가한 'abstract' 키워드로 대체할 수 있다. 물론 C++ 표준이 아니므로 코드 호환성을 위해 '= 0'을 쓸 것을 권장한다.Note
순수 가상 함수는 오버라이딩을 강제하는 것이지 정의를 가지지 못 하는 게 아니다. 여전히 함수이며 정의가 있는 경우 부모 타입을 명시하여 호출하는 것도 가능하다. 물론 정의부가 없이 호출하면 찾을 수 없는 심볼 링크 에러가 발생한다.
하나 이상의 순수 가상 함수가 포함된 클래스를 추상 클래스(Abstract class)라고 부른다. 자식을 통해 구체화되어야 하는 추상 함수를 포함하는 클래스라는 뜻으로, 기본적으로 존재 자체가 상속될 것을 전제한다. 따라서 추상 클래스의 인스턴스를 만들 수는 없다.오로지 순수 가상 함수 멤버로만 이루어진 클래스는 특별히 인터페이스(Interface)라고 부른다. 말 그대로 어떠한 구현, 로직, 데이터도 가지지 않고 오직 서로 다른 객체 간의 소통을 위한 매개 레이어로만 쓰이는 클래스라고 할 수 있다.
C++ 이후의 언어들은 아예 인터페이스 클래스를 분리하고 예약어를 통해 명시적으로 선언하게 하기도 한다. 그러나 C++에선 별도의 키워드는 없다. (MSVC가 COM 프로그래밍에 쓰려고 추가한 __interface 키워드가 있긴 하지만, C++ 표준이 아니다.)class Parent
{
public: virtual void Foo() = 0 { std::cout &lt;&lt; "순수 가상 함수 역시 함수이며 정의를 가질 수 있다.\n"; }
}; class Child : public Parent
{
public: // C++11에서 오버라이드 함수임을 명시할 수 있는 override 키워드가 추가되었다. // 오버라이드 함수에만 붙일 수 있다. 그냥 사람이 오버라이드 함수임을 명확히 알 수 있도록 하는 데 쓰인다. virtual void Foo() override { std::cout &lt;&lt; "자식 클래스\n"; }
}; int main()
{ Parent* ptr = new Child; ptr-&gt;Foo(); ptr-&gt;Parent::Foo();
}
]]></description><link>0-발행완료/c,-c++/문법/가상-함수-(virtual-function).html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/가상 함수 (Virtual function).md</guid><pubDate>Tue, 02 Dec 2025 13:36:01 GMT</pubDate></item></channel></rss>