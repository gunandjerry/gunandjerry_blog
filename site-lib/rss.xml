<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[건제리의 블로그]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>건제리의 블로그</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 23 Sep 2025 13:23:49 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 23 Sep 2025 13:22:39 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[건제리의 블로그 (공사중)]]></title><description><![CDATA[게임 개발자 지망생 이건제입니다.현재 작성했던 문서들을 하나씩 다듬어가며 발행하고 있습니다.빠른 시간 안에 모든 문서를 발행할 수 있도록 노력해보겠습니다. :D포트폴리오 페이지 바로가기: <a data-tooltip-position="top" aria-label="https://gunandjerry.github.io/" rel="noopener nofollow" class="external-link is-unresolved" href="https://gunandjerry.github.io/" target="_self">gunandjerry의 포트폴리오</a>]]></description><link>건제리의-블로그-(공사중).html</link><guid isPermaLink="false">건제리의 블로그 (공사중).md</guid><pubDate>Tue, 23 Sep 2025 13:22:07 GMT</pubDate></item><item><title><![CDATA[function, mem_fn, bind]]></title><description><![CDATA[모두 &lt;functional&gt; 헤더에서 정의한다.함수 포인터의 래퍼 객체. 모든 종류의 Callable 타입을 가리킬 수 있다.
예를 들면 함수, 멤버 함수, 함수 포인터, 람다, 함수 객체 등.템플릿 인자로 반환형(매개변수) 형태의 서명을 전달한다.C++1int FloatToInt(float value)2{3	return static_cast&lt;int&gt;(value);4}56int main()7{8	std::function&lt;int(float)&gt; func = FloatToInt;9	int value = func(3.14f);10}C++멤버 함수의 경우, 구체적인 인스턴스를 통해서만 호출이 가능하므로 위와 같이 일반적인 형태로 함수 포인터가 가리키도록 할 수 없다.std::function이 멤버 함수를 가리키려면 람다로 인스턴스를 캡쳐해서 그 람다 함수를 가리키게 하거나C++1std::function&lt;void(int)&gt; fp = [&amp;foo]() { foo.print(); };C++암시적으로 존재하는 첫 번째 this 포인터 인자를 명시하여 외부에서 주입해서 사용해야 한다.C++1std::function&lt;void(Foo*, int)&gt; fp = &amp;Foo::print;2fp(&amp;foo);C++작동은 하지만 다소 낯설고 번거로운 문법이다.무엇보다 대개 STL 함수는 내부적으로 전달된 포인터를 '일반 함수처럼' 취급하고 사용한다. 그러나 멤버 함수는 반드시 인스턴스를 통해서만 호출될 수 있으므로, 에러가 발생하게 된다.예컨대 std::for_each의 내부 구조는 다음과 같다.C++1template&lt;class InputIt, class UnaryFunction&gt;2UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f)3{4 for (; first != last; ++first) {5 f(*first); // 일반 함수처럼 호출6 }7 return f;8}C++만약 f에 멤버 함수 포인터가 전달됐다면 f(*first) 의 형태로 호출이 불가능하므로 에러가 나게 된다.C++1std::vector&lt;Foo&gt; foos(3);2std::for_each(foos.begin(), foos.end(), &amp;Foo::print); // 에러C++그래서 std::mem_fn 이란 함수를 제공한다. 이 함수는 멤버 함수 포인터를 받아 (인스턴스, 함수인자) 순서로 인자를 전달해 호출할 수 있는, 다시 말해 '일반 함수처럼 호출할 수 있는' 함수 포인터 객체로 변환해서 반환한다.C++1struct Foo {2 void print(int x) const {3 std::cout &lt;&lt; "Foo::print(" &lt;&lt; x &lt;&lt; ")\n";4 }5};67int main()8{9	auto fp = std::mem_fn(&amp;Foo::print);10	Foo foo;11	fp(foo, 100);12}C++이걸 사용하면 앞서 든 STL 함수에서 사용이 불가능했던 문제 예시를 해결할 수 있게 된다. 첫 번째 인자로 인스턴스인 *first가 전달되어 호출할 수 있기 때문이다.C++1std::vector&lt;Foo&gt; foos(3);2std::for_each(foos.begin(), foos.end(), std::mem_fn(&amp;Foo::print));C++함수의 특정한 인자를 미리 고정한 상태의 함수 포인터 래퍼를 반환한다.
예컨대 float Sum(float x, float y)이란 함수가 있을 때, x에 미리 3.14f를 넣은 상태로 호출하는 함수 호출자를 생성해 인자 하나를 고정해놓고, y만 넣어서 호출할 수 있게 하는 식이다.C++1float Sum(float x, float y)2{3	return x + y;4}56int main()7{8	auto fp = std::bind(Sum, 3.14f, std::placeholders::_1);9	std::cout &lt;&lt; fp(5.5f);10}C++특히 멤버 함수를 담을 때 편리하다. 인스턴스를 미리 바인드해두고 사용할 수 있기 때문.C++1Foo foo;2std::function&lt;void()&gt; fp = std::bind(&amp;Foo::DoSomething, &amp;foo);3fp(); // foo.DoSomethingC++std::bind의 인자로 이게 오면 해당 위치의 매개변수를 직접 전달할 수 있도록 한다. 뒤에 붙은 번호는 이러한 매개변수 대체자들끼리의 순서를 의미하는데, 예시를 보자.C++1void Fn(int x, int y, int z) { ... }23std::function&lt;void(int a, int b)&gt; SomeFunc = std::bind(Fn, 10, std::placeholders::_2, std::placeholders::_1);C++위와 같이 bind가 되었다면, Fn의 첫 번째 매개변수인 x는 10으로 고정, y, z는 SomeFunc에 값을 넣어 직접 전달할 수 있는데, placeholders의 순서가 2, 1 순으로 배치 되었으므로,
SomeFunc(20, 30); 으로 호출했다면 실제로는 Fn(10, 30, 20); 으로 전달되어 호출되는 것과 같게 된다.std::placeholders::_n 의 n은 같은 매개변수 대체자std::placeholders들 간의 순서를 의미함을 주의하자. 절대로 n번째 매개변수란 뜻이 아니다.Note
‘placeholder’는 빠져있는 것을 대신하는 기호나 텍스트를 의미한다.
std::bind를 사용할 때 주의할 점은 매개변수로 객체나 변수를 전달하면 일단 기본적으로 복사해서 전달한다는 것이다.C++1Foo foo;2auto SomeFunc = std::bind(MyFunc, foo); // foo의 복사본을 생성해 고정시킨다.3// SomeFunc에서 전달된 Foo 객체의 데이터멤버를 바꿔도 foo의 데이터멤버는 그대로임.C++만약 참조로 전달하고 싶다면 std::ref()로 객체나 변수를 감싸야 한다. const 객체라면 std::cref()로 감싼다.C++1Foo foo;2auto SomeFunc = std::bind(MyFunc, std::ref(foo));3// SomeFunc에 전달된 Foo 객체와 foo는 동일함.C++보다 자세한 내용은 <a class="internal-link" data-href="0 발행완료/C, C++/문법/reference_wrapper, ref, cref.md" href="0-발행완료/c,-c++/문법/reference_wrapper,-ref,-cref.html" target="_self" rel="noopener nofollow">reference_wrapper, ref, cref</a> 페이지를 참고]]></description><link>0-발행완료/c,-c++/문법/function,-mem_fn,-bind.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/function, mem_fn, bind.md</guid><pubDate>Tue, 23 Sep 2025 13:09:28 GMT</pubDate></item><item><title><![CDATA[플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기)]]></title><description><![CDATA[CustomPrimitiveData
관련 문서: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://dev.epicgames.com/documentation/ko-kr/unreal-engine/storing-custom-data-in-unreal-engine-materials-per-primitive" target="_self">https://dev.epicgames.com/documentation/ko-kr/unreal-engine/storing-custom-data-in-unreal-engine-materials-per-primitive</a>
여기선 다루지 않고 이 방법을 적용할 수도 없지만, 다른 방식이 있나 찾아보던 중 아주 강력한 기능을 찾게 되었다. 언리얼의 렌더링 기초인 Primitive마다 커스텀 데이터를 전달할 수 있는 기능이다.
UPrimitiveComponent::SetCustomPrimitiveData@@@(Index, Value) 함수로 동적으로도 쉽게 커스텀 데이터를 전달할 수 있으며, 전달할 수 있는 데이터의 양도 매우 크다.
그냥 머터리얼 안에 Parameter 노드를 두고 Use Custom Primitive Data에 체크한 뒤 지정한 인덱스로 가져오기만 하면 된다.
웬만한 경우에 있어서 다이나믹 머터리얼 인스턴스를 쉽게 대체할 수 있는 강력한 기능인 것 같다. 다만 어디까지나 Primitive 단위로 동작하므로, 이 문서에서 다루는 내용처럼 PostProcess를 통한 일관된 처리를 하는 경우엔 사용하지 못 한다.
<br>언리얼에서 Custom Stencil Buffer를 사용하는 방법에 대해선 <a class="internal-link" data-href="0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Stencil Buffer 사용하기.md" href="0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/custom-stencil-buffer-사용하기.html" target="_self" rel="noopener nofollow">Custom Stencil Buffer 사용하기</a> 문서를 참고하자.플레이어의 일정 반경 내에서 상호작용 가능한 오브젝트들은 잠깐동안 아웃라인이 그려지게 해달라는 요구를 받았다.
포스트 프로세스 머터리얼을 사용해 스텐실 값이 기록된 메쉬에 아웃라인을 그리는 방식을 사용한다.아웃라인은 부드럽게 생겼다가 부드럽게 사라지는 게 보기 좋은데, 포스트 프로세스를 사용하기 때문에 경과 시간을 구할 수는 없다. 따라서 좋은 방법 같지는 않지만, 스텐실 버퍼의 100~200 영역을 Opacity 값으로 사용해볼까 한다. 스텐실 ID가 200이면 Opacity 1.0, 120이면 0.2가 되는 식이다.아웃라인이 그려질 영역은 일반적인 방법으로 추출할 것이다. 원본 Primitive가 차지하는 영역은 커스텀 스텐실로 기록할 것이므로 SceneTexture:CustomStencil의 한 픽셀로부터 8방향으로 일정 거리만큼 떨어진 위치에 스텐실 값이 기록되어 있으면 아웃라인 영역으로 취급하면 된다.8방향(가로, 세로, 사선)으로 체크하는 이유는 스텐실이 기록된 모양이 어떻게 될 지 알 수 없기 때문이다. 예컨대 그 모양이 X, Y축에 정렬된 정직한 사각형 모양이라면 훨씬 적은 방향으로만 검사해도 되겠지만, 복잡한 모양은 어쩔 수 없이 8방향으로 해야 이쁘게 나온다.가로 세로 4방향만 검사하면 이렇게 되고<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205447.png" src="♣vaultstorage/attachment/pasted-image-20250812205447.png" target="_self" style="width: 200px; max-width: 100%;">사선으로 4방향만 검사하면 이렇게 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205452.png" src="♣vaultstorage/attachment/pasted-image-20250812205452.png" target="_self" style="width: 200px; max-width: 100%;"><br><img alt="♣VaultStorage/attachment/Pasted image 20250812205501.png" src="♣vaultstorage/attachment/pasted-image-20250812205501.png" target="_self">
아웃라인의 굵기(= 검사를 위해 이동할 거리)와 이동할 방향을 받는다.
굵기와 방향은 SceneTexelSize(현재 해상도의 한 픽셀이 0-1 사이 UV 좌표로 얼만큼인지를 반환)와 곱하여 정규화한다.
현재 픽셀의 UV 좌표(ScreenPosition)와 현재 좌표에서 굵기만큼 방향으로 이동한 UV 좌표의 커스텀 스텐실 값을 구하고, 그 차이를 반환한다.
이를 모든 픽셀에 대해 수행하게되면 8방향으로 굵기 만큼 떨어진 위치에 있는 픽셀이 스텐실 값이 기록된 픽셀일 때, 자신은 아웃라인 영역이 된다는 걸 알 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205505.png" src="♣vaultstorage/attachment/pasted-image-20250812205505.png" target="_self" style="width: 150px; max-width: 100%;">Note
여기서 약간의 조정을 가하면 아웃라인을 원본 영역의 '완전히 바깥'에 그릴 지, 혹은 '완전히 안에' 그릴 지, 그것도 아니면 안과 바깥 절반씩 걸쳐서 그릴 지 결정할 수 있다. 미니맵 문서를 참고하자. <br><img alt="♣VaultStorage/attachment/Pasted image 20250812205512.png" src="♣vaultstorage/attachment/pasted-image-20250812205512.png" target="_self">
앞서 만든 아웃라인 영역 판별 함수를 8방향으로 8번 호출하고, 그 최대값을 구한다.
우린 Stencil ID 100~200 사이의 값을 실제 아웃라인의 Opacity로 사용하기로 했으므로, 식으로 opacity 값을 구한다. 이 값은 반드시 Stencil ID가 100 이상인 영역의 아웃라인 영역에 대해서만 0.0 이상의 값이 나오는 게 보장된다. (200 이상은 1.0 이상이 나오므로, 사용하지 않기로 약속하자...)
Opacity가 0을 초과할 경우, 식으로 보간한 블렌딩 색상을 출력한다.
OutlineThickness와 OutlineColor는 쉬운 수정을 위해 MaterialParameterCollection 에셋으로 정의했다.포스트 프로세스 준비는 끝났으니 이제 코드를 통해 스텐실 값을 동적으로 바꿔주면 된다.
스텐실 값을 동적으로 바꾸는 것 자체는 FHInteractableComponent가 담당하도록 한다. 이 경우 액터가 사라질 때 컴포넌트도 함께 제거되므로 별도의 중간 탈출 예외처리가 필요하지 않다.그리고 우리가 원하는 건 아웃라인이 부드럽게 생겼다가 n초 뒤에 다시 부드럽게 사라지는 것이므로, 반경 n미터 안에 '처음 진입'했는지, 아니면 이미 캐싱되어 있는지 체크해야 한다. 이건 FHPlayerBase가 직접 담당한다.로직은 매우 단순하다.
n초마다 반경 n미터 안에 FHInteractableComponent를 가진 모든 액터를 목록화한다.
캐싱된 목록 안에 이미 포함되어 있는 액터는 제외하고, 처음 진입한 액터들에 대해 FHInteractableComponent::Highlight(시간) 함수를 호출한다.
더이상 반경 n미터 안에 포함되지 않지만 캐싱된 목록에는 존재하는 액터들은 캐싱된 목록에서 제거한다.
FHInteractableComponent 내부에서 n초간 스텐실 값을 0 -&gt; 1 -&gt; 0 순으로 흐르게 한다.
]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/플레이어-주변-액터-외곽선으로-강조하기-(custom-stencil로-외곽선-그리기).html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/플레이어 주변 액터 외곽선으로 강조하기 (Custom Stencil로 외곽선 그리기).md</guid><pubDate>Tue, 23 Sep 2025 13:09:28 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[의존성 주입 패턴 (Dependency Injection Pattern)]]></title><description><![CDATA[고수준 모듈이 저수준 모듈을 사용할 때 이를 직접 생성하거나 제3자를 통해 찾아오는 대신,
고수준 모듈을 생성 또는 초기화하는 외부로부터 저수준 모듈을 '주입받아' 사용하는 패턴. 핵심은 의존성을 외부에서 동적으로 만들어내고 관리하는 것이다.기본적으로 <a class="internal-link" data-href="0 발행완료/프로그래밍 일반/설계 방법론/의존성 역전 (Dependency Inversion Principle).md" href="0-발행완료/프로그래밍-일반/설계-방법론/의존성-역전-(dependency-inversion-principle).html" target="_self" rel="noopener nofollow">의존성 역전 원칙</a>이 지켜진다는 전제로 구현되며, (1) 확장과 변경에 용이하게 하고, (2) 의존성을 명시적으로 드러내기 위해 사용한다.저수준 모듈을 외부에서 생성 또는 가져와 주입하기 때문에 보통은 해당 모듈의 수명까지 외부에서 관리하게 된다. 생성자 주입으로 주입된 객체를 주입의 대상만 사용하게끔 만들고 대상이 소멸할 때 주입된 객체도 같이 소멸하게 하는 방법도 있겠지만, 직관성이 크게 떨어지고 동적으로 의존성을 관리하는 의미가 퇴색되므로 좋은 방법이라고 할 수 없다.실제 사용법은 매우 간단하다. 생성자 또는 초기화 함수에서 인자로 주입할 객체를 전달하거나, 혹은 특정 함수를 호출할 때 사용할 객체를 인자로 전달하는 게 전부다.
의존성이 명확하게 드러난다: 의존성은 적으면 적을 수록 좋지만, 줄이는 데에는 한계가 있다. 의존은 반드시 발생한다. 그렇다면 의존성이 명확하게 드러나 유지보수에 들일 시간과 노력이 적어지는 쪽이 좋다.
의존성 주입 패턴은 이 객체를 생성하는데, 혹은 특정한 함수를 호출하는데 필요한 것이 무엇인지 호출을 하는 쪽에서 바로바로 알 수 있게 만들기 때문에 내부의 구현 로직을 전혀 몰라도 어떤 객체에 의존하는 지 명확하게 알 수 있다.
의존성이 줄어든다: 객체를 주입당하는 쪽은 그냥 주입해준 객체를 쓰고나서 신경을 끄면 된다.
테스트하기 쉽다: 테스트를 하고 싶다면 그냥 테스트용 Mock 냄비 객체를 주입해보면 된다.
단점이 없는 것은 아니다. 가장 큰 문제는 주입되는 개체의 수명 관리 문제다.
위에서도 말했지만 주입된 객체의 수명을 주입을 당한 객체가 직접 관리하는 것은 의존성 주입 패턴의 의미를 크게 퇴색시키는 좋지 못 한 방법이다.
그렇다면 외부에서 수명을 관리해주어야 하는데, 문제는 자칫 잘못했다간 주입된 객체의 수명이 그것을 사용하는 객체보다 먼저 끝나서 댕글링 포인터가 발생할 수도 있다는 것.이 문제의 가장 쉬운 해결법은 스마트 포인터를 쓰는 것이지만, 일반 포인터보다 비용이 큰 건 어쩔 수 없다.]]></description><link>0-발행완료/프로그래밍-일반/설계-방법론/의존성-주입-패턴-(dependency-injection-pattern).html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계 방법론/의존성 주입 패턴 (Dependency Injection Pattern).md</guid><pubDate>Tue, 23 Sep 2025 13:09:28 GMT</pubDate></item><item><title><![CDATA[구글 Build로 만든 TypeScript Page를 깃허브 페이지로 게시하기까지]]></title><description><![CDATA[깃허브 페이지 게시용 레포지토리 생성법은 <a class="internal-link" data-href="0 발행완료/툴과 API/Git, Github/Github.io 블로그 개설하기.md" href="0-발행완료/툴과-api/git,-github/github.io-블로그-개설하기.html" target="_self" rel="noopener nofollow">Github.io 블로그 개설하기</a> 문서를 참고.일단 npm도 써야하고 TypeScript 컴파일도 해야되니 Node.js를 설치하자.그리고 만약 VSCode로 편집하거나 하려면 NPM으로 TypeScript 스니펫을 깔아줘야 빨간줄이 안 뜬다.
npm install -g typescript 를 쳐서 전역설치해주자.이후 구글이 만들어준 프로젝트를 그대로 가져와서 깃허브 클론 경로에 두고, cmd창을 열어 해당 프로젝트 경로에서 다음 명령어를 친다.리액트를 사용한다면
npm install --save-dev @types/react
npm install --save-dev @types/react-dom우선 "scripts"에 다음과 같이 predeploy, deploy 항목을 추가한다.JSON1"scripts": {2 "dev": "vite",3 "build": "vite build",4 "preview": "vite preview",5 6 "predeploy": "npm run build",7 "deploy": "gh-pages -d dist"8 },JSON참고로 deploy에서 뒤에 dist 말고 build를 쓰면 build 폴더 생성이 안 되고 못 찾겠다고 오류가 뜨던데 왜 그런 건진 몰?루. 어쨌든 구글에 검색해보니 dist 쓰라고 해서 써봤더니 됨.그리고 밑에 homepage 항목을 추가하고 내 깃허브 페이지 경로를 적자.JSON1},2 "homepage": "https://gunandjerry.github.io/"3}4JSON알아서 Node.js로 TypeScript 코드를 JavaScript로 컴파일한 후, 자동으로 깃허브 페이지에 게시해주는 패키지다.npm install gh-pages로 설치하자.다음은 gh-pages로 컴파일, 페이지 게시까지 알아서 해주는 배치 파일 명령어다. 최상위 경로에 놓고 쓰자.1@echo off2cd /d "%~dp0"3npm run deploy4pausedeploy가 완료되면 내 깃허브 레포지토리에 gh-pages 브랜치가 새로 생겨있는 것을 볼 수 있다. 이제 깃허브로 가 Settings - Pages - Build and deployment 설정에서 브랜치를 gh-pages로 바꿔주면 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250527003400.png" src="♣vaultstorage/attachment/pasted-image-20250527003400.png" target="_self">gh-pages는 public 폴더 안에 있는 리소스를 그대로 배포할 때 복사해서 가져간다.
최상위 경로에 public 폴더를 만들고 그 안에 이미지든 뭐든 넣고 상대경로로 쓰면 된다.다음 배치 파일을 최상위 경로에 두고 실행하자.1@echo off2cd /d "%~dp0"3npm run dev4pause그럼 localhost 어쩌구 주소가 뜨는데, 그리로 들어가면 로컬에서 동작중인 가상환경을 통해 페이지를 미리 볼 수 있으며, 변경 사항도 즉시 반영된다.]]></description><link>0-발행완료/툴과-api/git,-github/구글-build로-만든-typescript-page를-깃허브-페이지로-게시하기까지.html</link><guid isPermaLink="false">0 발행완료/툴과 API/Git, Github/구글 Build로 만든 TypeScript Page를 깃허브 페이지로 게시하기까지.md</guid><pubDate>Tue, 23 Sep 2025 13:09:28 GMT</pubDate></item><item><title><![CDATA[원자성 연산, atomic]]></title><description><![CDATA[원자성 연산이란 작은 데이터에 대한 연산을 수행함에 있어 CPU가 특수한 조치를 취해 여러 틱에 걸쳐 연산을 수행하지 않고 한 번만에 수행하는 것을 말한다. 하나의 코어가 한 번의 동작만으로 연산이 완료되므로 멀티 코어, 멀티 스레드 환경에서 연산의 중간에 다른 스레드가 개입하는 문제가 생기지 않는다. Lock을 사용해 강제로 막는 방식이 아니라 CPU의 자체 설계로 제공되는 기능을 이용하는 것이므로 Lock보다 훨씬 빠르게 Thread-Safe를 구현할 수 있다.원자성 연산은 별도의 조치 없이 경쟁 상태나 메모리 가시성 문제가 발생하지 않는다.메모리 가시성 문제
메모리 값의 갱신은 한 틱만에 발생하지 않으며 일반적으로 중간다리를 거쳐 이루어진다. 예컨대 스레드A가 메모리 0x01 주소의 값에 11을 기록하려고 '일련의 입력 프로세스'에 진입했는데, 그 밑에서 생성된 스레드B는 아직 입력 프로세스가 끝나지 않아 새 값이 기록되기 전의 메모리를 읽어들일 수 있다.
비슷한 문제로 코드 재배치 문제도 있다. 컴파일러는 딱히 멀티스레드 환경을 고려해 로우 레벨 코드를 생성하지 않기 때문에 그게 더 효율적이라는 이유로 '멀티스레드 환경에선 문제가 되는 방향으로' 코드의 순서를 뒤바꿔버릴 수도 있다. 심지어는 컴파일러가 아니더라도 CPU가 명령을 실행할 때 순서를 바꿀 수도 있다. CPU가 하나의 명령을 처리하는 것조차 한 틱만에 일어나는게 아니다.
C++이 제공하는 원자성 연산 래핑 객체. 이걸 쓰지 않는다면 각 운영체제, ABI마다 제공하는 명령어를 사용해야 한다. (예컨대, 윈도우즈의 InterlockedIncrement 함수같은 것)Note
x86(32비트) 환경이라면 인라인 어셈블리로 CPU 제조사의 원자성 어셈블리 명령어를 사용할 수도 있다.
이걸 사용하면 템플릿 타입을 넣는 것만으로도 아주 쉽게 원자성 연산이 가능한 타입을 선언할 수 있다. 단, 일반적인 환경에선 8바이트 이하의 데이터만 원자성 연산이 이루어지고, 8바이트를 초과하면 내부적으로 Spin Lock을 사용해 Thread-Safe를 구현하게 되어있다.C++1std::atomic&lt;int&gt; a1; // 가능2std::atomic&lt;double&gt; a2; // 가능34struct s1{ int x, y; };5std::atomic&lt;s1&gt; a3; // 가능C++원자성 연산이 이루어지는지 확인해보려면 다음의 방법을 사용하면 된다.C++1std::cout &lt;&lt; a3.is_lock_free(); // is_lock_free() 메서드는 이 타입에 대한 원자성 연산 가능 여부를 반환한다.23// 혹은, 선언된 타입의 크기를 확인해봐도 된다. 원자성 연산이 불가능한 경우엔 락을 잡기 위한 8바이트가 추가된다.C++]]></description><link>0-발행완료/c,-c++/시스템/원자성-연산,-atomic.html</link><guid isPermaLink="false">0 발행완료/C, C++/시스템/원자성 연산, atomic.md</guid><pubDate>Tue, 23 Sep 2025 13:06:27 GMT</pubDate></item><item><title><![CDATA[스레드 2. thread 라이브러리]]></title><description><![CDATA[C++11에서 추가된 새로운 스레드 표준. OS마다 알아서 다른 함수를 호출해 스레드를 생성한다.
기존의 WinAPI 스레드 함수를 사용하는 것보다 훨씬 편리하다.다음과 같이 사용한다.C++1std::thread t1(진입함수); // 스레드 객체가 생성되는 동시에 새 스레드를 생성한다.23// std::thread t; // 혹은 빈 스레드 객체만 만들어놓고4// t = std::thread(진입함수); // 나중에 생성해도 된다.56// 스레드가 콜백(흐름이 종료되고 호출자에게 반환)될 때까지 대기한다.7t.join();89// 스레드를 백그라운드에서 돌아가게 만들고 반환여부를 신경쓰지 않는다.10t.detach();C++스레드 객체는 생성과 동시에 동작에 필요한 자원(진입점 정보, 스레드의 스택프레임, 스레드 고유 자원 등등)을 할당받게 되므로 join 또는 detach 중 하나는 반드시 써줘야 안전하게 종료와 함께 자원을 해제할 수 있다.경쟁 조건(race condition)에 놓인 메모리의 배타적 사용을 위한 커널 뮤텍스 객체의 래퍼.C++1std::mutex m; // 커널 뮤텍스 오브젝트 생성.23m.lock(); // 현재 스레드에 의한 락45// 경쟁 자원에 접근6// 여길 임계 영역(critical section 이라고 함)78m.unlock(); // 락 해제C++한 스레드에서 같은 뮤텍스 객체의 lock()을 호출할 경우 뮤텍스 객체를 해당 스레드가 점유하게 되면서, 다른 스레드는 먼저 점유한 스레드가 unlock()을 할 때까지 대기하게 된다.흔히 헷갈리는 것은 둘 이상의 스레드가 함께 lock()과 unlock() 사이에 있는 임계영역에 들어갈 수도 있지 않냐는 것인데, 스레드가 동시에 작동하고 있다고 하더라도 m.lock()에 의해 커널 객체의 점유권이 이양되는 동작은 한 번에 하나만 일어나기 때문에, 가장 먼저 접근한 스레드만 이를 받을 수 있으므로 그런 일은 생기지 않는다.std::mutex는 교착상태를 수습하기 위한 함수로 try_lock()을 제공한다. 아무도 해당 뮤텍스를 점유하고 있지 않다면 락을 걸고 true를 반환하고, 누군가 이미 락을 걸고 있으면 false를 반환한다.C++1void Func1(mutex&amp; m1, mutex&amp; m2)2{3	m1.lock();4	m2.lock();5	6	// Do Something7	8	m2.unlock();9	m1.unlock();10}1112void Func2(mutex&amp; m1, mutex&amp; m2)13{14	m2.lock();15	if (!m1.try_lock())16	{17 m2.unlock();18 return;19	}20	21	// Do Something22	23	m1.unlock();24	m2.unlock();25}C++이러면 무조건 Func1을 돌리는 스레드가 우선권을 얻게 되기 때문에 교착상태는 일어나지 않는다. 그러나 이런식으로 스레드간의 우선순위를 정하는 방식으로 교착상태를 막게 되면, 경우에 따라 어떤 스레드는 다른 스레드에게 순서를 빼앗겨 거의 혹은 절대로 경쟁자원에 접근할 수 없는 상태가 될 수 있는데, 이를 기아 상태(Starvation) 문제라고 한다.교착상태를 예방하는 법 중첩된 Lock의 사용을 최대한 피한다. 대부분의 경우 설계가 문제지 사실은 Lock 하나만으로 충분히 구현할 수 있다. 애초에 Lock이 하나면 모든 스레드가 동일한 Lock에 대해 획득을 시도하므로 절대로 교착상태가 일어나지 않는다.
중첩된 Lock을 사용할 수밖에 없다면, 반드시 정해진 순서대로 획득하고, 그 역순으로 해제한다. 만약 A가 B에게 돈을 송금하고, B가 A에게 돈을 송금하는 상황이 동시에 발생하면 어떻게 될까?C++1void transfer(std::mutex&amp; from, std::mutex&amp; to, int val)2{3	from.lock();4	to.lock();56	// 대충 전송을 처리하는 코드78	to.unlock();9	from.unlock();10}1112int main()13{14	std::mutex A;15	std::mutex B;16	17	std::thread t1(transfer, std::ref(A), std::ref(B), 100);18	std::thread t2(transfer, std::ref(B), std::ref(A), 50);1920	t1.join();21	t2.join();22}C++스레드 t1이 from(A)를 잠구고 to(B)를 잠구려고 시도할 때, 이미 스레드 t2가 from(B)를 잠구고 to(A)를 잠구려고 시도하고 있었다면, 데드락이 발생한다.
따라서 이런 상황에선 두 뮤텍스를 동시에 잠궈야 한다. 이 때 사용하는 함수가 std::lock이다.C++1void transfer(std::mutex from, std::mutex to, int val)2{3	std::lock(from, to);45	// 대충 전송을 처리하는 코드67	to.unlock();8	from.unlock();9}C++이러면 두 상호배제 객체가 동시에 락이 걸리기 때문에 한 스레드가 일부만 락을 거는 상황은 발생하지 않는다.std::mutex는 unlock()을 잊으면 대참사가 나기 때문에, 스마트 포인터처럼 스택을 벗어날 때 알아서 unlock()을 호출하는 방법이 몇 가지 있다.상호배제 객체를 담아서 생성하는 순간 해당 객체를 통해 락을 걸고, 스택프레임이 풀릴 때 언락을 하는 객체. 임의로 언락을 하는 방법은 없다.여러 개의 상호배제 객체를 담아서 생성할 수 있는 락 가드. 언락을 할 땐 락을 건 역순으로 풀어서 데드락이 발생하지 않게 한다. 마찬가지로 임의로 언락을 하는 방법은 없다.아마 가장 많이 사용할 락 가드. 기본적으로 std::lock_guard와 같지만 언제든지 임의로 락을 풀고 다른 상호배제 객체를 넣고 임의로 락을 걸 수 있다. 즉, 스택프레임이 사라질 때 현재 가지고 있는 객체를 언락시킨다는 걸 빼면 그냥 std::mutex랑 다름 없다.
참고로 두 번째 매개변수로 std::defer_lock을 전달하면 unique_lock을 생성하는 시점에서 락을 걸지 않고 나중에 .lock() 메서드나 std::lock()을 통해 락을 걸게 할 수 있다. 근데 이럴 거면 그냥 std::mutex를 직접 쓰는 게 낫지 않을까?이벤트 커널 객체로 스레드를 깨우는 것과 유사한 방식으로 락을 대기시키는 객체. 내부적으론 SleepConditionalVariableSRW로 구현되어 있다고 한다. 그런데 SRWLock은 일정 주기로 체크하는 방식으로 알고있는데, 이건 notify()로 깨우는 방식이라 다르지 않나?예컨대 다음과 같은 생성자-소비자 패턴 코드가 있다고 하자.C++1void Produce(std::queue&lt;Foo&gt;&amp; jobs, std::mutex&amp; mtx)2{3	// 대충 일할 거리 구해다가 jobs 큐에 집어넣는 코드4}56void Consume(std::queue&lt;Foo&gt;&amp; jobs, std::mutex&amp; mtx)7{8	while(true)9	{10 mtx.lock();11 if (jobs.empty()) // 할 일이 없으면12 {13 mtx.unlock(); // 락을 풀고14 std::this_thread::sleep_for(std::chrono::miliseconds(10)); // 10ms동안 대기15 continue;16 }17 18 // 대충 jobs에서 일감을 꺼내서 처리하는 코드19 20 mtx.unlock();21	}22}C++여러 개의 워커 스레드가 각각 Consume()을 돌린다고 해보자. 현재는 jobs에 일감이 없으면 스레드는 10ms동안 대기하고 다시 뮤텍스의 락을 시도하게 된다. 이렇게 매번 락을 걸었다가, 풀었다가, 다시 시도하는 방식은 CPU 자원을 매우 비효율적으로 낭비하는 행위다.이것보단 스레드를 대기시켜놓고, jobs에 일감이 들어오면 순서대로 깨우는 것이 좋을 것이다.std::condition_variable 객체를 사용하면 이를 아주 쉽게 구현할 수 있다. 바뀐 코드를 보자.C++1void Produce(std::queue&lt;Foo&gt;&amp; jobs, std::mutex&amp; mtx, std::conditional_variable&amp; cv)2{3	// 대충 일할 거리 구해다가 jobs 큐에 집어넣는 코드4	5	cv.notify_one(); // 잠자고 있는 스레드 중 가장 먼저 재워진 스레드를 깨운다.6	// cv.notify_all(); // 이건 해당 cv에 의해 재워진 모든 스레드를 깨우는 함수.7}89void Consume(std::queue&lt;Foo&gt;&amp; jobs, std::mutex&amp; mtx, std::conditional_variable&amp; cv)10{11	while(true)12	{13 // std::lock_guard와 비슷하게 생성과 동시에 락을 걸고 소멸될 때 unlock을 하는 lock wrapping 객체. 다만 std::lock_guard는 생성밖에 못 하는데 얘는 생성 후에도 unlock, lock이 자유롭다.14 // 여기선 cv.wait이 unique_lock을 매개변수로 받기 때문에 사용했다.15 std::unique_lock&lt;std::mutex&gt; lk(m);16 17 // 두 번째 매개변수에 전달되는 조건이 false라면 락을 풀고 스레드의 경동맥을 졸라서 잠재운다.18 // 이후 notify()류 함수에 의해 스레드가 깨어나면 다시 조건 함수를 체크하고, 이 때 true로 바뀌었다면 락을 걸고 진행한다. 여전히 false를 반환한다면 다시 잠든다.19 cv.wait(lk, [&amp;jobs]{ return !jobs.empty() });20 21 // 대충 jobs에서 일감을 꺼내서 처리하는 코드22 23 lk.unlock();24	}25}C++위 코드는 매우 단순한 형태임을 명심하자. 여러 개의 생산자, 소비자 스레드가 동시에 생성되었을 때, 소비자 스레드의 입장에선 jobs가 비었으면 cv.wait에 의해 대기 상태가 되고, 생산자 입장에선 jobs에 일감을 하나 넣었다면 최소한 하나의 일감이 있음이 보장되므로 잠자고 있는 스레드 하나를 깨워서 일을 시킨다.std::conditional_variable에는 다음과 같은 함수들이 있다.C++1// 기본 대기, 조건이 참이면 그대로 넘어가고, 거짓이면 락을 푼 뒤 notify_one 또는 notify_all에 의해 깨어날 때까지 대기한다. 깨어나면 락을 걸고 진행된다. (물론, notify_all에 의해 여러 스레드가 같은 위치에서 깨어나면 선행 스레드가 락을 풀 때까지 대기한다.)2cv.wait(락, 조건);34// 시간 제한이 있는 대기. 기본적으로 wait과 동일하게 작동하나, 대기할 경우 notify에 의해 깨어나지 않더라도 지정된 시간이 지나면 자동으로 깨어난다.5// 스레드 스케줄링 오버헤드 등에 의해 실제 대기 시간이 정확하지가 않다. 이건 Sleep과 같이 스레드를 재우고 깨우는 함수 모두에 해당되는 얘기다.6cv.wait_for(락, 시간(chrono), 조건);78// 특점 시점까지만 대기. 기본적으로 wait_for와 동일하게 작동하나, wait_for가 '일정 시간 동안'만 대기하는 거라면 이건 '특정 시간 까지'만 대기하는 것이다.9cv.wait_until(락, 시간(chorono), 조건);1011// cv.wait류 함수에 의해 대기하고 있는 스레드 중 가장 먼저 잠재운 스레드 하나를 깨운다.12cv.notify_one();1314// cv.wait류 함수에 의해 대기하고 있는 모든 스레드를 깨운다.15cv.notify_all();C++주의할 점은 cv.wait의 두 번째 매개변수인 predicate 함수는 처음 wait() 함수를 만났을 때, 그리고 스레드가 notify()에 의해 깨어났을 때마다 한 번씩 호출되어 조건 함수로 쓰인다는 점이다.
그래서 만약 predicate 함수 내부에서 종료 조건을 따로 체크하지 않으면 스레드가 영원히 잠들게 되는 수가 있다. 보통 스레드를 종료시키기 전에 종료 플래그를 켜고, notify_all()을 호출해 모든 스레드가 깨어나도록 한 뒤 return할 때까지 기다리는 방식을 많이 사용하는데, predicate 함수 내부에서 종료 조건을 설정했을 때 탈출하지 못 하도록 로직이 짜여져 있으면 다시 잠들 뿐이라는 것.쉬운 비동기 처리를 위한 객체. 동작 과정은 다음과 같다.
std::promise 객체가 미래에 어떤 값을 주겠다고 약속(promise) 한다.
std::future 객체는 미래에 어떤 값을 받겠다는 의미로 그 약속을 받는다.
std::future 객체는 wait() 함수로 약속이 이루어질 때까지 대기한다.
std::promise 객체에 값이 담기면, 이 값이 future에게 전달되며 future의 대기가 끝난다.
C++1void DoSomething(std::promise&lt;int&gt;&amp; pm)2{3	Sleep(1000); // 1초간 대기하고4	pm.set_value(100); // promise 객체에 값을 담을 것5}67int main()8{9	std::promise&lt;int&gt; pm;10	11	// 미래에 값을 주겠다고 약속함12	std::future&lt;int&gt; ft = pm.get_future();13	14	// 워커 스레드에서 1초 후 pm에 값을 대입15	std::thread t(DoSomething, pm);16	17	// 약속이 이행될 때까지 대기18	ft.wait();1920	// pm이 값을 전달해주면 ft의 대기가 끝남2122	// get()으로 전달을 약속받았던 값을 얻을 수 있다.23	// 참고로, wait() 없이 그냥 get()만 호출해도 값이 담길 때까지 대기한다.24	std::cout &lt;&lt; f.get();25}C++std::future.get()은 값을 이동으로 반환하므로 두 번 호출할 수 없다.
conditional_variable을 쓰거나 thread만 써도 이런 동작을 구현할 수는 있지만, promise - future를 사용하는 게 훨씬 간단하고 직관적이다. 더욱이 promise.set_value() 말고도 promise.set_exception() 으로 예외를 전달하는 등 써먹을 방법이 많다.C++1p.set_exception(std::current_exception());23f.wait();45try {6	f.get(); // get을 할 때 실제로 예외가 던져진다.7} catch (const std::exception&amp; e) {8	...9}C++std::conditional_variable과 마찬가지로 wait_for 문을 지원한다. 기본 동작은 wait()과 같고, 대기할 경우 지정된 시간 동안만 기다렸다가 std::future_status::timeout을 반환하고 넘어간다.C++1std::future_status status = f.wait_for(std::chrono::seconds(5));23if (status == std::future_status::timeout)4{5	...6}7else if (status == std::future_status::ready)8{9	...10}C++std::future::get()은 기본적으로 값을 이동시키므로 한 번만 호출할 수 있다고 했는데, 이건 이동이 아니라 스마트 포인터처럼 내부 주소값을 전달해 참조하게 하므로 get()을 여러 번 호출할 수 있다.
여러 스레드에서 동일한 future 객체의 값을 참조하는 경우에 사용한다.C++1std::promise&lt;int&gt; p;2std::shared_future&lt;int&gt; sf = p.get_future(); // 사용법은 동일34std::thread t1(DoSomething, sf);5std::thread t2(DoSomething, sf);C++std::function처럼 Callable을 담는 객체. 그런데 promise-future 패턴을 내부에서 구현한다.
std::packaged_task 그 자체는 Callable을 담으면서 동시에 std::promise처럼 쓰여 get_future()를 호출해 약속을 하고, Callable이 리턴하는 값을 set_value()로 넣는 것처럼 future에 전달한다.
쉽게 말해 들고있는 콜백 함수의 반환값으로 set_value()를 하는 promise라고 생각하면 된다.C++1int DoSomething(int x) { return x * x; }23int main()4{5	std::packaged_task&lt;int(int)&gt; task(DoSomething);6	std::future&lt;int&gt; f = task.get_future();7	8	std::thread t(std::move(task), 5); // 복사생성이 불가능9	std::cout &lt;&lt; "결과값: " &lt;&lt; f.get() &lt;&lt; std::endl;10	11	t.join();12}C++8번 라인에 std::thread를 생성하면서 std::packaged_task 객체를 이동시키고 있는데, 그 이유는 다음과 같다.
기본적으로 std::packaged_task는 내부에 Callable과 연결된 std::promise 객체를 가지고 있다. 따라서 자기가 가리키는 함수 포인터만 전달할 수 없고 통채로 전달해야 한다.
그런데 std::packaged_task가 복사로 전달되면 std::promise 도 복사되는 등 참사가 일어나므로 복사생성이 불가능하다.
따라서 std::move로 감싸 이동을 시켜야만 한다.
극한까지 추상화되어 std::promise 객체와 함수를 바인딩하고 스레드를 생성해 해당 함수를 호출하고 std::future 객체에게 반환을 약속하는 것까지 전부 해주는 함수.
함수 포인터를 넣어도 되고 람다를 넣어도 된다.함수 포인터 전달C++1int DoSomething(int param);23// std::async 호출과 동시에 새 스레드가 생성된다.4// 리턴값을 전달받을 것을 약속받은 std::future 객체를 반환한다.5std::future&lt;int&gt; f = std::async(std::launch::async, DoSomething, 10);67f.wait();C++첫 번째 인자는 어떤 형태로 실행할 지를 결정하는데 사용된다.
(1) std::launch::async : 즉시 스레드를 생성, 인자로 전달된 함수를 실행하도록 한다.
(2) std::launch::deferred : future의 get() 함수가 호출될 때 동기적으로 실행된다. (왜 있지 이거?)람다식 전달C++1std::future&lt;int&gt; f = std::async([](){ return DoSomething(10); });C++]]></description><link>0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html</link><guid isPermaLink="false">0 발행완료/C, C++/시스템/스레드 2. thread 라이브러리.md</guid><pubDate>Tue, 23 Sep 2025 13:06:25 GMT</pubDate></item><item><title><![CDATA[스레드 1. WinAPI, CRT 스레드 함수]]></title><description><![CDATA[C 시절의 WinAPI 함수인 CreateThread() 함수는 CRT와 연동이 되지 않아 다음과 같은 문제가 있었다.
스레드를 생성할 때 CRT가 필요한 초기화를 수행하지 않아 로컬 저장소에 접근할 때 문제가 발생할 수 있다.
스레드가 종료될 때 CRT가 스레드 생성에 필요한 메모리 찌꺼기를 자동으로 해제하지 못 한다.
따라서 CreateThread() 함수를 래핑한 CRT의 _beginthreadex() 함수가 만들어졌다.
두 함수 모두 윈도우즈에서 스레드를 생성하는 함수임에 주의하자.Note
물론 C++11에서 추가되어 표준이 된 &lt;thread&gt; 라이브러리는 OS에 따라 다른 함수를 호출한다.
_beginthreadex()에 진입점 함수의 주소와 함께 전달할 void* 매개변수를 넣어 호출한다. 그럼 시스템 콜이 호출되고 새 스레드 진입점이 생성된다.
스레드 진입점이 될 함수는 다음과 같은 호출 규약을 지켜야 한다.C++1#include &lt;process.h&gt;23// Windows API에서 대부분의 스레드 관련 함수가 __stdcall을 사용하기 때문에, 스레드 진입점 함수도 __stdcall을 사용해야 한다.4// 스레드 종료 코드를 정확히 해석하기 위해 unsigned (unsigned int) 타입으로 반환한다.5unsigned __stdcall Func(void* args);6// 리턴되는 정수는 스레드의 종료 코드다. 정상 종료는 return 0으로 표현78// ...9HANDLE threadHandle = (HANDLE)_beginthreadex(nullptr, 0, Func, SomeParameters, 0, nullptr);C++WaitForSingleObject 또는 WaitForMultipleObject 함수는 전달된 이벤트 핸들이 signaled 상태가 될 때까지 현재 스레드를 대기시킨다. 두 번째 매개변수로 기다릴 최대 시간을 지정할 수 있다.C++1WaitForSingleObject(threadHandle, INFINITE);C++_endthreadex() 역시 ExitThread()의 래퍼 함수이다. 일반적으로 스레드를 강제로 종료시키는 것은 좋은 상황이라고 할 수 없다. 스레드 내부에서 어떤 동작들이 수행되었는 지 알 수 없는 상황에서 메모리 누수, 교착상태, 일관성의 파괴, Undefined behavior 등을 발생시킬 위험이 있기 때문이다.주의해야 할 점은 ExitThread()와 달리 해당 스레드의 핸들을 알아서 닫지 않는다는 것. 따라서 CloseHandle()로 스레드 커널 객체의 ref count를 0으로 만들어주지 않으면 아무 동작도 하지 않는 스레드 커널 객체가 영원히 커널 영역에 남아 메모리 누수를 일으키게 된다.
물론 스레드 관련 리소스(스레드를 생성할 때 필요한 메모리)는 CRT에 의해 자동으로 해제가 된다.전자는 스레드를 강제로 종료시키는 함수고, 후자는 핸들의 값을 NULL로 만들고 해당 커널 객체의 Reference Count를 하나 줄이는 함수다.어떤 커널 객체는 CloseHandle()로 레퍼런스 카운터를 줄였을 때, 그대로 0이 되어 해제될 수도 있다. 하지만 스레드의 경우엔 스레드가 돌고 있을 땐 시스템이 스레드 커널 객체를 참조하고 있기 때문에, CloseHandle로 핸들을 닫더라도 레퍼런스 카운터가 0이 되지 않고 스레드는 계속 돌게 된다. (이후 스레드가 종료되어 시스템에 의한 참조 카운트가 줄어들면 해제된다.)스레드는 생성 비용이 매우 크기 때문에 반복적으로 사용되는 상황에선 일반적으로 스레드풀을 만들어 스레드를 대기시켜놓고, 이벤트를 발생시키는 시스템 콜로 깨워서 돌게 만든다. 이벤트를 발생시키는 것도 시스템 콜을 요구하긴 하지만, 스레드를 그 때 그 때 재생성하는 것보다는 훨씬 빠르다.
다음의 예시는 매우 간단한 형태의 스레드 풀이다.C++1struct MyThread2{3	HANDLE handle{ nullptr }; // 스레드 커널 객체 핸들4	HANDLE event_ready{ nullptr }; // 스레드가 준비되었음을 알릴 이벤트 핸들5	HANDLE event_done{ nullptr }; // 스레드가 동작을 완료했음을 알릴 이벤트 핸들6	unsigned int id{ 0 }; // 스레드 uid7	8	unsigned (__stdcall *Func)(void*) { nullptr }; // 스레드 진입점 함수9	void* data{ nullptr }; // 진입점 함수에 전달할 매개변수1011	Thread()12	{13 event_done = CreateEvent(nullptr, false, false, nullptr);14 event_ready = CreateEvent(nullptr, false, false, nullptr);1516 // 스레드를 생성하고 대기상태로 만든다.17 handle = (HANDLE)_beginthreadex(nullptr, 0, ThreadMain, this, 0, &amp;id);18	}19	~Thread()20	{21 SetEvent(event_ready); // 대기 상태를 해제한다.22 WaitForSingleObject(handle, INFINITE);23 CloseHandle(handle);24 CloseHandle(event_done);25 CloseHandle(event_ready);26	}2728	static unsigned __stdcall ThreadMain(void* param)29	{30 MyThread* thread = static_cast&lt;MyThread*&gt;(param);31 while (true)32 {33 // 일이 맡겨질 때까지 무한 대기34 WaitForSingleObject(thread-&gt;event_ready, INFINITE);35 if (thread-&gt;Func == nullptr) // 종료조건36 break;3738 thread-&gt;Func(thread-&gt;data); // 함수를 실행한다.39 SetEvent(thread-&gt;event_done); // 동작이 완료되었음을 알리고 다시 잠든다.40 }41 return 0;42	}43}C++해당 구조체는 생성과 동시에 두 개의 이벤트 객체를 생성하고, 소멸될 때 스레드가 무사히 종료되도록 돌고있는지 확인한 뒤 종료되었음이 확인되면 CloseHandle로 닫는다.C++1// 스레드에 전달할 데이터 예시2struct ThreadData3{4	int SomeArg{ 0 };5}67// 스레드풀 클래스8class ThreadPool9{10public:11	std::vector&lt;MyThread*&gt; threads;12	13	ThreadPool(int threadNum)14	{15 threads.resize(threadNum);16 for (int i = 0; i &lt; threadNum; ++i)17 {18 threads[i] = new Mythread;19 }20	}21	~ThreadPool()22	{23 for (auto t : threads)24 {25 delete t;26 }27	}2829	void BeginThread(unsigned (__stdcall *Func)(void*), void* data)30	{31 for (auto t : threads)32 {33 // 대기중인 스레드라면 깨워서 일을 시킨다34 if (WaitForSingleObject(t-&gt;event_done, 0) == WAIT_OBJECT_0)35 {36 t-&gt;Func = Func;37 t-&gt;data = data;38 ResetEvent(t-&gt;event_done);39 SetEvent(t-&gt;event_ready);40 return;41 }42 }43	}44}C++]]></description><link>0-발행완료/c,-c++/시스템/스레드-1.-winapi,-crt-스레드-함수.html</link><guid isPermaLink="false">0 발행완료/C, C++/시스템/스레드 1. WinAPI, CRT 스레드 함수.md</guid><pubDate>Tue, 23 Sep 2025 13:06:23 GMT</pubDate></item><item><title><![CDATA[모듈 Module]]></title><description><![CDATA[불편한 C/C++의 컴파일 방식을 개선하기 위해 도입된 시스템. C++20부터 추가되었다.
C++ Language Standard 설정 C++20 이상으로 설정
Enable Experimental C++ Standard Library Module Yes로 설정
Tools -&gt; Get Tools and Features -&gt; 개별 구성 요소 -&gt; v143 빌드 도구용 C++ 모듈 설치되어있나 확인. VS에서 모듈 파일의 확장자는 ixx(Module Interface Unit) (근데 다른 확장자 써도 됨)
모듈의 접근자는 :: 대신 .을 쓴다. (ex: std.core)
std.core → 아래에 있는 것들을 제외한 대부분의 표준 라이브러리
std.regex → &lt;regex&gt;
std.filesystem → &lt;filesystem&gt;
std.memory → &lt;memory&gt;
std.threading → &lt;atomic&gt;, &lt;condition_variable&gt;, &lt;future&gt;, &lt;mutex&gt;, &lt;shared_mutex&gt;, &lt;thread&gt;]]></description><link>0-발행완료/c,-c++/시스템/모듈-module.html</link><guid isPermaLink="false">0 발행완료/C, C++/시스템/모듈 Module.md</guid><pubDate>Tue, 23 Sep 2025 13:06:21 GMT</pubDate></item><item><title><![CDATA[variant]]></title><description><![CDATA[타입에 안전한 공용체. C++17에서 도입. &lt;variant&gt; 헤더
C의 union은 단순히 바이트 덩어리를 여러 타입으로 읽을 수 있다는 의미였다. 이는 단순히 바이트를 메모리 공간에 담아놓고, 사용할 때 해당 타입으로 해석하는 방식이다.
여기서 더 나아가 std::variant는 타입에 대한 안정성이 추가되었다. 내부적으로 placement new를 사용해 타입에 제한되지 않는 메모리를 할당해두고, 정해둔 타입만 담고 정해둔 타입으로만 해석할 수 있게 알아서 검사를 수행한다.Note
std::any는 타입에 안전한 void*의 대안으로, std::variant는 타입에 안전한 union의 대안으로 도입되었음.
C++1std::variant&lt;int, float, std::string&gt; foo;23// 이 동작이 수행되면 foo의 타입은 int가 된다. 후술하겠지만 현재 어떤 타입의 데이터가 담겨있는지는 .index() 함수로 반환된 인덱스에 해당하는 템플릿 인자를 보면 된다.4foo = 1;56// 이번엔 std::string이 된다. 기존에 담겨있던 int 타입 데이터는 variant에게 할당된 메모리에서 지워지고, 이 때 필요하다면 안전한 해제를 위한 조치가 수행된다.7foo = "banana";89// 안에 든 값을 꺼낼 때는 std::get&lt;T&gt;로 타입을 명시해야함10std::cout &lt;&lt; std::get&lt;std::string&gt;(foo);11// 혹은 타입 인덱스로 명시12std::cout &lt;&lt; std::get&lt;2&gt;(foo); // 2번 인덱스 타입인 std::string으로 꺼내기를 시도1314// variant가 아예 담을 수 없는 타입을 요구하면 컴파일러가 오류를 잡아낸다.15std::get&lt;double&gt;(foo);16// variant가 담을 수 있는 타입이지만, 지금 담고 있지 않은 타입을 요구하면 런타임에 std::bad_variant_access 예외가 던져진다.17std::get&lt;int&gt;(foo);C++&lt;variant&gt;는 다음 STL 함수를 포함한다.C++1// get_if는 포인터를 받으며, 형식 불일치시 예외를 던지는 대신 nullptr를 반환한다.2std::get_if&lt;std::string&gt;(&amp;foo); // &amp;foo3std::get_if&lt;float&gt;(&amp;foo); // nullptr45// holds_alternative는 variant가 담고 있는 값의 타입을 체크한다.6std::holds_alternative&lt;std::string&gt;(foo); // true7std::holds_alternative&lt;float&gt;(foo); // false89// index 메서드는 variant가 담고 있는 값의 타입의 인덱스를 반환한다.10foo.index(); // 3번째 타입인 std::string을 담고 있으므로 2C++]]></description><link>0-발행완료/c,-c++/문법/variant.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/variant.md</guid><pubDate>Tue, 23 Sep 2025 13:06:19 GMT</pubDate></item><item><title><![CDATA[static]]></title><description><![CDATA[static 키워드는 사용되는 위치에 따라 여러 방식으로 사용된다. 기본적으로 변수나 함수의 스코프 주기(수명)를 정적 스코프 주기로 변환해 프로세스의 수명동안 존속하도록 하는 게 골자다.
특히 '스코프'와 관련된다는 점에 주목해야 한다. 전역 변수나 전역 함수는 프로세스 전체에서 전역적으로 접근 가능한 변수나 함수를 말하지만, static 변수나 함수는 정적 영역에 생성되어 수명이 유지될 뿐 어디까지나 해당 scope 내부에 종속되어 있는 개념이다.
따라서 local scope 내부의 static 변수는 해당 local scope 내부에서만 접근 가능하며, 클래스에 선언된 static 함수는 클래스의 네임스페이스를 명시하여 찾아가야지만 호출할 수 있는 것.외부에서 접근 가능한 전역 변수
외부에서 접근 가능한, 즉 여러 목적 파일에서 공유할 수 있는 변수를 만들려면 static을 사용하는 게 아니라 한 곳에서 전역 변수를 선언한 뒤 다른 곳에서 extern 키워드로 그 변수가 다른 어딘가에서 선언되었음을 알리고, 링크 단계에서 연결시켜야 한다.
해당 변수를 static scope로 선언한다. 이는 해당 local scope 내부로 접근은 제한되지만 변수가 할당되는 공간 자체는 정적 공간이므로 local scope를 벗어나도 해제되지 않는다.
함수 내부에서 선언된 static 변수는 함수가 호출될 때마다 새 함수 스택 프레임을 생성하는 것과 별개로 초기화 시점에 정적 공간에 생성되므로, 여러 번의 함수 호출 동안 상태를 공유할 수 있어 유용하다.함수 내부의 변수에 쓰일 때와 마찬가지로 해당 정적 변수나 정적 함수의 접근을 클래스 내부로 제한하라는 의미가 된다.
보다 정확히는 일반적으로 메모리에 객체화되어 사용되는 클래스의 의미와 다르게 객체와 무관하게 정적 스코프 주기에 해당 변수와 함수를 선언하라는 의미가 된다. 따라서 접근 지정자에 의해 접근이 차단된 게 아니라면 클래스의 이름을 명시하여 정적 공간에서 해당 변수와 함수를 찾아가 접근할 수 있다. 클래스의 여러 인스턴스가 존재해도 static 변수나 함수는 정적 공간에 하나만 존재하므로 공유할 수 있어 유용하다.어떻게 보면 이게 가장 특이한 쓰임이다. 전역적으로 사용 가능한 함수나 변수를 선언하는 것은 사실 static 키워드를 붙이지 않고 그냥 어떤 지역 스코프에도 속하지 않는 위치에서 선언하는 것으로 끝이다. 함수는 선언부가 있는 헤더를 포함해서 쓰면 되고 변수는 전역 변수의 이름이 충돌하면 링크 에러가 발생하므로 한 곳에선 전역 변수를 선언하고 다른 곳에선 extern 키워드를 사용하는 방식이 된다.
그럼에도 static을 사용한다는 의미는, 그 변수와 함수를 파일 스코프 안에서만 접근 가능하도록 제한한다는 의미이다. 즉, 목적 파일마다 그 목적 파일에서만 사용하는 정적 스코프 주기의 함수와 변수를 선언하게 되는 것이다.
이러면 static 함수의 서명을 여러 곳에서 포함해 사용할 경우 각각의 목적 파일마다 해당 함수의 코드가 생성되게 되며, 해당 함수 안에서 static 변수를 선언했다면 그 static 변수도 서로 다른 것이 된다. static 변수의 경우에도 해당 목적 파일 안에서만 사용되는 정적 스코프 주기 변수이므로 여러 목적 파일에 이름이 같은 static 변수가 여러 개 존재해도 상관 없다.]]></description><link>0-발행완료/c,-c++/문법/static.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/static.md</guid><pubDate>Tue, 23 Sep 2025 13:06:17 GMT</pubDate></item><item><title><![CDATA[reference_wrapper, ref, cref]]></title><description><![CDATA[객체의 참조 wrapper. 말 그대로 객체를 ‘참조하는’ 객체로, 참조자&amp;를 붙인 것과 정확히 동일하게 작동한다. 참조자는 해당 객체의 alias로 참조 대상을 바꿀 수 없었지만, reference_wrapper는 어디까지나 독립적인 객체이므로 타입만 동일하다면 얼마든지 참조 대상을 바꿀 수 있다.
std::ref()와 std::cref()로 생성할 수 있다. cref는 const형사실 주소를 전달하고 포인터로 받으면 필요 없다. 하지만 모던 C++은 포인터를 안 쓰는 방향으로 진행중이라 좀 더 유연한 방식의 참조 전달 방법을 개발한 것이다.예시를 보면 쉽게 이해가 된다.
여기 기존의 포인터를 쓰는 코드가 있다.C++1void print(int* i)2{3	printf("%d", *i); // 간접 참조로 주소에 접근해야 함.4}56int i = 10;7auto f1 = std::bind(print, &amp;i); // 주소 연산자를 붙여 전달해야 함.C++포인터는 사용하기가 상당히 까다롭다. 주소와 간접참조의 개념부터 이해해야 한다. 참조자를 쓴다면 훨씬 간단해지지만.
문제는 std::bind나 std::thread같이 인자가 됐든 뭐가 됐든 전달된 객체나 변수를 가지고 있다가 나중에 사용하는 형태로 설계된 놈들은 기본적으로 받은 모든 객체를 '복사해서' 가지고 있는다는 것이다.C++1void print(int&amp; i) // 참조자를 쓰면 간단해지겠지?2{3	printf("%d", i);4}56int i = 10;7auto f1 = std::bind(print, i); // 그러나 일단 bind로 묶을 때 i를 복사하기 때문에 참조자를 쓰는 의미가 없어진다.89i = 20;1011f1(); // 10이 출력된다.C++이런 놈들을 쓰려면 어쩔 수 없이 함수를 포인터를 받게 바꾸고, 주소를 전달해야 할까? 그게 싫었기 때문에 std::reference_wrapper라는 걸 만들었다.C++1// std::bind는 함수와 함수에 묶을 인자를 각각 보관하는 객체를 만들어서 반환하기 때문에, print 함수가 복사로 받던 참조로 받던 상관 없다. 복사로 받으면 참조하고 있는 놈을 호출 시점에 복사해서 전달하고, 참조로 받으면 참조하고 있는 놈을 참조로 전달할 것이다.2void print(int i)3{4	printf("%d", i);5}67int i = 10;8auto f1 = std::bind(print, i); // i를 복사한 10을 묶는다.9auto f2 = std::bind(print, std::ref(i)); // i의 참조 래퍼를 묶는다.1011i = 20; // i를 20으로 바꿈.1213f1(); // bind 시점에 복사한 10을 print에 전달, 10이 출력됨.14f2(); // bind 시점에 복사한 참조 래퍼가 가리키는 메모리 공간의 값을 print에 전달, 20이 출력됨.C++]]></description><link>0-발행완료/c,-c++/문법/reference_wrapper,-ref,-cref.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/reference_wrapper, ref, cref.md</guid><pubDate>Tue, 23 Sep 2025 13:06:15 GMT</pubDate></item><item><title><![CDATA[move, forward]]></title><description><![CDATA[둘 다 단순한 캐스팅 함수다. std::move는 l-value 참조를 r-value참조로 캐스팅하여 반환하고, std::forward는 universal reference를 받아서 상황에 따라 l-value 참조 또는 r-value 참조로 캐스팅하여 반환한다.Universal reference
auto 추론, 템플릿 타입 추론에서 전달되는 값이나 타입에 따라 좌측값 참조자 또는 우측값 참조자로 변환되는 참조자.
auto&amp;&amp; 또는 template &lt;typename T&gt; void Foo(T&amp;&amp; param)의 꼴이다.
C++1template &lt;class _Ty&gt;2using remove_reference_t = typename remove_reference&lt;_Ty&gt;::type;34// FUNCTION TEMPLATE move5template &lt;class _Ty&gt;6// 받을 땐 보편 참조로 받지만, remove_reference_t를 사용해 우측값이든 좌측값이든 모조리 우측값 참조로 만들어버린다.7_NODISCARD constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept { // forward _Arg as movable8 return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);9}C++std::move는 강제로 우측값 참조로 캐스팅하므로 우측값 참조 캐스팅이 불가능한 경우에 사용하지 않도록 주의해야 한다. 이동이 불가능한 경우엔 복사가 대신 일어난다. 예컨대,C++1const Foo foo(123);2Foo foo2 = std::move(foo);C++위 코드에서 std::move로 foo를 우측값 참조로 캐스팅해 이동시키려고 했지만, foo는 const속성을 가지고 있어 이동이 불가능하기 때문에 대신 복사 대입 연산을 사용하게 된다.
std::move를 사용한다는 것 자체가 이동 연산을 수행하겠다는 의도인데, 이건 아주 치명적인 버그가 될 수도 있다.전달된 참조가 l-value면 아무것도 하지 않고 l-value 참조로 리턴하고, 그 외에는 r-value 참조로 캐스팅하여 반환하는 함수.C++1// FUNCTION TEMPLATE forward2template &lt;class _Ty&gt;3_NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp; _Arg) noexcept 4{ // forward an lvalue as either an lvalue or an rvalue5 return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);6}78template &lt;class _Ty&gt;9_NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg) noexcept 10{ // forward an rvalue as an rvalue11 static_assert(!is_lvalue_reference_v&lt;_Ty&gt;, "bad forward call");12 return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);13}C++보통 보편 참조 매개변수를 받는 함수를 통해 좌측값, 우측값일 때 각각 다르게 처리해야 하는 로직을 구현할 때 알맞은 위치로 보내기 위해 사용한다.C++1void Catch(Foo&amp; p); // 좌측값 참조는 여기로2void Catch(Foo&amp;&amp; p); // 우측값 참조는 여기로34template &lt;typename T&gt;5void Forwarding(T&amp;&amp; obj)6{7	Catch(std::forward&lt;T&gt;(obj));8}910int main()11{12	Foo foo;13	Forwarding(foo); // 첫번째로 감14	Forwarding(std::move(foo)); // 두번째로 감15}C++]]></description><link>0-발행완료/c,-c++/문법/move,-forward.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/move, forward.md</guid><pubDate>Tue, 23 Sep 2025 13:06:13 GMT</pubDate></item><item><title><![CDATA[friend]]></title><description><![CDATA[외부의 클래스나 함수가 해당 클래스에 public으로 접근할 수 있도록 강제하는 키워드.
편리하지만 캡슐화를 위반하는 위험한 키워드이다. 난발하지 않도록 하자.C++1// 외부의 함수2void Func(int x);34// 외부의 클래스5class Foo{ ... };67class Bar8{9	friend void Func(int); // 특정 함수에 대한 friend화10	friend class Foo; // 특정 클래스 전체에 대한 friend화11	friend void Foo::Func(); // 특정 클래스의 특정 메서드에 대한 friend화12	// 이제 friend로 지정된 범위에선 Bar의 모든 멤버가 public인 것처럼 접근할 수 있다.13};C++friend를 붙이고 그 자리에서 바로 함수나 클래스를 정의할 수도 있는데, 이러면 외부에서 정의하고 그걸 friend화 한 것으로 인식하게 된다. 따라서 멤버함수처럼 this 포인터를 사용하거나 그럴 수 없다. 단순히 편의를 위한 문법.C++1class Bar2{3	friend void Func(int x) // 외부 스코프에서 선언된 것으로 취급한다.4	{5 cout &lt;&lt; x;6	}7}C++]]></description><link>0-발행완료/c,-c++/문법/friend.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/friend.md</guid><pubDate>Tue, 23 Sep 2025 13:06:09 GMT</pubDate></item><item><title><![CDATA[C++ 메모리 정렬 연산]]></title><description><![CDATA[최신 컴퓨터 하드웨어의 CPU는 데이터의 주소가 데이터 사이즈의 배수일 때(즉, 데이터 사이즈로 주소를 나누었을 때 나머지가 생기지 않을 때) 메모리에 대한 읽기 쓰기 연산을 가장 효율적으로 처리할 수 있다.그 상태를 데이터가 ‘자연스럽게 정렬(naturally aligned)’되어 있다고 말한다.컴파일러와 ABI가 기본적으로 구조체 패딩을 진행하는 이유가 이러한 자연 정렬 상태를 보장하기 위함이다.Note
‘메모리를 정렬(align)한다’는 건 메모리 주소를 해당 정렬 크기 단위로 잘라서 읽는다는 의미이다. 예컨대 ‘32바이트로 정렬된 구조체’는 메모리 상에서 시작 주소가 반드시 32의 배수가 되는 곳에 배치되기 시작하고, alignas 등으로 정렬 크기를 정해서 선언한 경우 그 멤버들도 32의 배수 자리에 놓이게 된다. 빈 공간은 그대로 낭비가 된다.
일반적으로 x86-64, ARM64 환경에서는 기본 최대 정렬 단위가 16바이트이다. 이는 초기 SIMD 벡터 타입(__m128 벡터)을 포함해 일반 자료형의 최대 크기가 16바이트를 초과하지 않기 때문이다. 따라서 일반 자료형을 사용할 때 정렬크기(alignof(T))는 그 자료형의 크기를 넘을 수 없다.일반적으론 ABI 규칙에 맞게 컴파일러가 알아서 정렬을 수행하므로 개발자는 효율적인 구조체 구조만 생각하면 된다. 그러나 경우에 따라 16바이트를 초과하는 크기로 정렬해야 하는 경우가 있다.예컨대 SIMD 벡터 연산에서 __m256 벡터를 선언하거나 _mm256_store_ps 와 같은 함수를 사용한다면 거기에 맞는 크기로 정렬 단위가 맞춰져 있어야 한다. 그렇지 않으면 segmentation fault가 발생하거나, unaligned load/store가 강제되어 연산이 느려질 수 있다.혹은 하드웨어 I/O의 경우 종종 Direct Memory Access를 지원하기 위해 하드웨어 차원에서 특정 크기로 정렬된 메모리 블록만 받아들이는 경우가 있다. 이 때는 alignas 등으로 강제로 정렬 크기를 맞추어 통신해야 한다.type의 정렬 크기를 반환하는 연산자. 예컨대 alignof(float[10]) 는 4바이트 크기로 정렬된 float들의 배열의 정렬 크기이므로 4를 반환하고, alignof(struct{char c; int n;}) 는 구조체 정렬 규칙에 의해 가장 큰 단위인 int n 멤버의 크기 4바이트로 정렬되므로 4를 반환한다.타입 선언 시 특정 크기로 메모리를 정렬하도록 요구하는 예약어. 물론 이걸 썼다고 이상한 값까지 무조건 정렬해준다는 뜻은 아니다. ABI 규칙과 컴파일러의 기분에 따라 가능하면 해준다.C++1alignas(32) int i; // 32바이트로 정렬된 형태의 메모리에 배치2struct alignas(32) Foo { int a, b; }; // 구조체의 모든 멤버를 32바이트로 정렬된 형태의 메모리에 배치C++C++17에서 추가된 매크로. 특별한 건 아니고 이 값이 ‘정렬 크기’라는 걸 명시하기 위한 단위이다. new, delete 등에서 정렬 단위 인자를 이 타입으로 받는다. 어떤 값이 ‘바이트 크기’임을 명시하기 위한 size_t 랑 똑같다. 둘 다 1바이트 단위.]]></description><link>0-발행완료/c,-c++/문법/c++-메모리-정렬-연산.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/C++ 메모리 정렬 연산.md</guid><pubDate>Tue, 23 Sep 2025 13:05:59 GMT</pubDate></item><item><title><![CDATA[constexpr]]></title><description><![CDATA[객체 혹은 함수의 리턴값을 컴파일 타임에 알 수 있는 상수식으로 만드는 키워드.
컴파일러가 컴파일 타임에 어떤 식의 값을 결정할 수 있다면, 해당 식을 상수식(Constant expression)이라고 한다.특히 정수 상수식은 쓰임이 굉장히 많다.C++1int arr[size]; // 배열의 크기 size는 상수식이어야 한다.23template &lt;int N&gt; struct A { ... };4A&lt;number&gt; a; // 템플릿은 컴파일 타임에 생성되므로 템플릿 인자 number는 상수식이어야 한다.56enum Fruit { Apple = number, Grape, Berry }; // enum 값 number는 상수식이어야 한다.C++constexpr 키워드가 붙은 변수는 그 자체로 상수식이 된다. 따라서 담기는 값은 컴파일 타임에 결정될 수 있어야 한다.C++1// 예제 12int GetOne() { return 1; }34const int a = GetOne(); // const 키워드는 생성 시점의 초기화 후 상수성을 가짐을 의미. 꼭 컴파일에 결정되는 값을 받을 필요 없이 컴파일, 런타임 시점 모두 사용 가능하다. 따라서 이 라인은 오류가 발생하지 않는다.56constexpr int b = GetOne(); // 반면 constexpr int는 반드시 컴파일 타임에 결정되어야 한다. 따라서 런타임에 반환되는 값으로 초기화할 수 없다. 오류가 발생한다.789// 예제 210template &lt;int N&gt; struct A { ... };11constexpr int _N = 10;1213A&lt;_N&gt; a; // constexpr int는 컴파일 타임에 결정되는 값이므로 템플릿 인자로 사용할 수 있다. 오류가 발생하지 않는다.C++Note
참고로 const 키워드는 상수식으로도, 비-상수식으로도 쓰일 수 있다. VS 컴파일러는 상수 리터럴처럼 컴파일 타임에 결정되는 값을 받으면 상수식으로 해석하고, 다른 변수나 함수처럼 런타임에 결정되는 값을 받으면 비-상수식으로 해석하지만, 컴파일러에 따라 이를 지원하지 않을 수도 있기 때문에, 상수식으로 활용할 생각이라면 명시적으로 constexpr 키워드를 사용하는 것이 좋다.
constexpr 키워드가 추가되기 이전까지는 컴파일 타임에 반환값이 결정되는 함수를 설계하는 것은 불가능했다. 아래와 같이 난해한 템플릿 메타 프로그래밍으로 구현할 수는 있었지만, 사용에 제약이 많았다.C++1template &lt;int N&gt;2struct Factorial { // F&lt;0&gt; ~ F&lt;N&gt; 까지를 전부 컴파일 타임에 생성3	static const int value = N * Factorial&lt;N-1&gt;::value;4};56template &lt;&gt;7struct Factorial&lt;0&gt; { // 탈출 조건이 되는 템플릿 특수화8	static const int value = 1;9};1011int Arr[Factorial&lt;10&gt;::value];C++이제는 constexpr 키워드를 붙여 반환만 해주면, 조건에만 부합한다면 컴파일러가 알아서 적절한 처리(실제로 계산을 한다!)를 해서 컴파일 타임에 리턴값을 결정하고 이걸로 치환해버린다.C++1// 이 함수는 반환값을 결정하는데 런타임에만 알 수 있는 다른 외부 변수가 필요하지 않다. 따라서 오류가 나지 않는다.2constexpr int Factorial(int n)3{4	int total = 1;5	for (int i = 1; i &lt;= n; ++i)6 total *= 1;7	8	return total;9}1011int main()12{13	// 컴파일러는 컴파일 타임에 함수를 동작시켜서 반환값을 결정한 뒤 Factorial(10) 부분을 그 값으로 치환해버린다.14	int arr[Factorial(10)];15}C++만약 constexpr 반환타입을 가진 함수가 반환값을 결정함에 있어 런타임에만 얻을 수 있는 다른 변수를 취급해야 하거나, 매개변수로 비-상수식이 전달되었다거나 이러면 그냥 일반 함수처럼 런타임에 반환값을 반환하는 함수가 된다.C++11까지는 constexpr 함수의 사용에 제약이 많았으나, C++14부터 다음의 제약을 제외하고는 편리하게 사용할 수 있게 되었다. 다음은 constexpr 함수가 상수식을 반환하기 위해 지켜야 하는 조건이다.
내부에 goto문을 사용하면 안 된다. goto문은 스택 메모리를 사용하여 런타임에 동작하기 때문이다.
try - catch 예외 처리를 해선 안 된다. (단, C++20부터는 가능해졌다.)
내부에서 리터럴 타입이 아닌 변수(쉽게 말해 런타임에 완성되는 변수)를 정의해선 안 된다.
초기화되지 않은 변수를 정의해선 안 된다.
내부에서 다른 함수를 호출할 땐 그 함수도 반드시 상수식을 반환하는 constexpr 함수여야 한다.
리터럴 타입이란?
컴파일러가 컴파일 타임에 정의할 수 있는 타입을 말한다. 대충 아래와 같다. void타입, 스칼라타입(int, char, float 같은 원시타입)
리터럴 타입의 레퍼런스
constexpr 함수인 람다 함수
Aggregate 타입: 사용자 정의 생성자나 소멸자가 없고, 모든 데이터 멤버가 public인 클래스. std::pair가 대표적
혹은 다음의 조건을 만족하는 클래스 디폴트 소멸자를 사용한다.
constexpr 생성자를 정의한다. ~ constexpr 생성자는 constexpr 함수에 적용되는 제약이 모두 적용되며, 다른 클래스를 가상 상속 받을 수 없다.
복사 및 이동 생성자를 정의하지 않는다. 제네릭 메타 프로그래밍은 템플릿의 성질(컴파일 타임에 코드를 생성해내는 것)을 활용해 컴파일 시점에 코드의 구조를 연쇄적으로 생성하여 연산에 이용하는 일종의 트릭이다.
반면 constexpr 함수는 컴파일러가 컴파일 타임에 실제로 함수를 동작시켜서 결과값을 구해 그걸로 호출문을 치환하는 방식이다.
전자는 코드 뭉치를 실제로 생성해내므로 실행파일의 용량을 키우지만, 후자는 그렇지 않다. 다만 전자는 DP에서 메모이제이션을 활용하듯이 재활용이 가능하다는 장점은 있다.
물론 둘 다 컴파일에 걸리는 시간은 늘린다.예컨대 타입에 따라 형태가 달라지는 템플릿 함수를 짜고 싶다고 하자.
템플릿 타입 추론을 이용하면 다음과 같이 짤 수 있다.C++1template &lt;typename T&gt;2void GetValue(T t)3{4	std::cout &lt;&lt; "It's not a pointer : " &lt;&lt; t &lt;&lt; std::endl;5}6template &lt;typename T&gt;7void GetValue(T* t)8{9	std::cout &lt;&lt; "It's a pointer : " &lt;&lt; *t &lt;&lt; std::endl;10}C++잘 작동하지만, 문제는 함수가 정확히 어떤 형태의 T를 요구하는지 알기가 어렵고(직관성이 떨어짐), 같은 함수를 두 번 쓰게 된다는 것이다.&lt;type_traits&gt;에는 여러 템플릿 메타 함수들을 제공하니 이걸 사용해서 간소화해볼 수 있겠다.C++1template &lt;typename T&gt;2void GetValue(T t)3{4	if (std::is_pointer&lt;T&gt;::value)5	{6 std::cout &lt;&lt; "It's a pointer : " &lt;&lt; *t &lt;&lt; std::endl;7	}8	else9	{10 std::cout &lt;&lt; "It's not a pointer : " &lt;&lt; t &lt;&lt; std::endl;11	}12}1314int a = 3;15GetValue(x);C++그런데 컴파일해보면 오류가 난다. 왜냐면 if문 분기가 있으면 컴파일러는 이 중 어떤 분기를 사용할 지 알 수 없으므로 모든 코드를 컴파일하게 되는데, 만약 T에 포인터가 아닌 것이 들어갔다면 *t 연산이 불가능하기 때문이다.이럴 땐 if constexpr을 사용해 아예 코드 자체가 컴파일되지 않도록 해야 한다.C++1template &lt;typename T&gt;2void GetValue(T t)3{4	if constexpr (std::is_pointer&lt;T&gt;::value)5	{6 std::cout &lt;&lt; "It's a pointer : " &lt;&lt; *t &lt;&lt; std::endl;7	}8	else9	{10 std::cout &lt;&lt; "It's not a pointer : " &lt;&lt; t &lt;&lt; std::endl;11	}12}1314int a = 3;15GetValue(x);C++if constexpr 분기는 컴파일 타임에 상수식 조건을 체크하고, 거짓인 분기는 아예 컴파일 하지 않고 무시해버린다. #ifdef 명령어와 비슷하게 작동한다.if constexpr의 조건식은 bool로 변환될 수 있는 상수식이어야 한다.]]></description><link>0-발행완료/c,-c++/문법/constexpr.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/constexpr.md</guid><pubDate>Tue, 23 Sep 2025 13:05:39 GMT</pubDate></item><item><title><![CDATA[concept, requires]]></title><description><![CDATA[C++20에서 추가된 템플릿 메타 프로그래밍을 위한 도구.
requires 키워드로 올 수 있는 템플릿 타입의 조건을 규정하고(어떤 타입이 올 수 있는지 정의할 뿐 아니라, 매개변수에 의미론적(semantic) 제약을 가할 수도 있다), concept로 이를 캡슐화할 수 있다.캡슐화된 제약 조건 덩어리.
컴파일 타임에 결정되는 bool을 반환하거나 그러한 값으로 귀결될 수 있어야 한다.
constexpr, consteval 키워드로 bool 타입을 반환하는 컴파일 타임 함수를 만들어 사용할 수도 있고, &lt;type_traits&gt;, &lt;concepts&gt; 헤더에 정의된 제네릭 함수들을 써도 된다.템플릿 타입이 '어떤 타입'이어야 한다는 형식 제약을 규정한다.
concept 이름 = 형식 제약 꼴로 선언하며, 컴파일 타임에 bool 값을 반환하는 식이어야 한다.C++1#include &lt;type_traits&gt;23class Weapon {};4class Sword : public Weapon {};56// concept의 정의7template &lt;typename T&gt;8concept IsWeapon = std::is_base_of_v&lt;Weapon, T&gt;;910template &lt;typename T&gt; requires IsWeapon&lt;T&gt;11void Foo(T weapon) { ... }C++requires 키워드와 함께 사용해 템플릿 타입이 '어떤 구조를 가진 타입'이어야 한다는 구조적 제약을 규정한다. (ex: Foo 라는 멤버를 가진 타입만 올 수 있음)
concept 이름 = requires(가상의 인스턴스) { 유효한지 확인할 표현식 }; 꼴로 작성한다.
bool을 반환하는 방식이 아니라 SFINAE를 통해 표현식의 유효성 여부를 검증하는 방식임에 주의하자.다음은 구조적 제약 컨셉의 몇 가지 예시들이다.C++1template &lt;typename T&gt;2concept Addable = requires(T a, T b)3{4	a + b; // 이 식이 성립하는지 체크한다.5};67template &lt;typename T&gt;8concept HasName = requires(T t)9{10	t.name; // name이란 이름의 멤버를 가지고 있으며, 현재 context에서 접근 가능한지 체크한다.11}1213template &lt;typename T&gt;14concept HasSubtypeFoo = requires(T t)15{16	typename T::Foo; // Foo라는 타입이 내부에 정의되어 있는지 체크한다.17}1819template &lt;typename T, typename U = T&gt;20concept Swappable = requires(T&amp;&amp; t, U&amp;&amp; u)21{22	std::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u)); 23	std::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t)); // std::swap으로 스왑 가능한지 체크한다.24}C++자주 발생하는 실수가 구조적 제약인 요구 조건 표현식에 형식 제약을 넣으려고 하는 것이다.
requires 요구 조건 표현식에 의해 구현되는 구조적 제약은 어디까지나 '이 식이 문법적으로 유효한가'만을 평가하지 '이 식이 결과적으로 true를 반환하는가 false를 반환하는가'를 평가하는 게 아니라는 것을 명심해야 한다.C++1// 예컨대, 다음 요구 조건 표현식은 T가 정수형이 아니어도 std::integral&lt;T&gt;가 false를 반환하므로 문법적으로 오류가 없고, 따라서 모든 T에 대해 통과된다.2template &lt;typename T&gt;3concept Requirements = requires(T t)4{5	std::integral&lt;T&gt;;6}78// 정수형만 통과시키려면 형식 제약 컨셉을 정의하는게 좋다.9template &lt;typename T&gt;10concept Requirements = std::integral&lt;T&gt;;C++만약 서로 종류가 다른 두 제약을 동시에 걸고 싶다면, 우선 requires 요구 조건 표현식을 쓰고 그 안에 다시 requires 형식 조건 라인을 작성하면 된다.C++1template &lt;typename T&gt;2concept HasKeyWhichInt = requires(T t)3{4	t.value; // (1) t는 value 멤버를 가지며, 현재 context에서 접근할 수 있는가?5	requires std::same_as&lt;decltype(t.key), int&gt;; // (2) t는 key 멤버를 가지고, 그 멤버는 int 타입인가? t가 key라는 멤버를 가지지 않거나, int가 아니라면 조건에 부합하지 않는다.6}C++혹은, 그냥 두 컨셉을 각각 만들어서 두 개를 AND로 묶어도 상관 없다.C++1// 구조적 제약 컨셉2template &lt;typename T&gt;3concept Addable = requires(T a, T b)4{5	a + b;6};78// 형식 제약 컨셉9template &lt;typename T&gt;10concept IsIntegral = std::integral&lt;T&gt;;1112// 두 개를 합친 컨셉13template &lt;typename T&gt;14concept UnionRequirement = Addable&lt;T&gt; &amp;&amp; IsIntegral&lt;T&gt;;C++제약조건을 제시하는 키워드. requires 뒤에 제약조건을 쓰는 것으로 사용된다.
템플릿 키워드 뒤에서 사용되면 뒤에 오는 표현식을 제약조건으로 제시한다. bool을 반환하는 상수 표현식, concept, type_traits나 concepts 헤더에 정의된 제네릭 함수 어떤 것이든 오거나 논리 연산자로 조합해 사용할 수 있다.
위에서 보았듯이 concept을 정의할 때 요구 조건 표현식 내에서 형식 제약을 거는데 사용할 수 있다.
'컴파일 타임 술어(Compile-time Predicate)'도 제약조건으로 제시할 수 있다.
어디까지나 제네릭 프로그래밍이므로 제약 조건에 부합하지 않으면 에러를 내는 것이 아니라 SFINAE 규칙에 따라 해당 템플릿을 후보에서 제외할 뿐이다.
키워드가 오는 위치는 temaplate&lt;&gt; 키워드 뒤에, 또는 함수의 서명 뒤에 올 수 있다.C++1template &lt;typename T&gt; requires std::is_integral_v&lt;T&gt; // 여기 올 수도2void Foo(T arg)3{ ... }45template &lt;typename T&gt;6void Foo(T arg) requires std::is_integral_v&lt;T&gt; // 여기 올 수도 있다. 이 경우엔 '후행 requires 절'이라고 부른다.7{ ... }C++requires 절은 템플릿의 서명에 포함되므로, 선언부와 정의부에 동일하게 적어야 한다. VS가 자동으로 함수 정의부를 만들어줄 때 이걸 빼먹으니 주의하기 바람.다음은 requires를 활용하는 몇 가지 예시들이다.C++1template &lt;typename T&gt; requires std::is_integral_v&lt;T&gt;2void Foo(T arg) { ... }34double Foo(double arg) { ... }56Foo(1); // 1번 함수. is_integral_v&lt;int&gt;가 true를 반환하여 템플릿 구체화.7Foo(3.14f); // 2번 함수. is_integral_v&lt;float&gt;이 false를 반환하여 템플릿 구체화가 일어나지 않음. 그 다음 후보인 2번 함수에 인자가 암시적 변환되어 전달됨.C++C++1// 템플릿 오버로딩2#include &lt;concepts&gt; // 여러 기정의된 컨셉트용 템플릿 함수 제공34// 1. 임의 접근이 가능한 컨테이너의 이터레이터를 받는 경우 -&gt; 포인터 더하기 연산으로 이동5template &lt;typename T&gt; requires std::random_access_iterator&lt;T&gt;6void MoveForward(T&amp; iter, int amount)7{8	iter = iter + amount;9}1011// 2. 임의 접근이 불가능한 컨테이너의 이터레이터를 받는 경우 -&gt; 다음 이터레이터로 반복 이동12template &lt;typename T&gt; requires std::input_iterator&lt;T&gt;13void MoveForward(T&amp; iter, int amount)14{15	while (amount--) ++iter;16}1718std::vector&lt;int&gt; v = { 1, 2, 3, 4, 5, 6 };19std::list&lt;int&gt; l = { 1, 2, 3, 4, 5, 6 };20MoveForward(std::begin(v), 3); // 1번 조건 통과 -&gt; 구체화21MoveForward(std::begin(l), 3); // 1번 조건 실패 -&gt; 2번 조건 통과 -&gt; 구체화C++Note
같은 접근 순위의 템플릿 오버로딩 간에는 위에서부터 아래로 내려가며 순서대로 구체화를 시도한다는 걸 명심하자.
bool을 반환하는 조건식을 직접 작성하는 것. 괄호()로 묶어야 한다.
컴파일 타임 술어는 일반적인 표현식과 형태가 같지만, constexpr 함수처럼 컴파일 시점에 컴파일러가 연산을 수행해 그 결과로 치환하는 형태이다.C++1template &lt;int N&gt; requires (N &gt;= 0)2void Foo() { ... }C++requires 키워드를 사용하지 않고 템플릿 매개변수 자리에 바로 컨셉을 넣는 축약 형태도 허용된다.C++1// 1. 일반적인 템플릿에 사용2// typename이나 class 대신 컨셉을 마치 타입을 적는 것처럼 넣는다.3template &lt;std::integral T&gt;4void Foo(T arg) { ... }56// 2. auto 단축 템플릿에도 사용 가능7// 이 경우 다음과 같이 '컨셉 + auto' 덩어리를 타입처럼 취급하면 된다.8std::integral auto Foo(std::integral auto arg) { ... }910// 3. 템플릿 특수화에도 사용 가능11template &lt;typename T&gt; struct Foo { ... };12template &lt;std::integral T&gt; struct Foo&lt;T&gt; { ... }; // 정수 타입에 대한 특수화1314// 4. 가변 인수 템플릿에도 사용 가능15template &lt;std::integral... Args&gt;16void Foo(Args... args) { ... }17181920// 이를 requires 절을 사용하는 기본 형태로 작성하면 다음과 같다.21// 1. 일반적인 템플릿22template &lt;typename T&gt; requires std::integral&lt;T&gt;23void Foo(T arg) { ... }2425// 2. auto 단축 템플릿26std::integral auto Foo(auto arg) requires std::integral&lt;decltype(value)&gt; { ... }2728// 3. 템플릿 특수화29template &lt;typename T&gt; struct Foo { ... };30template &lt;typename T&gt; requires std::integral&lt;T&gt; struct Foo&lt;T&gt; { ... };3132// 4. 가변 인수 템플릿에도 사용 가능33// 가변 인수 템플릿을 requires로 제약을 걸려면 컴파일 타임 술어와 템플릿 파라미터 팩을 사용해 모든 인자에 대해 체크해야 한다.34template &lt;typename... Args&gt; requires (std::integral&lt;Args&gt; &amp;&amp; ...)35void Foo(Args... args) { ... }36C++다음은 &lt;concepts&gt; 에서 제공하는 컨셉의 목록이다. 대부분 type_traits를 사용한 메타프로그래밍 기법으로 구현되어 있다. 다만 훨씬 편하게 정리되어 있으므로 type_traits 대신 concepts를 사용할 것을 권장한다.T가 정수 타입인지, 부동소수점 타입인지 확인한다.T가 부호 있는 정수 타입인지, 부호 없는 정수 타입인지 확인한다.두 타입이 서로 같은 타입인지 확인한다. 아래와 같이 구현되어 있다. 자리가 바뀐 경우도 확실히 해놨음.C++1namespace detail {2	template &lt;class T, class U&gt;3	concept SameHelper = std::is_same_v&lt;T, U&gt;;4}56template &lt;class T, class U&gt;7concept same_as = detail::SameHelper&lt;T, U&gt; &amp;&amp; detail::SameHelper&lt;U, T&gt;;C++D가 B를 상속했는지, 업캐스팅이 가능한지 확인한다. 다음과 같이 구현되어 있다.C++1template &lt;class Derived, class Base&gt;2concept derived_from =3 std::is_base_of_v&lt;Base, Derived&gt; &amp;&amp;4 std::is_convertible_v&lt;const volatile Derived*, const volatile Base*&gt;;C++]]></description><link>0-발행완료/c,-c++/문법/concept,-requires.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/concept, requires.md</guid><pubDate>Tue, 23 Sep 2025 13:05:37 GMT</pubDate></item><item><title><![CDATA[assert, static_assert]]></title><description><![CDATA[특정 지점에서 특정 조건이 참일 것을 가정하고, 참이 아니라면 프로그램의 실행을 중단하고 에러를 출력하는 기능.C에서는 #error 전처리자나 &lt;assert.h&gt; 헤더에 정의된 assert 매크로를 사용해 Assertion이 가능했다.C++1// #error 전처리자. 전처리 단계에서 #error를 만나면 컴파일 오류를 발생시킨다. 이 때, 뒤에 나오는 errortoken-string 문자열을 출력한다.23#ifndef ENGINE4#error Engine is not included.5#endifC++C++1// assert 매크로. 런타임에 표현식을 체크하여 false일 경우 런타임 에러를 발생시킨다.2#include &lt;cassert&gt;34void foo(int age)5{6	assert(age &gt; 0); // 표현식이 참이 아닐 경우 에러 문구를 출력한다.7	...8}910// 설명 문구까지 출력하고 싶다면 일종의 꼼수로 항상 참인 설명 문자열을 &amp;&amp; 연산자로 같이 전달하면 된다.11#define Assert(expression, message) assert(expression &amp;&amp; message)12Assert(age &gt; 0, "나이는 양수여야만 합니다.");13Assert(dynamic_cast&lt;Parent*&gt;(t), "Parent* 타입으로 업캐스팅할 수 없습니다");C++#error는 전처리 단계에서 발생하므로 템플릿이 구체화되기 전에 수행되어 C++에서 사용하기에는 적절하지 않다.assert 매크로의 경우 디버그 빌드에서 런타임에 작동하는데, assert는 어디까지나 예외를 던지고 처리하는 역할이 아니라 표현식의 유효성을 검증하는 일종의 트랩이기 때문에, 컴파일 타임에 체크가 가능하다면 굳이 런타임 중에 확인할 이유는 없다.
이런 경우엔 컴파일 타임에 체크할 수 있다면 생산성 면에서 더 좋을 것이다.그래서 C++11에서 static_assert 매크로가 도입되었다. 컴파일 타임(템플릿 구체화 이후에)에 작동하여 조건을 판정하고 거짓이면 컴파일을 중단하고 컴파일 에러를 발생시킨다. 표현식만 혹은 두 번째 인자로 설명 문구도 넣어서 체크할 수 있다.```cpp
template &lt;typename T&gt;
void DoSomething(T&amp; t)
{ static_assert(std::is_integral&lt;T&gt;::value, "T는 정수타입이어야 함.");
}
근데 실제론 잘 안 쓴다. 템플릿 메타 프로그래밍 같은 데서나 써먹을만 하다.]]></description><link>0-발행완료/c,-c++/문법/assert,-static_assert.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/assert, static_assert.md</guid><pubDate>Tue, 23 Sep 2025 13:05:36 GMT</pubDate></item><item><title><![CDATA[포인터와 배열]]></title><description><![CDATA[Note
C++에선 훨씬 쉽고 편리하며 직관적인 가변 길이 배열 STL 컨테이너를 사용하도록 하자.
C/C++에서 배열은 특정한 크기의 할당된 메모리 블록을 의미한다. 이 때 배열명은 특별한 의미를 가진다.
일반적으로 배열명 arr은 &amp;arr[0] 즉 배열의 첫 번째 요소의 주소를 가리키는 포인터로 암시적 변환된다.
단, 아래의 상황에선 예외로 배열 전체를 의미한다. sizeof(arr) 은 배열의 전체 크기를 반환한다.
&amp;arr 은 '배열 전체의 시작 주소'를 의미한다. 따라서 &amp;arr + 1은 '배열 전체의 다음 번지'를 가리킨다. 이 차이 때문에 다소 헷갈리는 문법이 된다. 다음은 배열명에 대한 주소 연산이 가지는 의미이다.C++1// int arr[4];23arr -&gt; 첫 번째 요소의 주소 (&amp;arr[0])4&amp;arr -&gt; 배열의 시작 주소56arr + 1 -&gt; 두 번째 요소의 주소 (&amp;arr[1])7&amp;arr + 1 -&gt; 배열의 크기(16바이트)만큼 이동한 주소C++T(*name)[size] 꼴로 선언되는 포인터는 해당 크기의 배열만 가리킬 수 있는 배열 포인터이다.C++1int arr[5];23// 일반 포인터로 arr의 한 요소를 가리킬 수 있다.4int* p1 = arr;56// 배열 포인터로 arr 전체를 가리킬 수 있다.7int (*pArr)[5] = &amp;arr;C++배열 포인터의 의의는 배열의 크기 정보를 유지하면서 가리킬 수 있다는 데에 있다. 배열을 일반 포인터로 가리키게 되면, 그냥 시작 요소의 주소만 저장될 뿐 크기 정보는 잃어버리게 된다.다음과 같은 경우에 사용한다.
다차원 배열을 포인터로 가리킬 때. 저차원 배열의 크기를 알아야 다음 요소가 어디서부터 시작하는 지 알 수 있으므로 접근이 가능하다.
함수의 인자로 배열을 전달할 때. 배열 포인터를 사용하면 크기 정보를 잃지 않고 전달할 수 있으며, 버퍼 오버런을 방지할 수 있다. 만약 배열 포인터를 사용하지 않으면, 별도로 요소의 개수를 인자로 전달해서 사용해야 한다.
3x4 크기의 int형 배열을 담으려면 int[4] 크기의 배열 포인터에 시작 요소(int[4] 배열)의 주소를 담거나, int[3][4] 크기의 배열 포인터에 배열 전체를 담으면 된다.C++1int arr[3][4] = { { 0, 1, 2, 3 }, { 4, 5, 6, 7 }, { 8, 9, 10, 11 } };2int(*pArr1)[4] = arr;3int(*pArr2)[3][4] = &amp;arr;C++전자의 경우엔 크기 4 배열이 '3개 있다는' 정보는 소실된다. 이는 1차원 배열을 일반 포인터로 가리키게 했을 때 배열의 크기 정보가 소실되는 것과 똑같은 상황이다.접근할 땐 똑같이 첨자 연산자를 이용하면 된다.C++1pArr1[1][3]; // 2번째 요소의 4번째 요소, arr[1][3]2// = *(*(pArr1 + 1) + 3);34// 동일한 크기의 배열 포인터를 통해 접근할 땐 첫 번쨰 요소만 존재한다.5pArr2[0][1][3]; // 첫 번째 요소의 2번째 요소의 4번째 요소, arr[1][3]6// = *(*(*(pArr2 + 0) + 1) + 3);C++pArr1은 int[4] 크기를, pArr2는 int[3][4] 크기를 가리키는 포인터이므로, 주소연산을 했을 때 그 크기만큼 이동하는 것을 볼 수 있다.다차원 배열도 똑같다.C++1int arr[2][3][4] = {2 {3 { 11, 22, 33, 44 },4 { 55, 66, 77, 88 },5 { 99, 110, 121, 132 }6 },7 {8 { 111, 122, 133, 144 },9 { 155, 166, 177, 188 },10 { 199, 1110, 1121, 1132 }11 }12};1314int(*pArr1)[3][4] = arr; // 첫 번째 요소 (int[3][4])를 가리키는 포인터15int(*pArr2)[2][3][4] = &amp;arr; // 배열 전체를 가리키는 포인터1617cout &lt;&lt; pArr1[0][2][1] &lt;&lt; endl;18cout &lt;&lt; *( *( *(pArr1 + 0) + 2) + 1);C++]]></description><link>0-발행완료/c,-c++/문법/포인터와-배열.html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/포인터와 배열.md</guid><pubDate>Tue, 23 Sep 2025 13:05:34 GMT</pubDate></item><item><title><![CDATA[특수 멤버 함수의 정의 규칙 (The rule of five)]]></title><description><![CDATA[The rule of five는 "소멸자, 복사생성자, 복사대입연산자, 이동생성자, 이동대입연산자"라는 다섯 가지 특수 멤버 함수 중 하나라도 정의한다면, 나머지에 대한 정의와 처리도 고민해야 한다는 원칙이다.
이 다섯 가지 특수 멤버 함수는 서로 긴밀하게 관련되어 있으며, 그렇기에 Cpp 컴파일러는 개발자가 특정한 상황에 특정한 특수 멤버 함수를 정의하지 않으면 이에 대한 기본 형태를 자동으로 생성해버린다.Note
실제로 컴파일러의 클래스 최적화는 훨씬 복잡하고 다양한 형태로 나타난다고 한다. 개념적인 차원에서 이해하자.
기본적으로 Cpp 표준에서 권장하는 방식은 5가지 중 하나라도 직접 정의했으면, 나머지도 직접 정의하라는 것이다. 이는 예상치 못한 동작을 예방하기 위함이기도 하고, 의사를 명확히 밝혀 협업자와의 오해의 소지를 원천 차단하기 위함이다.컴파일러의 자동 생성 규칙은 다음의 표가 잘 설명하고 있다.<img alt="♣VaultStorage/attachment/Pasted image 20250303124306.jpg" src="♣vaultstorage/attachment/pasted-image-20250303124306.jpg" target="_self">이를 말로 쉽게 풀어보면 다음과 같다.
생성자의 정의 여부는 고려하지 않는다.
사용자가 아무것도 정의하지 않으면, 컴파일러는 가장 기본적인 동작만 수행하는(= default) 5가지 멤버 함수를 생성한다.
사용자가 소멸자를 직접 정의하면, 컴파일러는 복사 함수만 생성하고 이동 함수는 사용 불가능하게(= delete) 만든다.
사용자가 복사 함수 중 하나를 정의하면, 컴파일러는 다른 쪽 복사 함수를 생성하며, 이동 함수는 따로 생성하지 않으나, 복사 연산이 구현되어 있으므로 이동 연산은 복사 연산으로 대신 수행된다.
사용자가 이동 함수 중 하나를 정의하면, 컴파일러는 소멸자를 제외하고 다른 어떤 함수도 생성하지 않는다. 이는 이동 연산이 임의로 규정될 수 없을 정도로 위험하고 강력한 연산이기 때문이다.
]]></description><link>0-발행완료/c,-c++/문법/특수-멤버-함수의-정의-규칙-(the-rule-of-five).html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/특수 멤버 함수의 정의 규칙 (The rule of five).md</guid><pubDate>Tue, 23 Sep 2025 13:05:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[가상 함수 (Virtual function)]]></title><description><![CDATA[OOP의 핵심인 다형성, 그 중에서도 가장 중요하다고 할 수 있는 서브타입 다형성(런타임 다형성, 오버라이딩)을 구현하기 위한 개념.C++에선 부모 클래스의 함수 서명을 자식 클래스에서 그대로 사용할 경우, 부모 클래스의 함수는 숨겨지게 된다. 예컨대 Foo() 라는 함수가 부모와 자식 모두에 존재하면, 자식 객체를 통해 Foo()를 호출하면 자식의 Foo()가 호출되게 된다.물론 그렇다고 부모의 Foo() 함수가 사라진 것은 아니다. 부모의 타입을 명시하여 접근하는 것으로 호출은 가능하다. (물론, 호출되는 위치에서 접근이 가능하다면)문제는 부모 타입 포인터가 기본적으로 부모 타입의 함수에만 접근할 수 있다는 데에 있다. 다형성을 활용하려면 부모 타입 포인터가 업캐스팅된 자식 타입 객체를 가리키게 하고, 자식 타입에서 작성한 로직을 사용하도록 해야 한다.이 때 가상 함수를 사용한다.
virtual 키워드를 붙인 멤버 함수는 가상 함수가 되며, 자식이 같은 서명으로 멤버 함수를 선언할 경우 부모의 함수를 덮어쓰게(override) 된다. 이는 부모 포인터를 통해 자식 객체를 가리키고, 자식이 override한 함수를 부모 포인터를 통해 호출하면, 포인터가 가리키는 실객체인 자식의 함수가 호출됨을 의미한다.Note
'overriding'은 어디까지나 부모-자식 간 캐스팅을 통한 실객체의 함수 호출을 가능케 한다는 의미이다. 부모의 함수와 자식의 함수가 공존하는 상태인 건 똑같다. 실제로, 가상 함수라고 해도 부모 타입을 명시적으로 써서 부모 함수에 접근하는 건 여전히 가능하다.
이게 어떻게 가능한 걸까?비밀은 가상 함수 테이블에 있다. 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해, 클래스 단위로 하나의 가상 함수 테이블을 만든다. 이 테이블은 클래스의 구조에 따라 고정된 형태로 컴파일 타임에 만들어진다.
가상 함수 테이블에는 오버라이딩 구조에 따라 현재 클래스의 타입을 통해 가상 함수를 호출했을 때 최종적으로 오버라이딩된 위치가 어디인지, 즉 클래스의 상속관계 안에서 어떤 클래스의 함수를 호출해야 하는지 기록되어 있다.가상 함수 테이블을 가진 클래스가 인스턴싱될 때, 객체는 자동적으로 '가상 함수 테이블 포인터(이하 vptr)' 멤버를 가지게 된다. 그리고 포인터를 통해 가상 함수를 호출하면 vptr가 가리키는 가상 함수 테이블의 함수 주소로 이동해 실제로 호출해야 하는 함수를 호출하게 된다.오버라이딩을 강제하는 가상 함수. virtual void Foo() = 0; 와 같이 '= 0' 키워드를 통해 선언한다. MSVC를 사용한다면 '= 0' 키워드는 MSVC가 추가한 'abstract' 키워드로 대체할 수 있다. 물론 C++ 표준이 아니므로 코드 호환성을 위해 '= 0'을 쓸 것을 권장한다.Note
순수 가상 함수는 오버라이딩을 강제하는 것이지 정의를 가지지 못 하는 게 아니다. 여전히 함수이며 정의가 있는 경우 부모 타입을 명시하여 호출하는 것도 가능하다. 물론 정의부가 없이 호출하면 찾을 수 없는 심볼 링크 에러가 발생한다.
하나 이상의 순수 가상 함수가 포함된 클래스를 추상 클래스(Abstract class)라고 부른다. 자식을 통해 구체화되어야 하는 추상 함수를 포함하는 클래스라는 뜻으로, 기본적으로 존재 자체가 상속될 것을 전제한다. 따라서 추상 클래스의 인스턴스를 만들 수는 없다.오로지 순수 가상 함수 멤버로만 이루어진 클래스는 특별히 인터페이스(Interface)라고 부른다. 말 그대로 어떠한 구현, 로직, 데이터도 가지지 않고 오직 서로 다른 객체 간의 소통을 위한 매개 레이어로만 쓰이는 클래스라고 할 수 있다.
C++ 이후의 언어들은 아예 인터페이스 클래스를 분리하고 예약어를 통해 명시적으로 선언하게 하기도 한다. 그러나 C++에선 별도의 키워드는 없다. (MSVC가 COM 프로그래밍에 쓰려고 추가한 __interface 키워드가 있긴 하지만, C++ 표준이 아니다.)C++1class Parent2{3public:4	virtual void Foo() = 05	{6 std::cout &lt;&lt; "순수 가상 함수 역시 함수이며 정의를 가질 수 있다.\n";7	}8};910class Child : public Parent11{12public:13	// C++11에서 오버라이드 함수임을 명시할 수 있는 override 키워드가 추가되었다.14	// 오버라이드 함수에만 붙일 수 있다. 그냥 사람이 오버라이드 함수임을 명확히 알 수 있도록 하는 데 쓰인다.15	virtual void Foo() override16	{17 std::cout &lt;&lt; "자식 클래스\n";18	}19};2021int main()22{23	Parent* ptr = new Child;24	ptr-&gt;Foo();25	ptr-&gt;Parent::Foo();26}C++]]></description><link>0-발행완료/c,-c++/문법/가상-함수-(virtual-function).html</link><guid isPermaLink="false">0 발행완료/C, C++/문법/가상 함수 (Virtual function).md</guid><pubDate>Tue, 23 Sep 2025 13:05:31 GMT</pubDate></item><item><title><![CDATA[STL sort()의 비교 함수가 같은 값일 때 false를 반환해야 하는 이유]]></title><description><![CDATA[STL 정렬 함수는 엄격한 약순서(Strict-Weak-Ordering) 비교를 만족하는 걸 전제로 작성되어 있기 때문.엄격한 약순서란 다음의 네 조건을 만족하는 비교이다.
반사 불가능성(Irreflexivity)
같은 값 간의 비교는 언제나 false여야 한다.
비대칭성 (Asymmetry)
Comp(A, B)가 true면, Comp(B, A)는 반드시 false여야 한다.
추이성, 일관성 (Transitivity)
Comp(A, B)가 true이고, Comp(B, C)가 true이면, Comp(A, C)도 반드시 true여야 한다.
등가성의 일관성(Transitivity of Equivalence)
!Comp(A, B)와 !Comp(B, A)가 모두 true라면, A와 B는 논리적으로 같다고 할 수 있다. 그렇다면, !Comp(A, C)와 !Comp(B, C)의 결과는 동일해야 한다.
복잡해보이지만 사실 2~4번은 일관된 비교를 위해선 당연한 말이고, 문제가 되는 건 1번이다.
STL sort는 1번 조건을 만족한다는 전제로 동작하는 퀵, 힙, 삽입정렬을 사용하므로 커스텀 비교 함수를 사용할 때도 이를 만족해야 한다.특히 퀵 정렬같은 경우엔 피벗을 정해놓고 요소들을 그 좌우로 옮겨가며 정렬을 수행하기 때문에, 같은 값 간의 비교에서 true가 나와버리면 요소가 계속 옮겨다니게 되면서 무한루프에 빠져버린다.]]></description><link>0-발행완료/c,-c++/기타/stl-sort()의-비교-함수가-같은-값일-때-false를-반환해야-하는-이유.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/STL sort()의 비교 함수가 같은 값일 때 false를 반환해야 하는 이유.md</guid><pubDate>Tue, 23 Sep 2025 13:05:27 GMT</pubDate></item><item><title><![CDATA[static_cast vs reinterpret_cast]]></title><description><![CDATA[static_cast는 타입에 안전하므로 캐스팅이 가능한지 체크하며, 그 과정에서 필요하다면 캐스팅 후 반환할 객체를 생성하거나 기존의 객체의 멤버들을 복사하는 등의 동작을 수행한다.
반면 reinterpret_cast는 단순히 전달된 객체를 특정 타입으로 해석할 뿐이므로 속도 면에서는 훨씬 빠르다.그러나 reinterpret_cast는 아주 특수한 상황에서만 사용할 것이 권장된다. 타입 안전성이 그만큼 중요하기 때문.
웬만한 객체의 캐스팅은 애초에 큰 비용이 들지 않는다. 캐스팅 비용이 매우 큰 거대한 객체라면, 애초에 캐스팅할 일을 만들지 않거나 자체적으로 다른 타입간의 연산을 계산해주는 것이 좋은 방법이다.]]></description><link>0-발행완료/c,-c++/기타/static_cast-vs-reinterpret_cast.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/static_cast vs reinterpret_cast.md</guid><pubDate>Tue, 23 Sep 2025 13:05:25 GMT</pubDate></item><item><title><![CDATA[멤버 초기화에서 소괄호 직접 초기화를 사용할 수 없는 이유]]></title><description><![CDATA[C++1class Foo2{3	int x(10); // 여기(멤버 초기화 문법)에선 데이터 멤버의 직접 초기화 불가능4	5	// 아래와 같이 값 복사 초기화나 유니폼 초기화, 또는 생성자에서 초기자 리스트나 생성자 내부 초기화를 사용해야 한다.6	int x = 10;7	int x { 10 };8	Foo() : x(10) {}9	Foo() { x = 10 }10}C++구문 해석 시 모호성(Ambiguous) 문제가 생기기 때문이다.
int x(10); 같은 구문은 함수의 선언으로 이해될 수 있기에 이를 구분하려면 구문 해석 비용이 너무 높아져버린다. 특히 C++11부터 변수를 최상단에서 선언하지 않아도 되도록 바뀌었다보니 구분이 더 어려워졌다. 그래서 아예 막아놓은 듯.]]></description><link>0-발행완료/c,-c++/기타/멤버-초기화에서-소괄호-직접-초기화를-사용할-수-없는-이유.html</link><guid isPermaLink="false">0 발행완료/C, C++/기타/멤버 초기화에서 소괄호 직접 초기화를 사용할 수 없는 이유.md</guid><pubDate>Tue, 23 Sep 2025 13:05:22 GMT</pubDate></item><item><title><![CDATA[WinAPI로 만드는 간단한 윈도우즈 스레드풀]]></title><description><![CDATA[C++1#include &lt;iostream&gt;2#include &lt;Windows.h&gt;3#include &lt;thread&gt;4#include &lt;vector&gt;5#include &lt;functional&gt;678struct MyThread9{10 std::thread t;11 HANDLE event_ready;12 HANDLE event_done;1314 MyThread(std::function&lt;void(HANDLE, HANDLE)&gt; func)15 {16 // 이벤트 커널 객체 생성17 event_ready = CreateEvent(nullptr, false, false, nullptr);18 event_done = CreateEvent(nullptr, false, false, nullptr);1920 // 스레드 생성21 t = std::thread(func, event_ready, event_done);22 }23};2425void 대충_스레드_함수(HANDLE event_ready, HANDLE event_done)26{27 // 스레드 진입점2829 // 무한 루프 진입30 while (true)31 {32 WaitForSingleObject(event_ready, INFINITE); // 스레드 대기상태로 전환 : event_ready 이벤트 발생시 깨어남333435 // 대충 필요한 동작36 //...37 //...38 //...394041 // 스레드의 현재 작업 완료42 SetEvent(event_done); // 메인 스레드에 현재 스레드의 작업이 완료되었음을 알림43 // 스레드는 다시 while문의 처음으로 돌아가 대기44 }45}464748void 대충_매프레임_호출되는_함수(std::vector&lt;MyThread*&gt; threads)49{50 // 스레드 깨우기51 for (auto t : threads)52 {53 SetEvent(t-&gt;event_ready);54 }5556 // 스레드들이 모두 완료될 때까지 대기57 for (auto t : threads)58 {59 WaitForSingleObject(t-&gt;event_done, INFINITE);60 }61}626364int main()65{66 std::vector&lt;MyThread*&gt; threads;67 threads.push_back(new MyThread(대충_스레드_함수));6869 대충_매프레임_호출되는_함수(threads);70}C++]]></description><link>0-발행완료/c,-c++/구현-예시/winapi로-만드는-간단한-윈도우즈-스레드풀.html</link><guid isPermaLink="false">0 발행완료/C, C++/구현 예시/WinAPI로 만드는 간단한 윈도우즈 스레드풀.md</guid><pubDate>Tue, 23 Sep 2025 13:05:20 GMT</pubDate></item><item><title><![CDATA[(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생]]></title><description><![CDATA[bReplicates 플래그가 켜진 자식 액터의 프로퍼티를 부모 액터의 BeginPlay에서 수정하려고 시도하자 댕글링 포인터 에러가 발생했다.자식 액터가 완전히 리플리케이트 되기 전에 부모 액터의 BeginPlay가 호출됐기 때문이다.리플리케이트는 부모 → 자식 순서로 일어나며, 클라이언트 입장에선 액터가 리플리케이트되어 레벨에 배치되는 순간 BeginPlay를 호출한다. 따라서 자식의 리플리케이트가 완료되기 전에 일어날 수 있다.애초에 부모가 초기화될 때 자식의 초기화를 시도하는 것 자체가 나쁜 설계다. 부모 → 자식 순서는 보장되기 때문에 자식이 Owner에 접근해서 스스로 처리하는게 좋다.물론 부모-자식 관계가 아니라 별개의 두 액터라면 뭐가 먼저 리플리케이트될 지 알 수 없으므로 금물.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0806)-클라이언트에서-자식-uobject에-접근할-때-nullptr참조-발생.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 클라이언트에서 자식 UObject에 접근할 때 nullptr참조 발생.md</guid><pubDate>Tue, 23 Sep 2025 13:05:14 GMT</pubDate></item><item><title><![CDATA[(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제]]></title><description><![CDATA[비네트 매니저는 로컬 플레이어의 카메라를 따라다니는 방식으로 작동한다. 이 때 플레이어가 움직이면 한 타이밍 늦게 따라오는 것처럼 이격이 발생하는 문제가 발생했다.비네트 매니저 액터의 Tick 업데이트가 카메라 업데이트보다 빨라서 발생하는 문제다.언리얼은 TickGroup을 두고 해당 단위로 순차적인 Tick 업데이트를 진행한다. 이 때 카메라는 부드러운 화면 전환을 위해 항상 가장 마지막에 업데이트되도록 되어있다.따라서 플레이어의 이동과 비네트 매니저의 이동 → 카메라가 이동하는 순서를 가지게 되기 때문에, 비네트 매니저가 항상 최소한 한 프레임 이전의 카메라의 위치를 따라가게 되는 것이다. (최소 한 프레임인 이유는 플레이어의 이동이 나중에 일어날 수도 있기 때문)이런 경우를 위해 언리얼이 이미 Tick Group을 편집할 수 있게 해두었다. Details - Actor Tick - Tick Group 설정을 Post Update Work로 변경하면 카메라의 업데이트 이후에 업데이트된다.<img alt="♣VaultStorage/attachment/Pasted image 20250916150659.png" src="♣vaultstorage/attachment/pasted-image-20250916150659.png" target="_self">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0806)-카메라를-따라가는-비네트-쿼드가-렉이-걸린-것처럼-뒤늦게-따라오는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0806) 카메라를 따라가는 비네트 쿼드가 렉이 걸린 것처럼 뒤늦게 따라오는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:05:12 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible' 경고가 뜨는 문제]]></title><description><![CDATA[플레이어가 몹에 맞아 날아갔다가 다시 일어나는 동작을 구현하면서 발생.래그돌 상태에서 다시 원래 상태(’CharacterMesh’ ProfileName)로 되돌아갈 때 Body is set to stimulate physics but Collision Enabled is incompatible 경고가 떴다.SetSimulatePhysics를 호출하는 것과 SetCollisionEnabled 를 호출하는 코드가 같은 곳에 있었는데도.추측이지만 언리얼에서 한 쪽을 바꾸는 함수가 호출되면 즉시 다른 쪽 상태를 체크하는 것으로 보인다. 그래서 실제로는 같은 곳에서 변경되어 아무 문제가 없어도 일단 경고를 띄우고 보는 듯.다음과 같이 순서를 바꾸니까 경고가 안 뜬다.C++1// CharacterMesh -&gt; Ragdoll2thirdPersonMesh-&gt;SetCollisionProfileName(TEXT("Ragdoll"));3thirdPersonMesh-&gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);4thirdPersonMesh-&gt;SetAllBodiesSimulatePhysics(true);5thirdPersonMesh-&gt;SetSimulatePhysics(true);67// Ragdoll -&gt; CharacterMesh // 여기서 SimulatePhysics랑 CollisionEnabled 순서 바꾸니까 경고 안 뜬다.8thirdPersonMesh-&gt;SetAllBodiesSimulatePhysics(false);9thirdPersonMesh-&gt;SetSimulatePhysics(false);10thirdPersonMesh-&gt;SetCollisionProfileName(TEXT("CharacterMesh"));11thirdPersonMesh-&gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly);C++]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0805)-플레이어가-래그돌이-됐다가-복구될-때-‘body-is-set-to-stimulate-physics-but-collision-enabled-is-incompatible&apos;-경고가-뜨는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 플레이어가 래그돌이 됐다가 복구될 때 ‘Body is set to stimulate physics but Collision Enabled is incompatible&apos; 경고가 뜨는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:05:10 GMT</pubDate></item><item><title><![CDATA[(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250916150543.png" src="♣vaultstorage/attachment/pasted-image-20250916150543.png" target="_self" style="width: 250px; max-width: 100%;">분명 크기를 맞췄음에도 터미널 메쉬에 일부가 잘린 채로 그려졌다.메쉬의 UV 자체가 저 부분만 사용해서 그렇다. 메쉬 에셋 우클릭 → UV Editor를 눌러 확인해보자.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916150549.png" src="♣vaultstorage/attachment/pasted-image-20250916150549.png" target="_self" style="width: 225px; max-width: 100%;">가로 세로가 0~1 사이의 UV 좌표를 꽉 채우도록 늘려주면 잘 그려진다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916150557.png" src="♣vaultstorage/attachment/pasted-image-20250916150557.png" target="_self" style="width: 300px; max-width: 100%;"> <img alt="♣VaultStorage/attachment/Pasted image 20250916150609.png" src="♣vaultstorage/attachment/pasted-image-20250916150609.png" target="_self" style="width: 225px; max-width: 100%;">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0805)-메쉬의-머터리얼로-위젯-렌더-타겟을-입혔는데-일부가-잘리는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0805) 메쉬의 머터리얼로 위젯 렌더 타겟을 입혔는데 일부가 잘리는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:05:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(0801) 프로젝트와 언리얼 엔진 연동 실패 문제]]></title><description><![CDATA[언리얼 버전 셀렉터가 프로젝트 경로를 자동으로 잡지 못 하면 uproject 파일에 Generate Visual Studio project files 옵션도 안 뜨고, VS를 열었을 때 엔진 소스들도 로드가 안 된다.주로 언리얼 런처든 엔진이든 기본 경로에 설치하지 않아서 그렇다. 높은 확률로 엔진은 C, 런처는 D에 깔려있을 것이다.이럴 땐 그냥 수동으로 경로를 추가해주면 된다. 런처가 있는 경로(Epic Games/Launcher/Engine/Binaries/Win64)로 이동해 UnrealVersionSelector.exe 파일을 복사한 뒤,엔진이 설치된 경로(Epic Games/UE_XX)에 넣고 관리자 권한으로 실행하면 알아서 레지스트리에 해당 경로가 등록되며, 이제 해당 버전의 엔진을 사용하는 프로젝트를 다룰 때 버전 셀렉터가 해당 엔진 버전의 경로에 접근할 수 있게 된다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0801)-프로젝트와-언리얼-엔진-연동-실패-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0801) 프로젝트와 언리얼 엔진 연동 실패 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:05:06 GMT</pubDate></item><item><title><![CDATA[(0731) DX12 GroomComponent 렌더링 문제]]></title><description><![CDATA[언리얼 5.5 프로젝트를 언리얼 5.6으로 업그레이드 한 후, 클라이언트가 접속할 때 GPU Crashed or D3D Device Removed 에러가 발생했다.C++1D3D12: Removing Device.2[2025.07.31-00.59.04:580][905]LogD3D12RHI: Error: GPU crash detected:3	- Device 0 Removed: DXGI_ERROR_DEVICE_HUNG45[2025.07.31-00.59.04:581][905]LogRHI: Error: Active GPU breadcrumbs:67	Device 0, Pipeline Graphics: (In: 0x8012df72, Out: 0x8012de7e)8	(중략...)9 (ID: 0x8012e200) [Not Started] RenderGraphExecute - BP_CaptureTarget0 (ChildActor_GEN_VARIABLE_BP_CaptureTarget_C_CAT_0)10 (ID: 0x8012e0af) [Not Started] Scene11 (ID: 0x8012e0ba) [Not Started] HairCardsInterpolation12 (ID: 0x8012e0d1) [Not Started] HairCardsInterpolation1314[2025.07.31-00.59.04:582][905]LogD3D12RHI: Error: Shader diagnostic messages and asserts:1516Decoding Aftermath GPU Crash:1718	Device Info:19 Status : Timeout20 Adapter Reset: False21 Engine Reset : TrueC++DX12 렌더링 스레드와 메타휴먼의 GroomComponent 간의 충돌로 보인다.로그를 해석해보면, 대강 BP_CaptureTarget0에 그리려는 MetaHuman의 HairCards에서 GPU가 무한루프에 빠져 Timeout이 걸렸다는 걸로 볼 수 있다.언리얼 5.6에서 레이트레이싱 최적화와 함께 메타휴먼과 관련한 대규모의 업데이트가 있었다보니, Groom컴포넌트의 렌더링 메서드가 변한 걸까?로그를 통해 DX12 레이트레이싱과 충돌이 난 것으로 파악하고 다음과 같은 시도들을 해보았다.
Project Settings에서 하드웨어 레이트레이싱을 끄거나, 캡쳐 타겟으로 GroomComponent를 캡쳐하지 않으면 문제가 발생하지 않는다.
Groom 및 GroomBinding 에셋들을 Rebuild, Reload 해도 해결되지 않는 걸 보면 5.6으로 올라가며 에셋이 변한 건 아니다.
이런저런 시도들을 해보던 중 SceneCaptureComponent2D에 Use Ray Tracing If Enabled 플래그가 있는 걸 발견했다. 이걸 켜주니까 이제 된다!정확한 원인은 아직도 모르겠고, 검색해도 나오지 않지만, 내 생각엔 5.6 업데이트를 하면서 레이트레이싱과 GroomComponent 렌더링을 뭘 건드렸는데, GroomComponent는 레이트레이싱을 받아 그려지는데 이걸 SceneCaptureComponent가 캡쳐할 땐 레이트레이싱을 사용하지 않게 되어있으면 충돌이 나는 버그가 생긴 모양이다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0731)-dx12-groomcomponent-렌더링-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0731) DX12 GroomComponent 렌더링 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:05:04 GMT</pubDate></item><item><title><![CDATA[(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상]]></title><description><![CDATA[서버와 클라이언트가 함께 던전에 진입하여 레벨 스트리밍으로 레벨들이 로딩된 상태에서 서버가 ServerTravel()로 먼저 레벨을 이동할 경우, 클라이언트에 스트리밍된 레벨들의 WorldSettings가 nullptr로 비워져, 레벨 리소스를 정리하는 과정에서 ALevel::GetWorldSettings() 함수로 가져올 때 checkf에 걸린다.정확한 원인은 아직도 파악하지 못 했다. 아무리 찾아봐도 나오지 않는다. 애초에 ULevelStreamingDynamic 객체를 쓰는 사람조차 보기가 힘들다.아무튼 이 문제는 ULevelStreaming과 ULevelStreamingDynamic의 근본적인 작동 방식의 차이 (및 언리얼의 불충분한 지원) 때문인 것으로 보인다.레벨 스트리밍은 두 가지 방식으로 나뉜다. 하나는 정적으로 이미 레벨 레이어가 등록되어있는 스트리밍 서브레벨을 LoadStreamLevel을 통해 단순히 ‘켜는’ 것이고, 다른 하나가 우리가 사용한 ULevelStreamingDynamic::LoadLevelInstance를 통해 동적으로 스트리밍 서브 레벨을 등록하고 내부의 액터들을 실시간으로 로드해내는 방식이다.절차적 던전 생성같은 이상한 짓만 하지 않는다면 애초에 후자는 필요가 없다. 그렇다보니 언리얼의 지원이 미흡한 게 문제의 원인이 아닌가 싶다.일단 전자의 레벨 스트리밍은 서버가 먼저 나가던 말던 아무 상관 없다. 이게 정확히 서브레벨이 이미 메인 퍼시스턴트 레벨에 통합이 되어있어서인지, 아니면 내부적으로 처리를 하는 것인지는 모르겠다.반면 후자의 레벨 스트리밍은 직접 레벨 리소스들을 해제하지 않으면 이런 문제가 발생한다.문제는 Travel은 항상 서버와 클라이언트에서 동시에 일어나기 때문에 지연을 둬서 이게 (1) 서버에서 레벨 스트리밍 객체가 제거되고, 이것이 전파되어 클라이언트의 레벨 스트리밍 정보가 사라져서 생기는 문제인지, (2) 아니면 그냥 클라이언트상에 ULevelStreamingDynamic이 남아있는 상태에서 레벨 이동을 시도하면 그 과정에서 순서가 꼬여서 이런 문제가 발생하는 건지 모르겠다.ULevelStreamingDynamic::SetIsRequestingUnloadAndRemoval(true) 를 통해 수동으로 ULevelStreamingDynamic이 관리하는 레벨 리소스들을 해제해주면 해당 레벨에 대해선 문제가 발생하지 않는다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0730)-스트리밍된-레벨이-있을-때-서버가-먼저-travel을-하면-클라이언트에서-worldsettings가-nullptr로-바뀌는-현상.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0730) 스트리밍된 레벨이 있을 때 서버가 먼저 Travel을 하면 클라이언트에서 WorldSettings가 nullptr로 바뀌는 현상.md</guid><pubDate>Tue, 23 Sep 2025 13:05:01 GMT</pubDate></item><item><title><![CDATA[(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터]]></title><description><![CDATA[플레이어가 메고 있는 백팩에 시야(Sweep으로 표현)가 닿았을 때 열 수 있어야 하는데, 희안하게도 단일 감지 함수일 땐 감지가 안 되고 다중 감지 함수일 때만 감지가 됐다.백팩 액터의 콜라이더의 Collision Response가 Overlap으로 되어있었다.기본적으로 단일 감지 씬쿼리는 Overlap은 무시하고 지나가다 최초로 만나는 Block Response를 반환하고, 다중 감지 씬쿼리는 Overlap은 배열에 쌓다가 최초로 Block Response를 만나면 배열에 추가해서 반환하는 방식으로 동작한다.따라서 SweepSingle은 무시되고 SweepMulti는 첫 번째로 백팩을 담기는 했던 것.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0721)-tracesingle론-안-되고-tracemult로만-감지되는-액터.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0721) TraceSingle론 안 되고 TraceMult로만 감지되는 액터.md</guid><pubDate>Tue, 23 Sep 2025 13:04:59 GMT</pubDate></item><item><title><![CDATA[(0707) ‘GEngine not initialized!’ 패키징 에러]]></title><description><![CDATA[(로그 내용)C++1UATHelper: 패키징 (Windows): LogPhysics: Error: FBodyInstance::GetSimplePhysicalMaterial : GEngine not initialized! Cannot call this during native CDO construction, wrap with if(!HasAnyFlags(RF_ClassDefaultObject)) or move out of constructor, material parameters will not be correct.2PackagingResults: Error: FBodyInstance::GetSimplePhysicalMaterial : GEngine not initialized! Cannot call this during native CDO construction, wrap with if(!HasAnyFlags(RF_ClassDefaultObject)) or move out of constructor, material parameters will not be correct.C++로그 내용을 보면 알겠지만 GEngine(언리얼 엔진 전역 객체)이 초기화되지 않은 상태(CDO를 초기화하는 단계)에서 SetSimulatedPhysics() 나 SetMassOverrideInKg() 같은 언리얼 물리 엔진 함수를 호출했다는 뜻이다.정확한 이유는 검색해봐도 안 나와서 모르겠다. 아마 GEngine 객체가 초기화될 때 물리 엔진도 같이 초기화되는데, 그 전에 물리엔진에 접근하는 함수는 호출할 수 없나보다.에디터로 열 때는 되는 이유는 에디터를 로딩하는 과정이 패키징된 실행파일을 열 때와 다르게 GEngine 초기화 → CDO 구성 순이기 때문으로 보인다.로그에서 시키는 대로 if(!HasAnyFlags(RF_ClassDefaultObject)) 문으로 감싸거나, 해당 함수를 호출하는 위치를 CDO 밖으로(PostInitializeComponents 나 BeginPlay) 빼면 된다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0707)-‘gengine-not-initialized!’-패키징-에러.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0707) ‘GEngine not initialized!’ 패키징 에러.md</guid><pubDate>Tue, 23 Sep 2025 13:04:57 GMT</pubDate></item><item><title><![CDATA[(0630) 블루프린트로 추가된 컴포넌트를 소스코드에서 GetComponent로 가져올 수 없는 문제]]></title><description><![CDATA[당연하다. 블루프린트에서 추가된 컴포넌트는 소스코드가 일단 빌드된 후에 구성되기 때문이다.그러나 접근 자체를 블루프린트에서 추가한 컴포넌트가 구성된 뒤에 동적으로 하면 되기 때문에 접근할 방법이 없는 건 아니다. (물론, 권장되는 방법은 아닌 듯 하다.)BP에서 작업한 내용은 USimpleConstructionScript 에서 관리한다. 여기서 BP 노드들을 순회하며 이름으로 탐색해야 한다.다음은 블루프린트로 구성된 메타휴먼 캐릭터 BP가 주어질 때 블루프린트 노드를 순회하며 이름이 같은 컴포넌트를 찾는 예시다.C++1#include "Engine/SCS_Node.h" // SCS_Node를 사용하기 위해 헤더 추가2#include "Engine/SimpleConstructionScript.h" // SimpleConstructionScript를 사용하기 위해 헤더 추가34UBlueprintGeneratedClass* BPClass = Cast&lt;UBlueprintGeneratedClass&gt;(MetahumanActor);5if (USimpleConstructionScript* SCS = BPClass-&gt;SimpleConstructionScript)6{7	for (USCS_Node* Node : SCS-&gt;GetAllNodes())8	{9 if (Node &amp;&amp; Node-&gt;ComponentTemplate)10 {11 USkeletalMeshComponent* SKMComponentTemplate = Cast&lt;USkeletalMeshComponent&gt;(Node-&gt;ComponentTemplate);12 if (SKMComponentTemplate)13 {14 FString name = SKMComponentTemplate-&gt;GetName();15 if (name == TEXT("Body") || name == TEXT("Body_GEN_VARIABLE"))16 {17 ThirdPersonMesh-&gt;SetSkeletalMesh(SKMComponentTemplate-&gt;GetSkeletalMeshAsset());18 }19 else if (name == TEXT("Face") || name == TEXT("Face_GEN_VARIABLE"))20 {21 FaceMesh-&gt;SetSkeletalMesh(SKMComponentTemplate-&gt;GetSkeletalMeshAsset());22 }23 else if (name == TEXT("Torso") || name == TEXT("Torso_GEN_VARIABLE"))24 {25 TorsoMesh-&gt;SetSkeletalMesh(SKMComponentTemplate-&gt;GetSkeletalMeshAsset());26 }27 else if (name == TEXT("Legs") || name == TEXT("Legs_GEN_VARIABLE"))28 {29 LegsMesh-&gt;SetSkeletalMesh(SKMComponentTemplate-&gt;GetSkeletalMeshAsset());30 }31 else if (name == TEXT("Feet") || name == TEXT("Feet_GEN_VARIABLE"))32 {33 FeetMesh-&gt;SetSkeletalMesh(SKMComponentTemplate-&gt;GetSkeletalMeshAsset());34 }35 }36 }37	}38}C++]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-블루프린트로-추가된-컴포넌트를-소스코드에서-getcomponent로-가져올-수-없는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 블루프린트로 추가된 컴포넌트를 소스코드에서 GetComponent로 가져올 수 없는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:55 GMT</pubDate></item><item><title><![CDATA[(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제]]></title><description><![CDATA[메타휴먼 BP를 넣으면 해당 BP의 스켈레탈 메쉬 컴포넌트들을 찾아 순회하며 스켈레탈 메쉬 에셋을 끼우는 방식으로 캐릭터를 구성하는데, 메타휴먼을 이루는 파츠 스켈레탈 메쉬들(Face, Torso, Legs, Feet 등) 중 Legs 파츠만 Body 스켈레탈 메쉬의 애니메이션을 따라가지 않고 따로 노는 문제가 발생했다.결론부터 말해 바디 메쉬가 Legs 메쉬의 LeaderPose로 설정되어 있지 않았기 때문이었다. 근데 그 이유는 모른다. 기본적으로 어떤 스켈레탈 메쉬 컴포넌트의 자식 스켈레탈 메쉬 컴포넌트들은 자동으로 부모 스켈레탈 메쉬를 LeaderPose로 설정하는데, 이것만 안 되는 이유는 도저히 모르겠다. 아마도 버그?해당 스켈레탈 메쉬 컴포넌트에 SetLeaderPoseComponent를 수동으로 호출해주었다.Face 스켈레탈 메쉬의 경우 바디 포즈를 리더 포즈로 설정한 경우 바디 스켈레탈 메쉬와 이름이 같은 목 본을 기준으로 움직인다. 그러나 페이셜 애니메이션을 입히기 위해선 페이스 스켈레톤을 사용하는 페이스 스켈레탈 메쉬에 다른 애님 인스턴스를 입혀야 한다.이 때는 LeaderPose 설정을 해제하고(말한 대로, 자식이라면 기본이 설정이 된 상태이므로 수동으로 해제해줘야 한다.) 애님 그래프에서 Copy pose 노드로 바디 포즈를 카피해서 블렌딩해야 한다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-메타휴먼의-특정-파츠만-바디-애니메이션을-상속하지-않는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼의 특정 파츠만 바디 애니메이션을 상속하지 않는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:53 GMT</pubDate></item><item><title><![CDATA[(0630) 메타휴먼 LOD 버그]]></title><description><![CDATA[메타휴먼 파츠 갈아끼우기를 구현하던 중 위와 같이 일부 파츠의 일부 본들이 애니메이션을 따라 이동하지 않는 문제가 발생했다. InitAnim(true) , MarkRenderStateDirty() , RecreatePhysicsState() RecreateRenderState_Concurrent() 등 뭘 호출해봐도 해결되지 않았다.유일한 단서는 캐릭터가 카메라로부터 충분히 가깝거나 멀 때는 괜찮다가 특정한 거리 구간 안에서만 저런다는 것. 거리를 기준으로 변하는 문제이므로 LOD 쪽을 살펴봤다.결론만 말해 원인은 LODSync 컴포넌트였다. 본래 메타휴먼의 LOD 메쉬 간에 부드러운 Transition을 만들어주는 역할이라는데, 이유는 모르겠으나 캐릭터의 기본 메쉬(Character::Mesh)를 Components to Sync에 추가하면 특정 메쉬의 특정 LOD 구간에 한정해 저런 버그를 만들어낸다.기본 메타휴먼 BP에서는 Body 라는 이름의 스켈레탈 메쉬가 최상위 부모가 되기 때문에 LODSync 컴포넌트에도 Body라는 이름으로 등록되어 있다. 그런데 캐릭터로 사용하는 과정에서 ACharacter의 기본 메쉬 이름을 사용했더니 이런 문제가 발생하는 건가 싶다. 아무튼 원인은 아직 못 찾았다.<img alt="♣VaultStorage/attachment/image.png" src="♣vaultstorage/attachment/image.png" target="_self">바디 스켈레탈 메쉬의 LOD Sync 옵션을 끄면 된다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0630)-메타휴먼-lod-버그.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0630) 메타휴먼 LOD 버그.md</guid><pubDate>Tue, 23 Sep 2025 13:04:49 GMT</pubDate><enclosure url="♣vaultstorage/attachment/image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;♣vaultstorage/attachment/image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제]]></title><description><![CDATA[공격 애니메이션 시퀀스의 챠징 포즈를 캡쳐하려고 CreateAsset -&gt; Create Animation -&gt; Current Pose 로 해당 포즈로부터 시퀀스를 생성했는데, 열어보니까 상체는 작아지고 하체는 커진 이상한 모양으로 보였다.애니메이션 시퀀스에는 각 본들의 트랜스폼 정보들이 저장되어 있다. 이 때 중요한 건 이 트랜스폼들은 각각의 스켈레탈 메쉬들이 가진 Bind Pose(기본 자세)를 기반으로 연산이 된다는 것이다.예컨대, 같은 시퀀스라도 여성 체형의 스켈레탈 메쉬에 입히느냐, 남성 체형의 스켈레탈 메쉬에 입히느냐에 따라 움직이는 골격 자체가 달라지게 된다.즉, 이런 문제가 발생했던 건 우리 게임에서 사용하던 Quinn 스켈레탈 메쉬가 Retarget Source(어떤 Bind Pose를 기준으로 미리보기를 보여줄 것인가)에서 빠져있어서, 시퀀스에 든 본 트랜스폼 정보가 그대로 출력되었기 때문이었다.사실 미리보기만 달라지는 거지 실제로 입혀질 땐 어디까지나 스켈레탈 메쉬 기준으로 입혀지기에 문제가 있는 것도 아니었다. 어쨌든 Retarget Source에 원하는 바인드 포즈를 가진 스켈레탈 메쉬를 넣으면 된다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0627)-애니메이션-시퀀스의-특정-포즈에-대한-애님-시퀀스를-만들었더니-스켈레탈-메쉬의-모양이-이상해지는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0627) 애니메이션 시퀀스의 특정 포즈에 대한 애님 시퀀스를 만들었더니 스켈레탈 메쉬의 모양이 이상해지는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:47 GMT</pubDate></item><item><title><![CDATA[(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제]]></title><description><![CDATA[아이템의 메쉬 에셋의 경로를 TSoftObjectPtr로 들고있다가 플레이어가 해당 아이템을 손에 들면 서버, 클라에서 각각 비동기로 메쉬 에셋을 로드해서 갈아끼운다.그런데 이 때 해당 메쉬 컴포넌트의 Component Replicates 플래그를 켜두니 서버와 클라의 메쉬 GUID가 다르다는 ensure에 걸렸다.이 역시 정확한 원인을 파악한 건 아니지만, 추론하자면 다음과 같다.
서버와 클라는 같은 메쉬 에셋을 사용했으므로 동일한 것으로 간주는 한다.
문제는 언리얼의 리플리케이트는 단순히 같은 경로인 같은 에셋이냐만 따지지 않고, 메모리에 로드된 UObject 인스턴스의 주소와 네트워크를 통해 전달된 NetGUID를 통해 상호체크를 하는 과정을 거친다.
동일한 에셋이긴 하지만 서버와 클라가 각각 비동기로 메모리에 로드했기 때문에, 두 UObject 인스턴스의 주소는 다르고, 서로 다른 NetID를 배정받는다.
서버에서 메쉬를 로드하고 이를 클라이언트로 전파하려고 시도했는데, 이미 해당 위치를 NetID가 다른 UObject가 차지하고 있으므로, 서로 다른 ID 경고가 발생한다.
두 가지가 있다. 서버에서 먼저 로드하여 단일 NetID를 부여받은 뒤 이를 리플리케이트하는 것과, 그냥 리플리케이트를 끄고 각자 로드하게 하는 것이다.당연히 후자가 낫다. 전자는 클라라는 이유로 서버보다 느리게 로드되기 때문.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0626)-tsoftobjectptr로-서버와-클라가-각각-비동기로-에셋을-로드할-때,-리플리케이트-과정에서-guid-불일치-경고에-걸리는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0626) TSoftObjectPtr로 서버와 클라가 각각 비동기로 에셋을 로드할 때, 리플리케이트 과정에서 GUID 불일치 경고에 걸리는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:45 GMT</pubDate></item><item><title><![CDATA[(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제]]></title><description><![CDATA[절차적으로 던전을 생성할 때, 룸 내부에 움직이는 액터가 있으면 NavSys의 OnNavigationGenerationFinishedDelegate가 브로드캐스트 되지 않았다.실제로 Finish 이벤트가 발생하지 않았기 때문이다. 움직이는 액터 때문에 NavMesh가 계속 재생성되고 있던것.두 가지 방법이 있다.
NavMesh를 수동으로 빌드한다. 처음에 BuildingLock을 걸어놓고, 모든 던전 구성이 끝난 시점에 한 번만 수동으로 빌드 명령을 내리는 것이다.
그냥 움직이는 액터를 빼던가 Can ever affect nav mesh 옵션을 끈다.
]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0617)-동적-스트리밍되는-룸-레벨-안에-움직이는-액터가-있을-때-onnavigationgenerationfinisheddelegate-이벤트가-발생하지-않는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0617) 동적 스트리밍되는 룸 레벨 안에 움직이는 액터가 있을 때 OnNavigationGenerationFinishedDelegate 이벤트가 발생하지 않는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:43 GMT</pubDate></item><item><title><![CDATA[(0616) 위젯 델리게이트 중복 등록 문제]]></title><description><![CDATA[위젯의 NativeConstruct()에서 OnClicked 델리게이트에 함수를 등록했는데, 게임을 실행하니 델리게이트 중복 등록 에러가 발생했다.델리게이트 함수 바인딩을 NativeConstruct에서 수행하고, SetWidget을 매 틱마다 호출해 NativeConstruct가 매 틱마다 호출되고 있었기 때문이다. NativeConstruct는 위젯의 초기 상태를 구성하는 함수이므로 SetWidget으로 갈아끼울 때 호출되었던 것.SetWidget을 매 틱마다 호출한 이유는 미니맵이 그래야만 그려졌기 때문인데, 이건 다이나믹 머터리얼 인스턴스에 그려질 목적으로 추가해둔 Widget Component의 스케일을 0으로 설정해 언리얼이 ‘그리지 않아도 되는 놈’으로 판단하고 틱을 안 돌렸기 때문이었다.SetWidget을 매 틱마다 호출하는 코드를 지우고 WidgetComponent의 Tick when Offscreen 옵션을 켜 강제로 틱을 돌려주면 된다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0616)-위젯-델리게이트-중복-등록-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0616) 위젯 델리게이트 중복 등록 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:42 GMT</pubDate></item><item><title><![CDATA[(0605) 포인트 라이트가 벽을 뚫고 나가는 문제]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250916150940.png" src="♣vaultstorage/attachment/pasted-image-20250916150940.png" target="_self" style="width: 350px; max-width: 100%;">언리얼은 기본적으로 다이나믹 쉐도우맵(+ 레이트레이싱 루멘)을 사용해 동적으로 빛의 차폐를 구현하는데, 동적으로 생성된 룸에 배치된 포인트 라이트가 벽을 뚫고 넘어가 옆 방에 빛을 비추는 문제가 발생했다.여러 가지 실험을 해본 결과 원인은 Source Radius였다. 빛이 발하는 광원의 반경 자체를 조절하는 값인데, Source Radius가 너무 커서 벽 너머로 침범했고, 언리얼 셰이더가 해당 반경을 기준으로 빛을 퍼트리기 때문에 반대편에도 빛이 비췄던 것.Source Radius를 벽 안쪽에만 오게 조절하면 된다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0605)-포인트-라이트가-벽을-뚫고-나가는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0605) 포인트 라이트가 벽을 뚫고 나가는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제]]></title><description><![CDATA[던전이 생성된 후 플레이어 폰을 스폰할 수 없는 상황이라 모든 행동을 막아놓고 MovementMode는 None으로 바꾼 뒤, 던전이 생성된 후 다시 MovementMode를 Walking으로 전환했다.이후 서버와 클라이언트에서 플레이어의 움직임이 어긋나고 MovementComponent 동기화에 실패했을 때 계속 복구를 가하는 특유의 끊김이 발생했다.로그에선 MovementComponent의 보간 예측이 매 프레임 어긋나며 계속 전송 패킷 한계(4096비트)를 초과하여 움직임이 무시되고 있었다.우선 플레이어의 현재 MovementMode를 확인한 결과, 서버는 Walking인데 클라이언트는 Falling이었다. 바닥 액터 정보를 찾지 못 해 계속 떨어지는 상태였다.C++1LogNetPackageMap: Warning: UPackageMapClient::InternalLoadObject: Unable to resolve default guid from client: ObjectName: /Game/Resources/RoomPreset/RoomData/Temple_StartRoom_01_AC1FB80B49400255F9129FA2876CAACD_17706_0, ObjOuter: NULL C++바닥 액터를 찾지 못 한 이유는 서버의 바닥 액터와 클라이언트의 바닥 액터의 GUID가 달랐기 때문으로 보인다.클라이언트에서 ObjOuter가 nullptr가 나온다는 건 해당 액터가 속해있어야 하는 ULevel 객체가 없다는 소리로, 레벨이 정상적으로 스트리밍되지 못 하고 액터만 리플리케이트된 것으로 보인다.언리얼의 레벨 스트리밍 방식이 이렇다고 한다.서버에서 레벨 스트리밍 요청 → 클라이언트로 스트리밍 명령 전달 → 클라이언트에서 ULevelStreaming 객체 생성 → 비동기적으로 로딩 시작.이 과정에서 스트리밍되는 레벨 내에 있는 리플리케이트되는 액터들은 큐에 담겨있다가 레벨 로딩이 끝난 뒤에 연결된다고 한다.해결법은 간단했는데, 그냥 레벨 스트리밍을 수행하는 제너레이터 액터를 동적으로 스폰하는 대신 레벨에 미리 배치해두니까 됐다. 이유를 추론해보자면 아래와 같다.
제너레이터 액터가 동적으로 서버에 스폰된 후 즉시 레벨 스트리밍을 시도한다 → 클라이언트 입장에선 제너레이터 액터(레벨 스트리밍의 주체)가 미처 리플리케이트 되기 전에 레벨 스트리밍 명령을 받아 꼬이거나, 주체가 없어 명령이 무시된다. → 스트리밍될 레벨 내부의 액터들이 클라이언트로 리플리케이트된다. 이 때, 레벨 스트리밍에 의해 생성된 것이 아니라 자체적인 리플리케이트로 만들어지기에 서로 다른 액터로 취급(다른 GUID)된다.
혹은, 단순히 클라이언트에서도 레벨 스트리밍을 시작했는데 스트리밍 주체인 제너레이터 액터가 완전히 복제되지 못 한 상태라 스트리밍된 레벨 내부의 액터들이 적절한 컨텍스트 또는 상위객체를 찾는데 실패했을 수도 있다.
]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0603)-dynamic-level-streaming으로-로드된-액터의-guid가-어긋나는-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0603) Dynamic Level Streaming으로 로드된 액터의 GUID가 어긋나는 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:04:38 GMT</pubDate></item><item><title><![CDATA[(0) 주요 언리얼 빌드 에러별 대처 방안]]></title><description><![CDATA[MSB3073은 단순히 외부 명령어 수행에 실패했다는 뜻. Output창에서 오류 내용을 확인하자. 언리얼에선 보통 경로에 한글이 포함되었거나 경로가 너무 길어서 발생하곤 한다.혹은 다른 언리얼 에디터가 열려있고 Hot Reload가 켜져있으면 발생하기도 하는데, 이 때는 에러 내용이 약간 다르다.(0416) 언리얼 샘플 프로젝트를 빌드할 때 해당 오류가 발생. Output 창에선 12&gt; Resource ActionRPG.rc: Exited with error code 1 . The build will fail. 라고 윈도우즈 리소스 파일을 읽는 부분에서 에러가 났다고 되어있었다. 확인해보니 IDICON_UE4Game ICON "../../../../Build/Windows/Application.ico" 라인에서 상대경로가 달라 아이콘 리소스를 못 읽어서 발생…(07-31) 또 발생. Output 창에선 2&gt;Unhandled exception: IOException: The process cannot access the file because it is being used by another process. 라며 모 프로세스가 파일을 읽으려고 점유하고 있다고 한다. 그냥 재부팅하니까 해결됐다. TortoiseSVN이나 누가 백그라운드에서 읽고있었던 듯.다양한 이유로 발생하는 에러지만, 언리얼에선 주로 소스 파일에서 언리얼 리플렉션 매크로를 사용해놓고 generated.h 헤더를 마지막에 포함하지 않아서 발생한다.이런 류의 경고들은 모두 CDO에서 CDO 밖에서 사용해야 하는 함수를 사용해서 그렇다. 대표적인 것이 SetReplicates() 함수로, 리플리케이트 설정을 바꾸고 MarkDirty를 수행하는 함수라 CDO에선 관련 동작이 무시된다. 대신 bReplicates = true 처럼 플래그를 직접 켜주는 것이 좋다.블루프린트에서 nullptr 참조가 발생했을 때 뜨는 에러. 내 경우엔 레벨에 배치된 AManagerActor들을 찾아 레지스트리에 등록해놓고 전역함수로 반환해주는 서브시스템을 만들었는데, 매니저를 레벨에 배치하지 않고 가져오려고 시도해서 발생했다.주로 같은 프로젝트의 에디터가 두 개 열려있어서 서로 에셋에 접근하려 시도할 때 발생한다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-주요-언리얼-빌드-에러별-대처-방안.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 주요 언리얼 빌드 에러별 대처 방안.md</guid><pubDate>Tue, 23 Sep 2025 13:04:36 GMT</pubDate></item><item><title><![CDATA[(0) 사소한 문제 해결 사례 - 외부 플러그인]]></title><description><![CDATA[검색해보니 5.6에서 기존 스팀 넷드라이버 위치가 OnlineSubsystemSteam.SteamNetDriver 여기서 SocketSubsystemSteamIP.SteamNetDriver 여기로 변했다고 함. 또 어떤 사람은 SteamSockets 플러그인 추가하고 SteamSockets.SteamSocketsNetDriver 로 바꿔야 된다고도 함.어쨌든 아래와 같이 바꾸면 된다.C++1[/Script/Engine.GameEngine]2!NetDriverDefinitions=ClearArray3+NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="/Script/SteamSockets.SteamSocketsNetDriver",DriverClassNameFallback="OnlineSubsystemUtils.IpNetDriver")45[OnlineSubsystemSteam]6bInitServerOnClient=true // 세션 사용하면 필요. 세션 초기화용C++]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-외부-플러그인.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 외부 플러그인.md</guid><pubDate>Tue, 23 Sep 2025 13:04:33 GMT</pubDate></item><item><title><![CDATA[(0) 사소한 문제 해결 사례 - 엔진, 에디터, 빌드]]></title><description><![CDATA[희안한 실수를 하거나 엔진 버전이 업데이트되는 등 기존 프로젝트의 엔진 빌드를 제거하고 다시 빌드해야 하는 경우가 있다. 이 때는 Intermediate(빌드된 엔진 파일들이 들어있음), Saved(보통은 상관 없지만, 내부에 빌드 관련 정보를 저장하는 경우가 있음), Binaries, .vs, .sln 폴더와 파일들을 제거하고 uproject 파일을 통해 재빌드를 하면 된다.언리얼 빌드 툴 규약에 따라 cpp 파일에는 자기 헤더가 가장 위에서 포함되어야 한다.Build Configuration을 에디터로 지정하지 않은 것. 기본 VS IDE 세팅에선 Config창이 좁아서 글자가 다 안 보인다.상단바 우클릭→ Customize → Commands → Toolbar → Standard → Solution Configurations - Modify Selection - Width에서 넓힐 수 있다.Dynamic Nav Mesh 옵션을 켜고, Navigation Invoker 컴포넌트가 붙은 액터를 레벨에 배치했는데 Nav Mesh가 동적으로 베이킹이 안 됐다. → Nav Mesh 베이킹이 워낙 무거운 동작이라 그런지 관련 버그가 참 많다. 이 경우엔 컴포넌트를 제거했다가 다시 다니까 작동했다.아니면, 실제론 베이킹이 됐는데 시각적으로 반영만 안 된 것일 수도 있다.말 그대로다. 왜 이렇게 되는 지는 모르겠다. 아마 내부적으로 객체의 부모부터 내려오면서 같은 이름을 가진 함수를 찾나보다.고의인지 버그인 지는 모르겠으나, 콜라이더를 추가해야만 한다.아마 에셋 경로에 한글이나 괄호같은 특수문자가 포함되어 있을 것이다. 그럼 안 된다.안 된다. 다이나믹 델리게이트의 경우 블루프린트에서도 바인딩할 수 있어야 하므로 UHT가 파싱할 수 있어야 하며, 따라서 generated.h 를 만들어내는 특정 클래스와 함께 선언해야 한다.UPhysicalMaterial같은 언리얼 물리 에셋을 사용하려면 PhysicsCore 모듈을 포함해야 한다.아마 함수 내부를 편집하는 중일 것이고, 이 함수가 const라서 클래스의 멤버 변수(즉, 함수의 Local variable이 아닌 변수)를 편집할 수 없기 때문. Local variable로 만들어야 한다.OnRep 함수는 UFUNCTION() 지정해야 한다.상호작용으로 열 수 있는 상자 액터를 컨텐츠 브라우저에서 꺼내서 놓으면 잘 작동하는데, 이미 레벨에 배치한 액터를 Alt 드래그로 복사하면 작동을 안 했다.여러 실험을 해본 결과 결론적으로 상호작용 이벤트 델리게이트에 함수 바인딩하는 동작을 CDO에서 하고 있었는데, 이게 Alt 드래그로 복사한 액터에 대해선 동작을 안 했다.근데 이 코드를 BeginPlay로 옮기니까 이번엔 Alt 드래그로 복사한 액터만 되고, 컨텐츠 브라우저에서 꺼낸 액터는 안 되는 해괴망측한 경우가 생겼다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-엔진,-에디터,-빌드.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 엔진, 에디터, 빌드.md</guid><pubDate>Tue, 23 Sep 2025 13:04:31 GMT</pubDate></item><item><title><![CDATA[(0) 사소한 문제 해결 사례 - 애니메이션]]></title><description><![CDATA[버그다. 에디터를 껐다 켜면 된다.해당 시퀀스의 Additive 설정이 켜져있는데 Base pose가 없기 때문이다. Additive 시퀀스는 Base pose의 본 트랜스폼을 기준으로 곱연산을 가하는 것이므로 0 공간으로 들어가버리는 것.서서히 작아지는 이유는 그냥 시퀀스 블렌딩 때문이다.정확한 원인과 해결 방법을 아직 모르겠다. 프레임이 1장인 애니메이션(정확히는 포즈)을 임포트할 때 발생하는데, 블렌더로 2프레임으로 늘리면 괜찮아진다.애님 인스턴스는 기본이 에디터에서도 동작하도록 되어있다보니 기본이 미리보기로 되어있다. PIE로 실행한 뒤, 상단의 Preview Instance를 생성된 ABP 객체의 이름으로 바꿔주면 된다.좌상단에 알림이 뜨긴 할 텐데, 두 시퀀스의 프레임 레이트가 일치하지 않아서 그렇다. 몽타쥬 따로 만드는게 제일 빠름.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-애니메이션.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 애니메이션.md</guid><pubDate>Tue, 23 Sep 2025 13:04:30 GMT</pubDate></item><item><title><![CDATA[(0) 사소한 문제 해결 사례 - 렌더링]]></title><description><![CDATA[언리얼에서 기본적으로 켜져있는 모션 블러 때문이다. Project Settings - Rendering - Motion Blur를 끌 수 있다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-렌더링.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 렌더링.md</guid><pubDate>Tue, 23 Sep 2025 13:04:29 GMT</pubDate></item><item><title><![CDATA[(0) 사소한 문제 해결 사례 - 네트워크]]></title><description><![CDATA[MovementComponent 동기화 문제다. 아마 서버와 클라이언트의 MovementMode가 다르다던가 해서 속도에 오차가 발생했을 것이다. 이러면 서버는 항상 Authority를 가지므로 잘 움직이지만 클라이언트는 서버에 의해 위치가 보정되면서 끊기는 느낌이 난다.이 오차가 심해서 매 틱마다 네트워크 대역폭을 초과할 만큼의 오차가 발생하면 빨간색으로 4096 비트 초과 에러까지 뜬다.RPC는 자신이 소유한 액터를 통해서만 호출이 가능하다. 게임 스테이트는 서버만 소유하므로 클라가 게임 스테이트를 통해 ServerRPC를 호출할 수 없다.대신 클라이언트가 명확히 소유하고 있는 PlayerController에서 호출하거나, PC가 소유한 Pawn이나 PlayerState를 통해야 한다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0)-사소한-문제-해결-사례-네트워크.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0) 사소한 문제 해결 사례 - 네트워크.md</guid><pubDate>Tue, 23 Sep 2025 13:04:27 GMT</pubDate></item><item><title><![CDATA[TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기]]></title><description><![CDATA[Data Asset - FHTreasureBookShelfSpawningDescriptor<img alt="♣VaultStorage/attachment/Pasted image 20250916191700.png" src="♣vaultstorage/attachment/pasted-image-20250916191700.png" target="_self">
Minimum/Maximum Item Num : 책장에서 스폰될 최소/최대 액터 수
Steepness : 스폰될 액터 수를 결정할 때 사용하는 계산식의 지수부. 높아질 수록 높은 개수가 선택될 확률이 기하급수적으로 줄어든다. 1.0 ~ 2.0 사이를 권장.
Spawnable Actor List : 책장에서 스폰될 수 있는 액터를 등록한다. 책장 메쉬 콜라이더 문제로 스폰된 액터들의 SetPhysicsSimulated 플래그는 꺼진다. <br><img alt="♣VaultStorage/attachment/Pasted image 20250916191707.png" src="♣vaultstorage/attachment/pasted-image-20250916191707.png" target="_self">
Descriptor : 생성한 BookShelfDescriptor 데이터 에셋을 부착한다.
Shelf Row / Shelf Column : 책장의 가로, 세로 분할 수를 입력한다.
Row Gap / Column Gap : 각 분할 포인트마다 가로, 세로로 떨어질 거리를 입력한다.
Point Exception : 입력한 값에 해당하는 포인트는 스폰 포인트에서 제외된다. (예: { 2, 4 } → 2행 4열의 포인트는 제외)
<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191712.png" src="♣vaultstorage/attachment/pasted-image-20250916191712.png" target="_self" style="width: 525px; max-width: 100%;">Left Top Anchor Arrow 컴포넌트의 위치를 기준으로 우측과 아래로 분할된 스폰 포인트들이 생성된다.위에서 예외로 지정한 {2, 4}, {2, 5}에 해당하는 포인트에는 디버그 기즈모가 그려지지 않은 것을 확인할 수 있다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/기능-설명서/treasurebookshelf-액터를-통해-랜덤-아이템-스폰하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/TreasureBookShelf 액터를 통해 랜덤 아이템 스폰하기.md</guid><pubDate>Tue, 23 Sep 2025 13:04:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Dungeon Generator 사용하기]]></title><description><![CDATA[룸 프리셋은 실제 액터들이 배치되는 레벨과 해당 레벨이 등록된 RoomData 에셋으로 짝을 이루어 만들어진다.룸 데이터 에셋의 생성 방법은 다음과 같다.<img alt="♣VaultStorage/attachment/Pasted image 20250916191355.png" src="♣vaultstorage/attachment/pasted-image-20250916191355.png" target="_self" style="width: 575px; max-width: 100%;"><br><img alt="♣VaultStorage/attachment/Pasted image 20250916191401.png" src="♣vaultstorage/attachment/pasted-image-20250916191401.png" target="_self">FHRoomData 에셋은 다음과 같이 구성된다.미니맵에 해당 룸을 표시할 이미지를 부착한다. 다층 룸인 경우 0번 인덱스부터 가장 낮은 높이일 때로 시작해 인덱스가 높아질 수록 더 높은 높이에서 표시될 이미지를 부착한다.예컨대 4층으로 이루어진 룸이며, 미니맵에 표시되는 건 플레이어가 1층 높이와 4층 높이에 있을 때로 한정하고 싶다면 다음과 같이 구성한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191414.png" src="♣vaultstorage/attachment/pasted-image-20250916191414.png" target="_self" style="width: 475px; max-width: 100%;">각 룰 타입별로 적용되는 규칙을 정의할 수 있다. 종류는 다음과 같다.
Progress Rate Constraint : 던전 생성 진행도(던전의 구성이 몇 %만큼 완료되었는가) 상으로 특정 구간 내에서만 현재 룸 타입이 배치될 수 있도록 한다.
예컨대 Min값이 0.2, Max값이 0.7인 경우 20%~70% 구간에서만 룸이 배치될 수 있다.
Distance From Start Room : 시작 룸으로부터의 최소, 최대 거리를 정의한다. 추후 설명할 CustomConnection/Minimum Distance Rule에 시작 룸을 지정한 것과 같은 효과이다.
CustomConnection/Custom Connection Setting : 현재 룸 타입에 인접하여 타입에 대한 커스텀 규칙을 정의한다. Weight는 등장 가중치이다.
‘Use Only Custom Connection Rule’을 체크할 경우, 인접하여 배치될 방 후보 목록을 생성할 때 현재 항목에서 정의한 규칙만을 사용하게 되므로 주의하여 사용한다.
예컨대, 특정 타입의 룸만 0.2의 가중치를 가지도록 하고싶다면 다음과 같이 설정한다.<br>
<img alt="♣VaultStorage/attachment/Pasted image 20250916191424.png" src="♣vaultstorage/attachment/pasted-image-20250916191424.png" target="_self">
CustomConnection/Minimum Distance Rules : 현재 룸이 특정 타입의 룸들로부터 일정 거리만큼 떨어져 있도록 하는 규칙이다. 룸 규칙 중 가장 비용이 높으므로 주의하여 사용한다. Is Core Room : 현재는 아무 역할도 하지 않는다.
Default Weight : 룸의 기본 가중치. 기본 값은 1.0
Note
가중치는 등장 확률이 아닌 이산 분포를 사용한 추첨을 수행할 때 해당 타입이 가지게 될 값에 해당한다.
예컨대 가중치 목록이 { 1, 1, 0.5 }인 경우, 각각 40%, 40%, 20% 확률로 선택된다.
<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191455.png" src="♣vaultstorage/attachment/pasted-image-20250916191455.png" target="_self">현재 룸 데이터가 가리키는 룸 프리셋 레벨을 등록한다.룸에 달린 문을 설정한다. 룸과 룸은 같은 타입의 문끼리만 연결될 수 있으며, 여기서 문 타입은 연결 가능 여부를 판단하기 위한 개념일 뿐 실제로 배치되는 문 액터의 종류는 하나의 타입 내에서 여러 개 있을 수 있다.룸에 추가된 문들은 Doors 배열에 추가되며 각 요소마다 그리드 위치(X, Y, Z), 방향, 타입과 태그를 설정할 수 있다. 그리드 위치 및 방향에 대해선 추후 에디트 과정에서 설명한다.Type 슬롯에는 앞서 말한 문 타입을 지정한다. 여기서 지정된 타입이 같은 문끼리 연결되어 룸이 이어진다.Note
여기서 문 타입을 지정하지 않을 경우, DungeonDescriptor에서 설정한 DefaultDoorType을 사용하게 된다.
Door Tag 슬롯에는 문에 태그를 지정한다. 이는 스폰되는 액터를 지정하기 위한 수단이다.태그는 지정자와 옵션의 조합으로 이루어진다.
지정자의 종류는 다음과 같다.
Empty : 문 액터를 스폰하지 않고 연결한다.
ForceIndexN : N번 인덱스 문 액터를 스폰한다.
옵션의 종류는 다음과 같다.
IfBoth : 연결될 두 문에 동일한 태그가 달려있을 경우 적용된다.
IfAny : 연결된 두 문 중 하나의 문에라도 태그가 달려있을 경우 적용된다.
두 문의 태그가 상충(예컨대, 서로 종류가 다른 IfAny 태그가 달릴 경우)할 경우 Empty &gt; 인덱스 오름차순 순으로 우선 적용된다.모든 룸은 단일 레벨로 만들어지며, 배치될 때 적절한 위치에 레벨 내 액터들이 로드되는 형태로 동작한다.룸 프리셋 레벨을 열고 상단 에디트 모드를 Dungeon Room Mode로 변경한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191534.png" src="♣vaultstorage/attachment/pasted-image-20250916191534.png" target="_self">Dungeon Room Mode에선 에디터 뷰포트에 룸 그리드와 문을 표시하는 기즈모가 그려지며, 룸의 크기를 조절하거나 문의 위치를 변경할 수 있다.우선 Dungeon Room 탭의 Data에 자신과 짝을 이루는 RoomData 에셋을 등록한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191540.png" src="♣vaultstorage/attachment/pasted-image-20250916191540.png" target="_self">이후 두 가지 모드를 전환하며 룸을 편집할 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191544.png" src="♣vaultstorage/attachment/pasted-image-20250916191544.png" target="_self">Size 모드에서는 룸 꼭지점의 흰 박스를 누르고 트랜스폼을 변경하여 룸의 크기를 조절할 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191549.png" src="♣vaultstorage/attachment/pasted-image-20250916191549.png" target="_self">Door 모드에서는 룸의 단위 격자 영역에 새 문을 달거나 제거할 수 있다.좌클릭으로 새 문을 추가하고 우클릭으로 기존의 문을 제거한다.Room Data 에셋의 Doors 배열에서 수치로 편집하는 것도 가능하다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191553.png" src="♣vaultstorage/attachment/pasted-image-20250916191553.png" target="_self">FHDungeonDescriptor 타입은 던전의 명세를 구성하는 데이터 에셋이다. Miscellaneous - Data Asset - FHDungeonDescriptor를 선택하여 생성한다.
Gate Type : 게이트 디스크립터의 이름(타입)을 지정한다. 여기서 지정한 이름으로 사용할 디스크립터가 결정된다. Start Room : 최초로 배치되는 룸. Must Start on Start Room 옵션으로 사용 여부를 토글한다.
Last Room : 던전 생성의 마지막에 배치될 수도 있는 룸. 던전이 순차성을 가지지 않으므로 사용하는 의미가 없으며, 연결 불가능할 경우 배치되지 않을 수도 있다.
Regular Rooms : 일반 룸. 개수 제한을 가지지 않으며 RoomData 에셋의 커스텀 규칙만 적용된다.
Special Rooms : 특수 룸. 정해진 개수만큼 반드시 배치되며, 그 분포는 게이트 전체에 고르게 퍼진다. 만약 정해진 개수의 특수 룸 배치에 실패할 경우 던전 생성 자체를 재시도한다. Default Door Type : RoomData 에셋의 문 설정에서 문 타입이 지정되지 않은 경우 사용하게 될 기본 타입.
Door Setting : 각 문 타입 마다 배치될 실제 문 액터를 지정한다. Use Door Array를 체크할 경우 타입마다 여러 개의 액터를 둘 수 있으며, 랜덤하게 선택되거나 문 태그에 따라 특정 인덱스가 선택된다.
Wall Settings : 문이 배치될 수 없는 경우 배치되는 벽 액터. 설명은 위와 같다.
실제 던전 생성을 수행하는 액터. FHDungeonGenerator를 상속한다.
Dungeon/Dungeon Descriptor : 제너레이터가 사용할 디스크립터를 지정한다.
Project Settings - Plugins - Procedural Dungeon에서 플러그인 설정을 할 수 있다.General - Room Unit 벡터의 크기를 변경하여 던전 격자의 단위 크기를 변경할 수 있다.X, Y, Z 축 크기가 같은 정육면체 형태를 권장한다.Occlusion Culling - Enable Occlusion Culling에 체크할 경우 플레이어가 현재 위치한 룸을 기준으로 n개의 룸을 거쳐 이동할 수 있는 룸부터 그리기를 생략하여 최적화할 수 있다.단, 언리얼의 자체 드로잉 최적화가 있기 때문에 사용할 동기는 크지 않다.룸 레벨에 FHNavModifierVolume을 배치하여 마력석 스폰을 방지할 영역을 설정할 수 있다.FHNavModifierVolume의 VolumeType 변수는 기본값이 PreventOnly로 설정되어 있으며, 이 경우 마력석 스폰을 차단하는 용도로만 사용된 뒤 레벨에서 삭제되므로 이동을 차단하지는 않는다.반면 VolumeType이 Default 인 경우 삭제되지 않으며 이동까지 차단한다.룸이 배치될 때 룸 레벨에 존재하는 모든 액터가 그 모양 그대로 배치되는 반면, 생성되는 던전의 룸들은 룸 레벨을 편집할 때 그려지는 룸의 범위(실선 기즈모로 표현되는 범위)에 기반하여 배치된다.따라서 룸의 범위를 벗어난 액터는 룸이 연이어 배치될 경우 다른 룸을 침범하게 될 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191603.png" src="♣vaultstorage/attachment/pasted-image-20250916191603.png" target="_self">위 예시 이미지는 빨간 룸 프리셋에 배치된 파란색 액터가, 초록색 룸 프리셋과 빨간 룸 프리셋이 연달아 배치될 경우 초록색 룸 프리셋을 침범하는 상황을 보여준다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/기능-설명서/dungeon-generator-사용하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/Dungeon Generator 사용하기.md</guid><pubDate>Tue, 23 Sep 2025 13:04:23 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[바닥 메쉬에 Surface Type 추가하기]]></title><description><![CDATA[플레이어의 발소리는 애니메이션과 연동하여 발이 땅에 닿는 시점에 로컬 환경에서 재생된다.이 때 플레이어의 현재 속도와 딛고 있는 바닥 액터의 UPhysicalMaterial 내 SurfaceType에 따라 분기한다.엔진 열거형 타입으로 Project Settings에서 Physical Surface를 검색하여 이름을 변경할 수 있다.<img alt="♣VaultStorage/attachment/Pasted image 20250916191755.png" src="♣vaultstorage/attachment/pasted-image-20250916191755.png" target="_self" style="width: 300px; max-width: 100%;">작성한 SurfaceType은 UPhysicalMaterial 안에서 표면 타입으로 설정함으로써 사용된다.25-07-31 기준으로 Marble(대리석)은 로비 바닥, Stone은 신전 룸의 바닥으로 사용된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191800.png" src="♣vaultstorage/attachment/pasted-image-20250916191800.png" target="_self" style="width: 425px; max-width: 100%;">다음과 같이 피지컬 머테리얼 에셋을 생성할 수 있다.디테일 창에서 물리적 성질을 지정할 수 있으며, Physical Properties - Surface Type에 작성한 타입명을 설정한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250916191809.png" src="♣vaultstorage/attachment/pasted-image-20250916191809.png" target="_self" style="width: 350px; max-width: 100%;">작성한 UPhyiscalMaterial 에셋은 다음 두 곳에서 적용할 수 있다.
스태틱 메쉬 에셋의 디테일 창에서 Collision - Simple Collision Physical Material 슬롯에 지정.
이 경우 해당 메쉬를 사용하는 모든 액터의 기본 머터리얼이 된다.
액터의 StaticMeshComponent의 Collision - Phys Material Override 슬롯에 지정.
이 경우 1번의 설정을 덮어쓰게 되며, 메쉬 컴포넌트 단위로 적용된다.
]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/기능-설명서/바닥-메쉬에-surface-type-추가하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/기능 설명서/바닥 메쉬에 Surface Type 추가하기.md</guid><pubDate>Tue, 23 Sep 2025 13:04:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PhysicsConstraints 문, 상자]]></title><description><![CDATA[관절(Joint) 또는 물리적 제약을 추가하는 컴포넌트. 주요 설정은 다음과 같다.
두 개의 대상 간의 Joint를 생성한다. 대상은 Constraint - Component Name1과 2에 입력한다. 비워두면 월드 공간이 대상이 된다.
여기선 문에 경첩같은 관절을 심는 것이 목적이므로, 1에는 문 메쉬 컴포넌트의 이름을, 2는 비워두도록 한다.
Linear Limits(선형 제약)은 두 대상이 상대적으로 얼마나 이동할 수 있는지 정의한다. 문의 경우 축을 기준으로 회전하는 동작만 수행해야 하므로, X, Y, Z 모두 Locked로 설정한다.
Angular Limits(각도 제약)은 회전을 정의한다. 문은 대략 -100도 ~ 100도 사이의 회전각을 가져야 한다. 회전은 주축(보통 X) 회전인 Twist와 Twist를 기준으로 다른 두 축으로의 회전(Swing1, Swing2)로 구분된다.
Limited(각도 제한)로 설정한 뒤 각 축의 제한 각도를 변경해가며 회전 범위 기즈모가 어떻게 그려지는지 확인하자. 문의 경우, 경첩 위치에 PhysicsConstraint를 위치시킨 뒤 Swing1만 켜면 열고 닫는 동작을 구현할 수 있다. Angular Motor는 특정한 각도로 복원력을 가한다. 여기선 Target Orientation(목표 방향) - Drives의 Swing에 체크하고 Strength는 50을 주어 50의 힘으로 Target Orientation을 바라보려는 복원력을 가하도록 한다.
Angular Motor를 사용해 Target Orientation을 바꿔주는 것만으로 물리적으로 자연스러운 움직임을 구현할 수 있다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/physicsconstraints-문,-상자.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/PhysicsConstraints 문, 상자.md</guid><pubDate>Tue, 23 Sep 2025 13:04:14 GMT</pubDate></item><item><title><![CDATA[Physics Swing Door, Chest]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250922121547.png" src="♣vaultstorage/attachment/pasted-image-20250922121547.png" target="_self" style="width: 250px; max-width: 100%;">경첩 위치에 PhysicsConstraint 컴포넌트를 부착한다.문은 언제나 밀어서 열며 미는 방향은 내적을 통해 간단하게 구할 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922122825.png" src="♣vaultstorage/attachment/pasted-image-20250922122825.png" target="_self" style="width: 194px; max-width: 100%;">빨간 화살표가 문의 Front 벡터, 보라색 화살표가 문에서 상호작용 당사자로 향하는 벡터일 경우, 두 벡터를 내적한 결과가 위 그림처럼 음수라면 Front 방향으로 회전시키면 된다.단, 아래 그림처럼 Front view 기준으로 경첩이 우측에 달려있는 경우, PhysicsConstraint에 의해 회전하는 방향이 반대가 되어야 하므로, 회전 방향을 역전시키거나 앞/뒤 판정을 역전시켜야 한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922123242.png" src="♣vaultstorage/attachment/pasted-image-20250922123242.png" target="_self" style="width: 200px; max-width: 100%;">C++1bool AFHDoorBase::IsDoorOpenDirectionForward(AActor* Subject)2{3	FVector SubjectPos = Subject-&gt;GetActorLocation();4	FVector DoorPos = GetActorLocation();5	6	FVector DoorToPlayer = (SubjectPos - DoorPos).GetSafeNormal2D();78	FVector DoorRight = DoorMesh-&gt;GetForwardVector();9	float dot = FVector::DotProduct(DoorToPlayer, DoorRight);1011	if (bHingeIsRightOnFrontView)12	{13 return (dot &gt; 0) ? true : false;14	}15	else16	{17 return (dot &gt; 0) ? false : true;18	}19}C++열고 닫는 것은 PhysicsConstraint의 모터를 이용하면 된다.C++1AFHDoorBase::AFHDoorBase()2{3	...4	// 초기화5	6	// 연결된 두 객체 간의 충돌 비활성화7	PhysicsConstraint-&gt;SetDisableCollision(true);8	9	// X, Y, Z축 스프링은 제거10	PhysicsConstraint-&gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0);11	PhysicsConstraint-&gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0);12	PhysicsConstraint-&gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0);13	14	// Swing1 회전만 사용. 앞 뒤로 RotationLimit만큼 열림.15	PhysicsConstraint-&gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Limited, RotationLimit);16	PhysicsConstraint-&gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Locked, 0);17	PhysicsConstraint-&gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Locked, 0);18	19	// Angular Drive 모드 변경20	FConstraintInstance&amp; ConstraintInst = PhysicsConstraint-&gt;ConstraintInstance;21	ConstraintInst.ProfileInstance.AngularDrive.SwingDrive.bEnablePositionDrive = true;22	ConstraintInst.ProfileInstance.AngularDrive.SwingDrive.bEnableVelocityDrive = true;23	ConstraintInst.SetAngularDriveMode(EAngularDriveMode::Type::TwistAndSwing);24}2526void AFHDoorBase::PostInitializeComponents()27{28	Super::PostInitializeComponents();29	30	// 당연히 물리 시뮬레이션 대상이어야 하며31	DoorMesh-&gt;SetSimulatePhysics(true);32	// 플레이어가 밀어서 열리지 않게 하기 위해 무겁게 한다.33	DoorMesh-&gt;SetMassOverrideInKg(NAME_None, 5000.0f, true);34}3536void AFHDoorBase::ToggleDoorOpen_Implementation(AActor* Subject, float power)37{38	FRotator targetRot{ 0, 0, 0};39	if (bIsOpened == true)40	{41 // 목표 회전각을 0으로 되돌린다.42 bIsOpened = false;43	}44	else45	{46 // 목표 회전각을 플레이어의 위치에 따라 앞 또는 뒤로 연 각도로 바꾼다.47 bIsOpened = true;48 targetRot.Yaw = IsDoorOpenDirectionForward(Subject) ? OpenDegree : -OpenDegree;49	}5051	HandleDoor(DoorMesh, PhysicsConstraint, targetRot, power);52}5354void AFHDoorBase::HandleDoor(UStaticMeshComponent* _DoorMesh, UPhysicsConstraintComponent* _PhysicsConstraint, FRotator AngularOrientation, float movePower)55{56	FConstraintInstance&amp; ConstraintInst = _PhysicsConstraint-&gt;ConstraintInstance;57	float inSpring{};58	float damping{};59	float forceLimit{};6061	_PhysicsConstraint-&gt;SetAngularOrientationTarget(AngularOrientation);62	ConstraintInst.GetAngularDriveParams(inSpring, damping, forceLimit);63	ConstraintInst.SetAngularDriveParams(movePower, damping, forceLimit);6465	// Sleep 상태일 경우 물리 프로퍼티를 바꿔도 바로 반영되지 않으니 주의.66	_DoorMesh-&gt;WakeRigidBody();67}C++만약 모터를 사용하지 않고 실제로 물리적인 힘을 가한다면 다음과 같이 작성한다. 좋은 방식은 아닌 듯 하다.C++1// FName ForceAnchorSocketName{ TEXT("DoorPushPoint") };2// float PushForce{ 30000.0f };34FVector forcePos = DoorMesh-&gt;GetSocketLocation(ForceAnchorSocketName);5DoorMesh-&gt;AddImpluseAtLocation(ForceDirection * PushForce, forcePos);C++상자를 열고 닫는 동작은 문과 똑같이 작업하면 된다.
단, 상자의 경우 닫힌 상태가 기본이 되지만 회전 각도는 아래 그림과 같이 설정되므로, 닫힌 상태에서 지향하는 각도는 -RotationLimit/2가 된다.Note
-RotationLimit/2 로는 윗뚜껑이 무거워도 회전 스프링이 워낙 쎄서 살짝 달랑거리는 느낌이 난다. RotationLimit * -0.7로 변경.
<br><img alt="♣VaultStorage/attachment/Pasted image 20250922192331.png" src="♣vaultstorage/attachment/pasted-image-20250922192331.png" target="_self" style="width: 150px; max-width: 100%;">Note
PhysicsConstraint 컴포넌트가 자신이 연결을 시키는 대상의 자식으로 설정되어 있지 않으면 블루프린트 뷰에서 그려지는 기즈모와 실제 제한 각도 또는 위치가 달라지는 버그가 있는 듯.
내부에 아이템을 스폰하는 동작은 단순히 상자 메쉬에 스폰 포인트 소켓을 달고 ChestDescriptor 데이터 에셋에 스폰 가능한 액터를 채워넣어 랜덤 스폰하는 방식으로 구현했다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/physics-swing-door,-chest.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Physics Swing Door, Chest.md</guid><pubDate>Tue, 23 Sep 2025 13:04:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Details Property Customization]]></title><description><![CDATA[언리얼 에디터 디테일 창의 고급 커스텀 기능.
IPropertyTypeCustomization 인터페이스를 상속한 클래스로 디자인을 설계하고, 이걸 '언리얼 프로퍼티 모듈'에 등록하여 적용하는 방식이다.간단한 예시를 들며 구현해보자.
아래와 같은 구조체가 있을 때, 각 멤버를 편집하는 위젯이 한 라인에 나열되도록 해보겠다.C++1USTRUCT(BlueprintType)2struct FRANKHUNTER_API FSpawnableActorDescriptor3{4	GENERATED_BODY()5	6	UPROPERTY(EditAnywhere)7	uint32 bSpawnable : 1{ true };8	UPROPERTY(EditAnywhere)9	TSubclassOf&lt;AActor&gt; actor;10	UPROPERTY(EditAnywhere)11	uint32 weight;12};C++먼저 IPropertyTypeCustomization 을 상속하는 Customization 클래스를 선언한다. UObject가 아니므로 접두사는 F
MakeInstance() 함수로 모듈 클래스에 등록할 커스텀 커스터마이제이션 인스턴스를 생성한다.
CustomizeHeader() 함수로 details에 표시되는 커스텀 메뉴의 헤더를 정의한다.
CustomizeChildren() 함수로 해당 메뉴를 눌러 열었을 때 표시되는 자식 엘리먼트를 정의한다.
C++1#include "IPropertyTypeCustomization.h"2#include "PropertyHandle.h"34class FRANKHUNTER_API FSpawnableActorDescriptorCustomization : public IPropertyTypeCustomization5{6public:78	static TSharedRef&lt;IPropertyTypeCustomization&gt; MakeInstance();9	10	virtual void CustomizeHeader(TSharedRef&lt;IPropertyHandle&gt; StructPropertyHandle, class FDetailWidgetRow&amp; HeaderRow, IPropertyTypeCustomizationUtils&amp; CustomizationUtils) override;11	12	virtual void CustomizeChildren(TSharedRef&lt;IPropertyHandle&gt; StructPropertyHandle, class IDetailChildrenBuilder&amp; ChildBuilder, IPropertyTypeCustomizationUtils&amp; CustomizationUtils) override;13};C++에디터 UI를 편집하는 것이므로 Slate의 헤더들을 사용한다. 여기선 값을 넣을 박스 위젯만 필요하다.
이 외의 코드 설명은 주석으로C++1#include "DetailWidgetRow.h"2#include "IDetailChildrenBuilder.h"3#include "PropertyCustomizationHelpers.h"4#include "Widgets/SBoxPanel.h"5#include "Widgets/Layout/SBox.h"6#include "PropertyEditorModule.h"78TSharedRef&lt;IPropertyTypeCustomization&gt; FSpawnableActorDescriptorCustomization::MakeInstance()9{10 return MakeShareable(new FSpawnableActorDescriptorCustomization);11}1213void FSpawnableActorDescriptorCustomization::CustomizeHeader(TSharedRef&lt;IPropertyHandle&gt; StructPropertyHandle, class FDetailWidgetRow&amp; HeaderRow, IPropertyTypeCustomizationUtils&amp; CustomizationUtils)14{15 // 커스텀 디테일 엘리먼트를 만들 구조체(FSpawnableActorDescriptor)의 멤버들의 '프로퍼티 핸들'을 가져온다.16 TSharedPtr&lt;IPropertyHandle&gt; props[3] = {17 StructPropertyHandle-&gt;GetChildHandle(GET_MEMBER_NAME_CHECKED(FSpawnableActorDescriptor, bSpawnable)),18 StructPropertyHandle-&gt;GetChildHandle(GET_MEMBER_NAME_CHECKED(FSpawnableActorDescriptor, actor)),19 StructPropertyHandle-&gt;GetChildHandle(GET_MEMBER_NAME_CHECKED(FSpawnableActorDescriptor, weight))20 };2122 // 디테일의 행으로 사용할 SHorizontalBox를 담을 포인터23 TSharedPtr&lt;SHorizontalBox&gt; ValueRow;2425 // Slate 정의. 체이닝을 사용한다.2627 // 엘리먼트 헤더의 이름 출력칸(name context)에 접근 28 HeaderRow.NameContent()29 [30 // 구조체 프로퍼티의 이름출력 31 StructPropertyHandle-&gt;CreatePropertyNameWidget()32 ].ValueContent() // 해당 엘리먼트의 Value 칸에는33 [34 // 새 SHorizontalBox 객체 생성35 SAssignNew(ValueRow, SHorizontalBox)36 ];3738 // 프로퍼티를 순회하며 이름, 밸류 순으로 SHorizontalBox에 추가한다39 for (const auto&amp; prop : props)40 {41 ValueRow-&gt;AddSlot().AutoWidth().Padding(0, 0, 5.0f, 0) // 체이닝으로 너비나 패딩을 설정하는 등의 동작이 가능42 [43 prop-&gt;CreatePropertyNameWidget()44 ];45 ValueRow-&gt;AddSlot().AutoWidth().MinWidth(20.0f).Padding(0, 0, 20.0f, 0)46 [47 prop-&gt;CreatePropertyValueWidget()48 ];49 }50}5152void FSpawnableActorDescriptorCustomization::CustomizeChildren(TSharedRef&lt;IPropertyHandle&gt; StructPropertyHandle, class IDetailChildrenBuilder&amp; ChildBuilder, IPropertyTypeCustomizationUtils&amp; CustomizationUtils)53{54	// 헤더에 한 줄로 수정가능한 엘리먼트를 표시할 예정이므로 자식에 대한 정의는 필요하지 않음.55}C++설계도를 만들었으니 '어떤 클래스의 디테일을 표시할 때 이걸 사용하라'고 에디터에 알려줘야 한다.
그걸 담당하는 것이 언리얼 프로퍼티 모듈(FPropertyEditorModule)이다.물론 언리얼 프로퍼티 모듈 코드를 직접 수정할 수는 없으므로, 대신 다른 모듈의 StartupModule에서 프로퍼티 모듈을 가져와 등록하는 방식이다.
그 역할은 일반적으로 언리얼 에디터 수정용 모듈을 따로 만들어서 맡긴다. 게임 모듈을 사용하면 에디터에서만 사용하는 코드, 패키징에서 사용하는 코드를 구분할 수 없게 되므로 나중에 문제가 생길 수 있다.다만 여기선 메인 게임 모듈을 사용한다.
※ 주의: 주 게임 모듈 클래스는 IsGameModule을 상속하고 true를 리턴해야지만 언리얼 에디터에서 C++ 프로젝트로 인식이 되고 우하단에 컴파일 버튼이 생긴다.C++1class FRankHunterModule : public IModuleInterface2{3public:4	virtual void StartupModule() override; // 여기서 커스텀 Customization을 등록하고5	virtual void ShutdownModule() override; // 여기서 해제한다67	virtual bool IsGameModule() const override{ return true; }8};C++C++1#include "Modules/ModuleManager.h"2#include "DungeonGeneration/FHSpawningPointDescriptor.h" // Custom property customization이 선언된 헤더34void FRankHunterModule::StartupModule()5{6	// Property Editor 모듈을 가져온다.7	FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;("PropertyEditor");89	// MakeInstance 함수의 주소를 전달하여, 그 함수를 이용해 커스터마이제이션 인스턴스를 만들어 사용하게 한다.10	PropertyModule.RegisterCustomPropertyTypeLayout(FSpawnableActorDescriptor::StaticStruct()-&gt;GetFName(), FOnGetPropertyTypeCustomizationInstance::CreateStatic(&amp;FSpawnableActorDescriptorCustomization::MakeInstance));11	// 수동으로 알려줘야 한다.12	PropertyModule.NotifyCustomizationModuleChanged();13}1415void FRankHunterModule::ShutdownModule()16{17	// 해제18	if (FModuleManager::Get().IsModuleLoaded("PropertyEditor"))19	{20 FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;("PropertyEditor");21 PropertyModule.UnregisterCustomPropertyTypeLayout(FSpawnableActorDescriptor::StaticStruct()-&gt;GetFName());22	}23}2425// 위에서 말했지만, 주 게임 모듈을 사용하지 않는 것을 권장.26IMPLEMENT_PRIMARY_GAME_MODULE(FRankHunterModule, FRankHunter, "FRankHunter");C++이제 등록된 클래스는 디테일 창에서 우리가 설계한 대로 표시된다. 예컨대 아래와 같은 데이터 에셋을 만들면C++1UCLASS()2class FRANKHUNTER_API UFHSpawningPointDescriptor : public UDataAsset3{4	GENERATED_BODY()5	67public:8	UPROPERTY(EditAnywhere, Category = "SpawingPointSetting");9	TArray&lt;FSpawnableActorDescriptor&gt; SpawnableItemList;10	UPROPERTY(EditAnywhere, Category = "SpawingPointSetting");11	TArray&lt;FSpawnableActorDescriptor&gt; SpawnableMonsterList;12	UPROPERTY(EditAnywhere, Category = "SpawingPointSetting");13	TArray&lt;FSpawnableActorDescriptor&gt; SpawnablePropList;1415public:16	UFHSpawningPointDescriptor();17};C++아래와 같이 한 라인에 제대로 표시되는 것을 볼 수 있다.<img alt="♣VaultStorage/attachment/Pasted image 20250816001455.png" src="♣vaultstorage/attachment/pasted-image-20250816001455.png" target="_self">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/details-property-customization.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Details Property Customization.md</guid><pubDate>Tue, 23 Sep 2025 13:04:09 GMT</pubDate></item><item><title><![CDATA[Custom Stencil Buffer 사용하기]]></title><description><![CDATA[언리얼은 1바이트의 커스텀 스텐실 버퍼를 제공한다. 이를 사용하기 위해선 우선
Project Settings - Engine - Rendering - Custom Depth-Stencill Pass 옵션을 ‘Enabled with Stencil’로 변경해야 한다.이후 언리얼의 렌더링 기초인 UPrimitiveComponent의 Details - Rendering - Advanced 섹션에서 'Render CustomDepth Pass' 플래그를 켜고, 'CustomDepth Stencil Value'에 커스텀 스텐실 값을 적으면 된다.일반적으론 Post Process를 통해 이를 활용한다. 가장 간단한 방법은 Domain이 PostProcess인 마터리얼을 작성하고, 이를 레벨에 배치된 Post Process Volume에 입혀 적용하는 것이다.
PostProcess는 모든 렌더링이 완료된 후각 픽셀에 대해 이루어지므로 CustomStencil SceneTexture로부터 바로 픽셀의 커스텀 스텐실 값을 알 수 있다.<img alt="♣VaultStorage/attachment/Pasted image 20250812205417.png" src="♣vaultstorage/attachment/pasted-image-20250812205417.png" target="_self">SceneTexture:CustomStencil이 스텐실 ID가 기록된 텍스쳐, SceneTexture:PostProcessInput0가 포스트 프로세스 과정의 처음 들어오는 렌더 텍스쳐이다.커스텀 스텐실 값은 커스텀 스텐실 신 텍스쳐의 R, 그 중에서도 1바이트만 사용하므로 Mask 노드로 필터링하여 가져온다.
위 예시에서는 그렇게 가져온 스텐실 ID가 1이라면 빨간색으로 그리도록 되어있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205421.png" src="♣vaultstorage/attachment/pasted-image-20250812205421.png" target="_self">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/custom-stencil-buffer-사용하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Stencil Buffer 사용하기.md</guid><pubDate>Tue, 23 Sep 2025 13:04:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Custom Camera Shake Pattern]]></title><description><![CDATA[일정 시간동안 카메라의 트랜스폼과 POV에 가외의 변경값을 가하여 흔들리는 효과를 주는 기능.아주 쉽다.
CameraShakeBase 에셋을 만들고 흔들림을 정의한다.
액터에 CameraShakeSourceComponent를 부착하고 Start Camera Shake를 호출한다.
기본적으로 CameraShakeSourceComponent의 영향을 받는 것은 반경 안에 있는 모든 카메라다.
마땅히 컴포넌트를 붙일 액터가 없다면 이미 컴포넌트가 부착되어 있는 CameraShakeSourceActor를 스폰하여 사용하면 된다.기획에서 플레이어가 곡괭이를 휘두르거나 휘두른 곡괭이가 사물에 맞을 때 사실감을 더하기 위해 약간의 흔들림을 주면 좋겠다고 요청해왔다.구현할 방법이야 많겠지만, CameraShake를 사용하면 원본 트랜스폼이 변질될 걱정도 없고, 여러 Shake 간의 블렌딩도 가능하기 때문에 이걸 사용하기로 했다.
기존의 패턴으론 느낌을 살리기 어려워 간단히 UCurveFloat 곡선을 따라 카메라의 회전값을 조절하는 커스텀 패턴을 만들어보았다.함수의 인자로 전달되는 OutResult에 가외로 더할 값을 넣어주면 알아서 카메라에 입히는 방식이다.C++1// Copyright F Rank Hunter. All Rights Reserved.23#pragma once45#include "CoreMinimal.h"6#include "Shakes/SimpleCameraShakePattern.h"7#include "FHSimpleCurveCameraShakePattern.generated.h"89UCLASS()10class FRANKHUNTER_API UFHSimpleCurveCameraShakePattern : public USimpleCameraShakePattern11{12	GENERATED_BODY()1314public:15	UPROPERTY(EditAnywhere, Category = "SimpleCurve")16	uint32 bCompressCurveIntoDuration : 1{ true };17	18	UPROPERTY(EditAnywhere, Category = "SimpleCurve")19	float RotationMagnitudeMultiplier = 1.f;2021	UPROPERTY(EditAnywhere, Category = "SimpleCurve")22	TObjectPtr&lt;UCurveFloat&gt; RotationPitchCurve;23	24	UPROPERTY(EditAnywhere, Category = "SimpleCurve")25	TObjectPtr&lt;UCurveFloat&gt; RotationYawCurve;26	27	UPROPERTY(EditAnywhere, Category = "SimpleCurve")28	TObjectPtr&lt;UCurveFloat&gt; RotationRollCurve;2930private:31	float ElapsedTime{ 0.0f };3233	float TimeCompressionFactor_Pitch{ 0.0f };34	float TimeCompressionFactor_Yaw{ 0.0f };35	float TimeCompressionFactor_Roll{ 0.0f };3637public:38	UFHSimpleCurveCameraShakePattern(const FObjectInitializer&amp; ObjInit);39private:40	// 시작시 카메라 쉐이크를 초기화하는 함수41	virtual void StartShakePatternImpl(const FCameraShakePatternStartParams&amp; Params) override;42	// 카메라 쉐이크 Duration동안 지속적으로 호출되는 함수43	virtual void UpdateShakePatternImpl(const FCameraShakePatternUpdateParams&amp; Params, FCameraShakePatternUpdateResult&amp; OutResult) override;44	// 카메라 쉐이크의 흔적을 지우고 원상태로 되돌리는 함수45	virtual void ScrubShakePatternImpl(const FCameraShakePatternScrubParams&amp; Params, FCameraShakePatternUpdateResult&amp; OutResult) override;4647	void UpdateSimpleCurve(float DeltaTime, FCameraShakePatternUpdateResult&amp; OutResult);48};49C++C++1// Copyright F Rank Hunter. All Rights Reserved.234#include "Effects/FHSimpleCurveCameraShakePattern.h"56UFHSimpleCurveCameraShakePattern::UFHSimpleCurveCameraShakePattern(const FObjectInitializer&amp; ObjInit) : Super(ObjInit) {}78void UFHSimpleCurveCameraShakePattern::StartShakePatternImpl(const FCameraShakePatternStartParams&amp; Params)9{10	Super::StartShakePatternImpl(Params);1112	if (!Params.bIsRestarting)13	{14 ElapsedTime = 0.0f;15 float MinTime, MaxTime{ 0.0f };1617 if (bCompressCurveIntoDuration)18 {19 if (RotationPitchCurve)20 {21 RotationPitchCurve-&gt;GetTimeRange(MinTime, MaxTime);22 TimeCompressionFactor_Pitch = MaxTime / Duration;23 }24 if (RotationYawCurve)25 {26 RotationYawCurve-&gt;GetTimeRange(MinTime, MaxTime);27 TimeCompressionFactor_Yaw = MaxTime / Duration;28 }29 if (RotationRollCurve)30 {31 RotationRollCurve-&gt;GetTimeRange(MinTime, MaxTime);32 TimeCompressionFactor_Roll = MaxTime / Duration;33 }34 }35	}36}3738void UFHSimpleCurveCameraShakePattern::UpdateShakePatternImpl(const FCameraShakePatternUpdateParams&amp; Params, FCameraShakePatternUpdateResult&amp; OutResult)39{40	UpdateSimpleCurve(Params.DeltaTime, OutResult);4142	const float BlendWeight = State.Update(Params.DeltaTime);43	OutResult.ApplyScale(BlendWeight);44}4546void UFHSimpleCurveCameraShakePattern::ScrubShakePatternImpl(const FCameraShakePatternScrubParams&amp; Params, FCameraShakePatternUpdateResult&amp; OutResult)47{48	ElapsedTime = 0.0f;4950	UpdateSimpleCurve(Params.AbsoluteTime, OutResult);5152	const float BlendWeight = State.Scrub(Params.AbsoluteTime);53	OutResult.ApplyScale(BlendWeight);54}5556void UFHSimpleCurveCameraShakePattern::UpdateSimpleCurve(float DeltaTime, FCameraShakePatternUpdateResult&amp; OutResult)57{58	ElapsedTime += DeltaTime;5960	if (bCompressCurveIntoDuration)61	{62 if (RotationPitchCurve)63 {64 OutResult.Rotation.Pitch = RotationPitchCurve-&gt;GetFloatValue(ElapsedTime * TimeCompressionFactor_Pitch) * RotationMagnitudeMultiplier;65 }66 if (RotationYawCurve)67 {68 OutResult.Rotation.Yaw = RotationYawCurve-&gt;GetFloatValue(ElapsedTime * TimeCompressionFactor_Yaw) * RotationMagnitudeMultiplier;69 }70 if (RotationRollCurve)71 {72 OutResult.Rotation.Roll = RotationRollCurve-&gt;GetFloatValue(ElapsedTime * TimeCompressionFactor_Roll) * RotationMagnitudeMultiplier;73 }74	}75	else76	{77 if (RotationPitchCurve)78 {79 OutResult.Rotation.Pitch = RotationPitchCurve-&gt;GetFloatValue(ElapsedTime) * RotationMagnitudeMultiplier;80 }81 if (RotationYawCurve)82 {83 OutResult.Rotation.Yaw = RotationYawCurve-&gt;GetFloatValue(ElapsedTime) * RotationMagnitudeMultiplier;84 }85 if (RotationRollCurve)86 {87 OutResult.Rotation.Roll = RotationRollCurve-&gt;GetFloatValue(ElapsedTime) * RotationMagnitudeMultiplier;88 }89	}90}C++]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/custom-camera-shake-pattern.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Custom Camera Shake Pattern.md</guid><pubDate>Tue, 23 Sep 2025 13:04:04 GMT</pubDate></item><item><title><![CDATA[Clothing Physics, 깃발]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250922193555.png" src="♣vaultstorage/attachment/pasted-image-20250922193555.png" target="_self" style="width: 150px; max-width: 100%;"> <img alt="♣VaultStorage/attachment/Pasted image 20250922193601.png" src="♣vaultstorage/attachment/pasted-image-20250922193601.png" target="_self" style="width: 200px; max-width: 100%;"> 블렌더로 여러 면으로 나눠진 깃발 메쉬를 준비한다.
블렌더의 Subdivide 기능을 사용하면 메쉬를 잘게 나눌 수 있다. FBX로 Export 언리얼 에디터에 Skeletal Mesh로 Import한다.
언리얼5 이후로 그냥 fbx 파일을 언리얼 에디터로 드래그를 했을 때 나오는 Import Content 창에서는 Import Skeletal Mesh를 체크해도 본 정보가 없기 때문에 Skeletal Mesh가 만들어지지 않는다.
대신 Content Browser 상단의 Import - 파일 확장자를 ‘FBX skeletal meshes’로 설정한 상태로 fbx 파일을 열자. 그럼 강제로 Skeletal Mesh로 Import를 시도하며, 본이 없기 때문에 비어있는 Physics Asset과 Skeleton을 포함해 Skeletal Mesh 에셋이 생성된다. 생성된 머터리얼을 열고 Two Sided에 체크한다. 깃발을 위한 Clothing Physics 데이터를 생성한다.
메쉬를 우클릭하고 Create Clothing -&gt; Create<br>
<img alt="♣VaultStorage/attachment/Pasted image 20250922193828.png" src="♣vaultstorage/attachment/pasted-image-20250922193828.png" target="_self" style="width: 450px; max-width: 100%;"> Cloth Paint로 Clothing Physics를 적용할 면을 설정한다.
Seketal Mesh 에셋을 열고 상단의 Activate Cloth Paint 버튼을 눌러 페인팅 모드로 전환한다.
그리고 4번에서 생성한 Clothing 데이터를 Clothing 탭(없으면 Window - Clothing 체크) - CLOTHING DATA에서 선택한다.
이후 메쉬에 브러쉬질을 해 물리를 적용할 정점을 지정한다.<br>
<img alt="♣VaultStorage/attachment/Pasted image 20250922193858.png" src="♣vaultstorage/attachment/pasted-image-20250922193858.png" target="_self" style="width: 400px; max-width: 100%;">
Clothing 탭에서 Paint Value(피직스 적용 강도)와 브러쉬 사이즈를 설정할 수 있다.<br>
<img alt="♣VaultStorage/attachment/Pasted image 20250922193912.png" src="♣vaultstorage/attachment/pasted-image-20250922193912.png" target="_self" style="width: 450px; max-width: 100%;">
브러쉬질이 끝났으면 상단의 Deactivate Cloth Paint 버튼을 눌러 저장하고
메쉬 우클릭 → Apply Clothing Data → 브러쉬질 한 Clothing Data 선택하여 Skeletal Mesh에 지정한다. 작업을 마쳤다면 해당 스켈레탈 메쉬를 배치만 해도 알아서 천 물리가 작동한다.Wind Directional Source 액터를 배치해 적당히 바람에 나부끼게 해주자.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/clothing-physics,-깃발.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Clothing Physics, 깃발.md</guid><pubDate>Tue, 23 Sep 2025 13:04:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chaos Destruction을 사용한 오브젝트 부수기]]></title><description><![CDATA[참고문헌
지오메트리 컬렉션 사용자 가이드
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://dev.epicgames.com/documentation/ko-kr/unreal-engine/geometry-collections-user-guide" target="_self">https://dev.epicgames.com/documentation/ko-kr/unreal-engine/geometry-collections-user-guide</a>
카오스 필드 사용자 가이드<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://dev.epicgames.com/documentation/ko-kr/unreal-engine/chaos-fields-user-guide-in-unreal-engine#%EC%86%8C%EA%B0%9C" target="_self">https://dev.epicgames.com/documentation/ko-kr/unreal-engine/chaos-fields-user-guide-in-unreal-engine#%EC%86%8C%EA%B0%9C</a>
지오메트리 컬렉션 에셋을 생성하는 건 매우 쉬우므로 생략한다.언리얼 카오스 시스템에는 카오스 필드라는, 볼륨을 통해 지오메트리 컬렉션을 조작할 수 있게 해주는 아주 간편한 기능을 포함한다.
언리얼은 활용도가 높은 카오스 필드 로직을 미리 작성해서 제공해준다. 컨텐츠 브라우저에서 Settings - Show Engine Contents에 체크한 뒤, Engine - Content - Engine Resources - FieldNodes 안에 있는 FS_ 접두어의 블루프린트들이 그것이다.이 중에 FS_MasterField는 볼륨 내에 특정한 힘을 가하는 역할로, 기본값은 방사형으로 화살표의 원점에서 화살표 방향으로 일정한 충격을 가하는 것이다.단순히 코어를 산산조각내는 거라면 크게 건드릴 부분은 없다. 그냥 Child Actor로 FS_MasterField를 코어 오브젝트의 자식으로 집어넣고, Activation Type을 Trigger로 바꾼 뒤, 플레이어의 타격이 발생할 때 CE_Trigger 이벤트를 호출하면 된다.<br><img alt="♣VaultStorage/attachment/2025_7_27_32.gif" src="♣vaultstorage/attachment/2025_7_27_32.gif" target="_self">이 때 코어 오브젝트의 물리를 켜주면 위와 같은 모습이 된다.파괴된 잔해는 GC 에셋의 Removal 카테고리에서 Romove on Sleep을 활성화하여 제거할 수 있다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/chaos-destruction을-사용한-오브젝트-부수기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/Chaos Destruction을 사용한 오브젝트 부수기.md</guid><pubDate>Tue, 23 Sep 2025 13:04:00 GMT</pubDate><enclosure url="♣vaultstorage/attachment/2025_7_27_32.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;♣vaultstorage/attachment/2025_7_27_32.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[상호작용, Interactable Component]]></title><description><![CDATA[단순하게 상호작용을 구현하는 방식은 크게 두 가지가 있을 듯 하다.
상호작용 가능한 물체가 상호작용 인터페이스를 상속하게 한다.
상호작용 가능한 물체에 상호작용 컴포넌트를 부착한다.
혹은 둘 다 사용해서 상호작용 가능 여부는 인터페이스 캐스팅으로, 관련 데이터는 컴포넌트에서 처리하기도 한다고 함.
나는 후자를 사용했다.고려한 요소와 구현의 특징은 다음과 같다.
우선 상호작용은 플레이어가 바라본 물체에 상호작용 키를 누르는 것을 의미한다.
상호작용의 형태는 세 가지로 구분된다. (1) 누르는 순간 이벤트 발생, (2) 누르고 n초 대기 후 이벤트 발생, (3) 떼는 순간 이벤트 발생 많은 게임들이 이런 형태를 취하고 있다. '(3) 떼는 순간'까지 처리해야 하는 이유는 하나의 물체에 짧게 누르기, 길게 누르기 두 가지 종류의 상호작용이 가능할 수 있기 때문이다.
예컨대 우리 게임에서 문은 짧게 누르면 소리를 내며 벌컥 열고, 길게 누르면 소리를 내지 않고 살살 연다. 이 때 짧게 누른 경우를 '(1) 누르는 순간'으로 처리하게 되면 길게 누를 때와 구분할 수가 없어진다. 이 방식은 포기했다. 떼는 순간 이벤트를 발생시키니까 체감되는 반응속도가 너무 느리기도 하고, 빠르게 움직일 때 누른 뒤 시점이 이동해 문 메쉬에서 벗어난 채로 떼게 되면 문이 열리지 않기 때문에 불편하기도 하다. 그렇다고 누른 순간의 타겟 메쉬를 캐싱해뒀다가 시점이 벗어나면 강제로 상호작용을 발생시키자니 그걸 의도하지 않았을 수도 있어서 골치가 아프다. 상호작용 키는 하나가 아닐 수도 있다.
아주 단순하다. 각 플레이어마다 현재 상호작용 가능한 오브젝트를 갱신하고, 상호작용 키를 누르면 타겟의 상호작용 컴포넌트를 통해 소통하게 된다.<img alt="♣VaultStorage/attachment/Pasted image 20250922184639.png" src="♣vaultstorage/attachment/pasted-image-20250922184639.png" target="_self" style="width: 825px; max-width: 100%;"><br><img alt="♣VaultStorage/attachment/Pasted image 20250922184658.png" src="♣vaultstorage/attachment/pasted-image-20250922184658.png" target="_self" style="width: 825px; max-width: 100%;">몇 가지 분기 처리(상호작용 도중 타겟이 변경되는 등)와 RPC를 통한 통신 때문에 코드량이 조금 늘어나긴 했지만 전체적인 구조 자체는 위와 같다.상호작용 컴포넌트는 다음의 기능을 지원한다.
툴팁 위젯 설정과 위젯 텍스트 변경
클라이언트 로컬 상호작용과 서버를 거쳐 멀티캐스트되는 상호작용 타입에 따라 다른 델리게이트를 사용한다.
상호작용 가능 거리, 상호작용 가능 여부, 툴팁 출력 여부, 누르고 있어야 하는 시간, 액터 감지 무시 등을 설정한다.
강조를 위해 아웃라인을 그릴 때, 스텐실 값을 기록하는 역할을 수행한다. (강조를 위한 아웃라인 문서 참고)
자체엔진이었다면 조금 까다로울 수 있었지만 언리얼에선 매우 간단하다.
일단, EnhancedInputComponent에 함수를 바인딩할 때 ETriggetEvent::Ongoing 타입의 액션을 지원한다.
해당 액션은 키를 누르고 있는 매 틱마다 함수를 호출한다.이 때 바인딩할 함수가 인자로 FInputActionInstance 구조체를 받으면 그 안에 해당 키를 얼마동안 누르고 있는지 데이터가 담겨서 온다.
단, 같은 타겟에 대해서 누르고 있었던 건 지는 알 수 없으므로 그걸 그대로 사용하진 않고, 타겟이 바뀌면 초기화되는 변수에 저장한다.C++1// UEnhancedInputComponent* PEI;2PEI-&gt;BindAction(InputActions-&gt;InputInteract1, ETriggerEvent::Started, this, &amp;AFHPlayerBase::Interact);3PEI-&gt;BindAction(InputActions-&gt;InputInteract1, ETriggerEvent::Ongoing, this, &amp;AFHPlayerBase::InteractHold);4PEI-&gt;BindAction(InputActions-&gt;InputInteract1, ETriggerEvent::Completed, this, &amp;AFHPlayerBase::InteractReleased);C++C++1void AFHPlayerBase::InteractHold(const struct FInputActionInstance&amp; InputActionInstance)2{3	// 예외 처리: 상호작용 가능 상태인지, 상호작용을 막는 GameplayTag가 부착되어 있지 않은지 등을 체크.4	...5	6	// float ElapsedTimeForInteract;7	// bool HoldingInteractTriggered;89	float Percent = 0.0f;10	if (HoldingInteractTriggered == false &amp;&amp;11 CurrentInteractable-&gt;GetHoldDuration() &lt;= ElapsedTimeForInteract &amp;&amp;12 CurrentInteractable-&gt;IsInteractableWithKey(InputActionInstance.GetSourceAction()))13	{14 HoldingInteractTriggered = true;15 CurrentInteractable-&gt;OnInteractHoldClient.Broadcast(this, InputActionInstance.GetSourceAction(), ElapsedTimeForInteract);16 Server_InteractHold(CurrentInteractable.Get(), ElapsedTimeForInteract, InputActionInstance.GetSourceAction());17	}18	else19	{20 ElapsedTimeForInteract += GetWorld()-&gt;GetDeltaSeconds();21 if (CurrentInteractable-&gt;GetHoldDuration() &gt; ElapsedTimeForInteract)22 {23 Percent = ElapsedTimeForInteract / CurrentInteractable-&gt;GetHoldDurationForHoldingInteract();24 }25	}26	GetPlayerStateChecked&lt;AFHPlayerStateBase&gt;()-&gt;OnChangeInteractProgressPercentDelegate.Broadcast(Percent);27}C++보고 있는 물체 체크를 라인 트레이스로 처리하니까 작은 물체에 상호작용을 하기가 너무 불편했다.C++1AActor* AFHPlayerBase::GetActorInfront(const float MaxLength, OUT float&amp; Distance, bool bOnlyDetectInteractable)2{3	FVector Start = CameraComponent-&gt;GetComponentLocation();4	FVector ForwardVector = CameraComponent-&gt;GetForwardVector();5	Start += (ForwardVector * PlayerDescriptor-&gt;AdditionalViewRayStartDistanceFromCamera);6	FVector End = Start + (ForwardVector * MaxLength);78	TArray&lt;FHitResult&gt; HitResults;9	FCollisionQueryParams Params;10	Params.AddIgnoredActor(this);1112	FCollisionShape SweepShape = FCollisionShape::MakeSphere(PlayerDescriptor-&gt;GetInfrontActorSweepRadius);13	bool bHit = GetWorld()-&gt;SweepMultiByChannel(HitResults, Start, End, FQuat::Identity, ECC_Camera, SweepShape, Params);1415	if (bHit)16	{17 HitResults.Sort([](const FHitResult&amp; A, const FHitResult&amp; B)18 {19 return A.Distance &lt; B.Distance;20 });2122 if (bOnlyDetectInteractable)23 {24 for (FHitResult&amp; hit : HitResults)25 {26 if (!hit.GetActor()) continue;27 UFHInteractableComponent* interactableComp = hit.GetActor()-&gt;GetComponentByClass&lt;UFHInteractableComponent&gt;();28 if (!interactableComp) continue;29 if (!interactableComp-&gt;IsActive()) continue;30 if (interactableComp-&gt;bIgnoreThisActorFromInteractCheck) continue;3132 Distance = hit.Distance;33 return hit.GetActor();34 }35 }36 else37 {38 for (FHitResult&amp; hit : HitResults)39 {40 if (!hit.GetActor()) continue;41 UFHInteractableComponent* interactableComp = hit.GetActor()-&gt;GetComponentByClass&lt;UFHInteractableComponent&gt;();42 if (interactableComp)43 {44 if (interactableComp-&gt;bIgnoreThisActorFromInteractCheck) continue;45 }4647 Distance = hit.Distance;48 return hit.GetActor();49 }50 }5152 53	}5455	return nullptr;56}C++
백팩 액터의 상호작용이 되지 않는 문제
컴포넌트 Active 플래그가 꺼졌을 때 TickComponent에 들어가지 않아 스텐실 값이 남아있는 문제
]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/상호작용,-interactable-component.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/상호작용, Interactable Component.md</guid><pubDate>Tue, 23 Sep 2025 13:03:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[메타휴먼에 Dissolving 이펙트 입히기]]></title><description><![CDATA[플레이어가 죽었을 때 소환당하는 효과를 구현한다.
Dynamic Material Instance를 사용해 동적으로 머터리얼 파라미터를 증가시켜, 노이즈 텍스쳐를 따라 Opacity Mask가 낮아져 투명해지는 부분의 주변 테두리에 푸른 Emissive를 주는 방식이다.메타 휴먼을 사용할 것이므로 Material Function 형태로 작성, 기존 메타 휴먼 머터리얼의 마지막 부분에 조합해주는 방식으로 구현했다.
문제는 그 머터리얼이 더럽게 많다는 것이다.<img alt="♣VaultStorage/attachment/Pasted image 20250922195704.png" src="♣vaultstorage/attachment/pasted-image-20250922195704.png" target="_self" style="width: 475px; max-width: 100%;">파라미터는 5개로 구성된다.
Dissolve : 핵심 밸류. -1 ~ 1 사이의 값을 가지며 노이즈 텍스쳐와 더해져 해당 픽셀의 Opacity Mask 값을 결정한다. Opacity Mask는 특정 값(기본 0.33) 이하면 그리기를 생략하게 된다.
DissolveEdge : 부드러운 보간(SmoothStep) 노드의 최대값으로 값이 클 수록 SmoothStep의 결과가 1이 아닌 0.xx로 나타나게 되므로 최종 GlowingColor의 색조를 낮추게 된다.<br>
<img alt="♣VaultStorage/attachment/Pasted image 20250922195719.png" src="♣vaultstorage/attachment/pasted-image-20250922195719.png" target="_self" style="width: 200px; max-width: 100%;"> SmoothStep 노드는 Min ~ Max 사이의 부드러운 보간 함수로, S자 형태로 끝으로 갈 수록 유려한 곡선을 그려 단순 Lerp보다 부드러운 느낌을 준다. Value가 Min보다 작으면 0을, Max보다 크면 1을 반환한다. DissolveIntensity : 커질 수록 부드러운 보간 노드의 보간계수가 낮아지고 이에 따라 SmoothStep이 0을 반환하는 영역이 커지게 되므로 Dissolving 테두리에서 Emissive Color를 방출하는 픽셀의 너비가 좁아지게 된다. 우선 메타휴먼은 Body, Feet, Leg, Torso, Face 스켈레탈 메쉬에 Eyelashes(속눈썹), Fuzz(얼굴 솜털), Eyebrows(눈썹), Hair(머리), Mustache(콧수염), Beard(수염)이라는 GroomComponent들로 이루어지며, 엄청나게 많은 머터리얼을 사용한다.
우선 Opacity Mask를 사용해 투명해질 영역을 지정해야 하므로 BlendMode는 Masked여야 한다.
Masked는 Opacity가 0 또는 1, Translucent는 0 ~ 1로 나타난다.
스켈레탈 메시의 마터리얼들은 기본적으로 Masked 또는 Opaque로 되어있으므로 Masked로 바꿔서 사용하면 된다.
메타휴먼의 마터리얼을 보면, 특정 메타휴먼 캐릭터가 사용하는 최종 머터리얼 인스턴스로부터, Common 폴더의 범용 머터리얼 인스턴스와 가장 위의 부모 머터리얼까지 올라가게 된다.
예컨대 다음은 템플릿 메타휴먼 Kai의 Torso 메쉬의 머터리얼 구조이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922195805.png" src="♣vaultstorage/attachment/pasted-image-20250922195805.png" target="_self" style="width: 600px; max-width: 100%;"><br>
<img alt="♣VaultStorage/attachment/Pasted image 20250922195808.png" src="♣vaultstorage/attachment/pasted-image-20250922195808.png" target="_self" style="width: 600px; max-width: 100%;"><br>
<img alt="♣VaultStorage/attachment/Pasted image 20250922195811.png" src="♣vaultstorage/attachment/pasted-image-20250922195811.png" target="_self" style="width: 600px; max-width: 100%;"><br><img alt="♣VaultStorage/attachment/Pasted image 20250922195813.png" src="♣vaultstorage/attachment/pasted-image-20250922195813.png" target="_self" style="width: 625px; max-width: 100%;">최상위 마터리얼 (fabric)의 끝 부분에에서 Emissive Color와 Opacity Mask를 Override하여 적용한다.얼굴 스켈레탈은 특히 사용하는 마터리얼이 많아 노가다가 고역이 된다.
걔중에는 Transcluent 모드를 사용하는 눈썹같은 머터리얼도 있으므로, 이렇게 Opacity Mask를 사용할 수 없는 경우엔 대신 Dissolve를 Opacity 0 ~ 1로 변환하는 머터리얼 함수를 대신 사용했다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922195845.png" src="♣vaultstorage/attachment/pasted-image-20250922195845.png" target="_self" style="width: 650px; max-width: 100%;">GroomComponent의 머터리얼들은 안타깝지만 아예 Opacity를 적용할 수 없다. Opacity Mask도 Opacity도 값을 무시해버린다. 이는 Hair Shader 자체가 아예 다른 구조로 되어있기 때문이다.그래서 GroomComponent의 머터리얼은 그냥 Emissive Color만 입히고(Emissive Color는 HairShader가 건드리지 않아서 기본값으로 입혀진다), 서서히 지우는 대신 적당한 타이밍에 Visibilty를 끄는 방식으로 대신했다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922195858.png" src="♣vaultstorage/attachment/pasted-image-20250922195858.png" target="_self" style="width: 500px; max-width: 100%;">( Hair Shading Model이 적용되는 모습. 뭔 짓을 해봐도 서서히 번지는 효과나, Opacity를 적용할 순 없었다.)<br>UGroomComponent 자체의 문제?
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://forums.unrealengine.com/t/groom-ignoring-emmisive-and-opacity-mask-inputs-in-material/472802/19" target="_self">https://forums.unrealengine.com/t/groom-ignoring-emmisive-and-opacity-mask-inputs-in-material/472802/19</a>
언리얼5 이전까진 UGroomComponent의 머터리얼(정확히는 HairStands 플러그인의 셰이더)은 Opacity는 커녕 Emissive Color도 적용할 수 없었다.
엔진 ini에 r.HairStands.Visibility.Emissive 1 커맨드를 입력해 실험적 기능을 켤 순 있었다.
이후 언리얼5에서 제한적인 Emissive Color 입히기가 지원된 것으로 보인다.
5월 22일자 언리얼 개발자 답변
“Hi, indeed in both Substrate &amp; Standard mode, hair strands doesn’t support opacity mask. There is no short term plan to support this at this point.”
걍 애초에 HairStandards 플러그인을 사용하는 UGroomComponent가 Opacity Mask를 지원하지 않는다고 한다.
메타휴먼 캐릭터 하나에 디졸브 효과를 입히려면 다음과 같이 수 많은 머터리얼, 머터리얼 인스턴스 편집이 필요하다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922200020.png" src="♣vaultstorage/attachment/pasted-image-20250922200020.png" target="_self" style="width: 575px; max-width: 100%;">그나마 머터리얼과 기반이 되는 머터리얼 인스턴스는 Common 폴더에 있는 범용이므로 한 번만 노가다를 해두면 다음 캐릭터부터는 그 캐릭터가 쓰는 머터리얼 인스턴스의 Parent만 바꿔주면 되긴 한다…이제 머터리얼은 준비되었으므로, 모든 타겟 머터리얼에 대해 다이나믹 머터리얼 인스턴스를 생성해 틱마다 Dissolve 파라미터의 값을 증가시켜주면 된다.
간단하게 FTimeLine객체를 통해 3초동안 0 ~ 1로 유려하게 증가하는 커브의 값을 받아 -1 ~ 1 사이의 갱신된 Dissolve값을 구해 갱신해주도록 했다.C++1// Dead Effect2public:3	FName DissolveParameterName{ TEXT("Dissolve") };4	UFUNCTION(Server, Reliable, BlueprintCallable)5	void Server_RequestToDissolvePlayer();6	void Server_RequestToDissolvePlayer_Implementation();7protected:8	UFUNCTION(NetMulticast, Reliable)9	void Multicast_StartDissolvePlayer();10	void Multicast_StartDissolvePlayer_Implementation();1112	UPROPERTY()13	TArray&lt;TObjectPtr&lt;class UMaterialInstanceDynamic&gt;&gt; DynamicMaterialsForDissolving;1415	void CreateDynamicMaterials(UMeshComponent* TargetMesh);16	bool bIsDissolving{ false };17	bool bIsDissolvingAndRemoveGrooms{ false };18	float DissolvingRomveGroomThreshold{ 0.5f };19	FTimeline DissolveTimeLine;20	UPROPERTY(EditAnywhere, Category="Dissolve")21	TObjectPtr&lt;UCurveFloat&gt; DissolveFloatCurve;22	UFUNCTION()23	void UpdateDissolveScaleOfDynamicMaterials(float Value);24	UFUNCTION()25	void OnPlayerDissolvedCompletely();C++C++1void AFHPlayerBase::Server_RequestToDissolvePlayer_Implementation()2{3	Multicast_StartDissolvePlayer();4}56void AFHPlayerBase::Multicast_StartDissolvePlayer_Implementation()7{8	DynamicMaterialsForDissolving.Empty();9	10	CreateDynamicMaterials(GetMesh());11	if (FaceMesh) CreateDynamicMaterials(FaceMesh);12	if (TorsoMesh) CreateDynamicMaterials(TorsoMesh);13	if (LegsMesh) CreateDynamicMaterials(LegsMesh);14	if (FeetMesh) CreateDynamicMaterials(FeetMesh);15	if (EyelashesGroom) CreateDynamicMaterials(EyelashesGroom);16	if (FuzzGroom) CreateDynamicMaterials(FuzzGroom);17	if (EyebrowsGroom) CreateDynamicMaterials(EyebrowsGroom);18	if (HairGroom) CreateDynamicMaterials(HairGroom);19	if (MustacheGroom) CreateDynamicMaterials(MustacheGroom);20	if (BeardGroom) CreateDynamicMaterials(BeardGroom);2122	if (DissolveFloatCurve)23	{24 FOnTimelineFloat ProgressFunction;25 ProgressFunction.BindUFunction(this, FName{"UpdateDissolveScaleOfDynamicMaterials"});2627 FOnTimelineEvent FinishedFunction;28 FinishedFunction.BindUFunction(this, FName{ "OnPlayerDissolvedCompletely"});2930 DissolveTimeLine.AddInterpFloat(DissolveFloatCurve, ProgressFunction);31 DissolveTimeLine.SetTimelineFinishedFunc(FinishedFunction);32 DissolveTimeLine.SetLooping(false);33 DissolveTimeLine.PlayFromStart();34 // TimeLineLength는 커브의 마지막 키까지로 자동 설정 된다고 함.3536 bIsDissolving = true;37	}38}3940void AFHPlayerBase::CreateDynamicMaterials(UMeshComponent* TargetMesh)41{42	int32 num = TargetMesh-&gt;GetNumMaterials();43	for (int i = 0; i &lt; num; ++i)44	{45 if (TargetMesh-&gt;GetMaterial(i) == nullptr)46 {47 continue;48 }4950 TArray&lt;FMaterialParameterInfo&gt; params;51 TArray&lt;FGuid&gt; guids;52 TargetMesh-&gt;GetMaterial(i)-&gt;GetAllScalarParameterInfo(params, guids);53 for (FMaterialParameterInfo&amp; param : params)54 {55 if (param.Name == DissolveParameterName)56 {57 DynamicMaterialsForDissolving.Add(TargetMesh-&gt;CreateDynamicMaterialInstance(i, TargetMesh-&gt;GetMaterial(i)));58 break;59 }60 }61	}62}6364void AFHPlayerBase::UpdateDissolveScaleOfDynamicMaterials(float Value)65{66	float NewScale = FMath::Lerp(-1.0f, 1.0f, Value);6768	if (bIsDissolvingAndRemoveGrooms == false &amp;&amp; NewScale &gt; DissolvingRomveGroomThreshold)69	{70 if (EyelashesGroom)71 {72 EyelashesGroom-&gt;SetVisibility(false);73 EyelashesGroom-&gt;SetCastShadow(false);74 }75 if (FuzzGroom)76 {77 FuzzGroom-&gt;SetVisibility(false);78 FuzzGroom-&gt;SetCastShadow(false);79 }80 if (EyebrowsGroom)81 {82 EyebrowsGroom-&gt;SetVisibility(false);83 EyebrowsGroom-&gt;SetCastShadow(false);84 }85 if (HairGroom)86 {87 HairGroom-&gt;SetVisibility(false);88 HairGroom-&gt;SetCastShadow(false);89 }90 if (MustacheGroom)91 {92 MustacheGroom-&gt;SetVisibility(false);93 MustacheGroom-&gt;SetCastShadow(false);94 }95 if (BeardGroom)96 {97 BeardGroom-&gt;SetVisibility(false);98 BeardGroom-&gt;SetCastShadow(false);99 }100101 bIsDissolvingAndRemoveGrooms = true;102	}103104	for (TObjectPtr&lt;class UMaterialInstanceDynamic&gt; mat : DynamicMaterialsForDissolving)105	{106 mat-&gt;SetScalarParameterValue(DissolveParameterName, NewScale);107	}108}109110void AFHPlayerBase::OnPlayerDissolvedCompletely()111{112	PRINT_LOG(TEXT("Player dead..."));113}114C++]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메타휴먼에-dissolving-이펙트-입히기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메타휴먼에 Dissolving 이펙트 입히기.md</guid><pubDate>Tue, 23 Sep 2025 13:03:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[메쉬 위에 비디오 재생하기]]></title><description><![CDATA[언리얼 공식 문서
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://dev.epicgames.com/documentation/en-us/unreal-engine/play-a-video-file-in-unreal-engine" target="_self">https://dev.epicgames.com/documentation/en-us/unreal-engine/play-a-video-file-in-unreal-engine</a>
비디오를 재생하는 TV 액터를 만들어보자비디오의 경우 언리얼 에셋으로 저장하기엔 용량이 너무 크기 때문에, 원본 파일을 Content/Movies 경로에 저장하고, FileMediaSource 에셋에서 해당 경로를 상대 경로로 참조하여 사용하게 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922194246.png" src="♣vaultstorage/attachment/pasted-image-20250922194246.png" target="_self" style="width: 138px; max-width: 100%;">Content/Movies 경로에 넣어둔 비디오 파일을 드래그하거나 Import하여 FileMediaSource 에셋을 생성한다.이제 Media Player 에셋을 생성한다. 이 때 우리는 비디오를 메쉬의 마테리얼로 재생할 것이므로 output MediaTexture asset 플래그에 체크한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922194254.png" src="♣vaultstorage/attachment/pasted-image-20250922194254.png" target="_self" style="width: 375px; max-width: 100%;"><br><img alt="♣VaultStorage/attachment/Pasted image 20250922194259.png" src="♣vaultstorage/attachment/pasted-image-20250922194259.png" target="_self" style="width: 240px; max-width: 100%;">MediaTexture 에셋이 함께 생성된 모습. 렌더 타겟처럼 자동으로 바인딩된 Media Player의 현재 프레임을 인화해준다.이제 Media Texture 에셋을 베이스 컬러로 사용하는 머터리얼을 만들자. 그냥 Media Texture 에셋을 메쉬에 드래그하면 알아서 기본형으로 만들어준다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922194306.png" src="♣vaultstorage/attachment/pasted-image-20250922194306.png" target="_self" style="width: 325px; max-width: 100%;">에셋은 모두 준비되었다. 이제 TV 액터를 만들어보자.기본적으로 메쉬에 입혀지는 머터리얼을 통해 실시간으로 인화되는 ‘화면’을 출력할 것이고, 소리는 UAudioComponent를 상속하는 UMediaSound 컴포넌트를 통해 재생할 것이다.
재생할 UMediaPlayer 오브젝트 포인터를 변수로 받는다.
Plane 메쉬를 추가하고 Set Material로 UMediaTexture를 인화하는 마터리얼을 지정한다.
UMediaSound 컴포넌트를 추가하고, SetMediaPlayer 함수로 타겟을 지정한다.
UMediaPlayer::OpenSource 함수로 FileMediaSource를 지정하여 재생한다. (FileMediaSource에 Play on Open이 체크되어 있다면 자동 재생, 아니면 재생 함수 호출 필요)
<br><img alt="♣VaultStorage/attachment/Pasted image 20250922194316.png" src="♣vaultstorage/attachment/pasted-image-20250922194316.png" target="_self" style="width: 350px; max-width: 100%;">구현된 모습대충 이런 식으로 작동하게 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922194323.png" src="♣vaultstorage/attachment/pasted-image-20250922194323.png" target="_self" style="width: 650px; max-width: 100%;">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/메쉬-위에-비디오-재생하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/메쉬 위에 비디오 재생하기.md</guid><pubDate>Tue, 23 Sep 2025 13:03:50 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[동적 생성 미니맵]]></title><description><![CDATA[던전이 동적으로 생성되므로 미니맵도 그에 맞춰 동적으로 만들어져야 한다.
여기에 완성된 미니맵 움짤 올리기
최초로 시도한 방식은 룸들을 각각의 UImage 위젯들로 표현하는 방식이었다. 룸의 크기, 위치는 알고 있으므로 그에 맞추어 생성한 UImage의 사이즈와 위치를 조절하고
각 층을 담당하게 될 CanvasPanel에 부착하여 층이 변경될 때 해당 층의 CanvasPanel을 보여주는 방식이다.그러나 이 방법은 방문하지 않은 룸을 가려놓는다던가, 문으로 연결된 부분을 뚫는다던가, 방문하지 않은 룸들을 하나로 합친 뒤 아웃라인을 입힌다던가 하는 효과를 적용하기 곤란했다.
이에 방식을 렌더 타겟 텍스쳐에 실시간으로 렌더링하는 방식으로 바꾸게 되었다.원리는 다르지 않지만 UImage 위젯을 캔버스에 올려놓고 그 캔버스의 Translation을 옮기는 방식에서, 실시간으로 계산된 위치에 룸 사각형을 그려넣는 방식으로 변경했다.
영상이 너무 큼, GIF로 대체?
위젯 방식의 미니맵은 그냥 룸을 나타내는 UImage의 색을 바꾸거나 Opacity를 조절하는 식으로 구현할 수 있지만, 렌더링 방식은 미니맵에 그려지는 각 룸들의 상태를 구분할 수 없기 때문에 픽셀의 색상값으로 이를 표현해야 한다.
그래서 다음과 같은 규칙을 세웠다.
미니맵 텍스쳐의 R은 룸이 밝혀졌는지의 여부, 그리고 밝혀진 룸들을 구분하기 위한 값으로 사용된다. R 1.0은 밝혀지지 않은 방으로, 내부 구조를 외곽선으로 그려내지 않는다.
R 1.0 미만은 밝혀진 방들이 가지는 값으로, 각 방마다 미세하게 다른 R 값을 가지므로 아웃라인 체크에서 R값의 차이가 있다면 아웃라인을 그리는 방식으로 방을 구분하고, 내부 구조를 아웃라인으로 그려낼 수 있다. 미니맵 텍스쳐의 G는 반드시 외곽선이 그려지지 않는 영역(ex. 문)을 그리기 위해 사용된다. G 1.0은 방을 연결하는 문이 있는 영역으로, 이 영역엔 아웃라인을 그리지 않는다. <img alt="♣VaultStorage/attachment/Pasted image 20250812205237.png" src="♣vaultstorage/attachment/pasted-image-20250812205237.png" target="_self" style="width: 200px; max-width: 100%;"> <img alt="♣VaultStorage/attachment/Pasted image 20250812205240.png" src="♣vaultstorage/attachment/pasted-image-20250812205240.png" target="_self" style="width: 196px; max-width: 100%;">이러한 규칙을 적용하여 그려진 미니맵 텍스쳐(좌)와 해당 텍스쳐를 기반으로 내부를 채우고 아웃라인을 그려내는 머터리얼을 거친 결과(우)이다.던전에는 층계가 있기 때문에 미니맵도 이를 구분해야 한다. 던전을 이루는 룸들은 각각 고유한 높이를 가지고 있으며, 각각 고유한 층을 '최저층'으로 삼아 배치된다.
또, 각 룸은 DungeonGridUnit 단위로 나뉘는 DungeonGrid 내에 특정한 크기를 가지게 되므로 DugeonGenerator를 기준으로 만들어진 Grid 공간 상에서 층을 구분지으면 된다.
이를 시각화해보면 아래와 같다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205259.png" src="♣vaultstorage/attachment/pasted-image-20250812205259.png" target="_self" style="width: 600px; max-width: 100%;">룸은 특정한 높이(층수)를 가지게 되는데, 모든 층에서 해당 룸을 그릴 필요는 없다. 최저층에만 진입할 수 있는 문이 있고 그저 천장이 높을 뿐인 맵이라면, 룸의 최저층을 제외하고 그 위 층에서는 해당 룸을 그리지 않는 것이 더 깔끔하다.
이는 룸 텍스쳐 배열을 통해 구현했다. 예컨대 높이가 4인 룸이라면 룸 텍스쳐 배열은 총 4개의 요소를 가질 수 있으며, 인덱스가 룸의 각 층을 의미한다. 따라서 텍스쳐가 있는 인덱스에 해당하는 높이에선 해당 텍스쳐를 사용해 그리고, 없다면 그리지 않으면 된다.룸과 비슷하지만 절차는 조금 더 까다롭다. 룸에 달려있는 문의 목록은 상수이지만 연결이 불가능한 경우 벽 액터를 스폰하게 되며, 각 문의 위치는 RoomGridPosition으로 정의된다.
따라서 벽 액터가 스폰된 경우엔 넘어가고, 문의 위치를 WorldAbsoluteFloor로 변환하여 현재 플레이어가 있는 층과 같은 층인지 체크하는 과정이 필요하다.다소 헷갈리지만 계산식이 어렵지는 않다. 문의 룸 내의 GridPositionZ를 LD, 룸의 최소 GridPositionZ를 LR, 룸의 최소 WorldAbsoluteFloor를 WR이라고 할 때
문의 WorldAbsoluteFloor는 이다.미니맵 아이콘들(계단 룸이라는 표시, 다른 플레이어, 코어 오브젝트 등등)은 미니맵 위젯의 UImage들로 그려지기 때문에 이전에 위젯 방식의 미니맵을 구현하면서 각 층을 CanvasPanel로 나타내던 것을 그대로 사용하면 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205311.png" src="♣vaultstorage/attachment/pasted-image-20250812205311.png" target="_self" style="width: 350px; max-width: 100%;">텍스쳐 샘플링 방식으로 인한 테두리 번짐으로 인해 위와 같이 Pixel-Perfect하게 그려지지 않아 매우 지저분해 보였다.
여러 방법을 시도해본 결과 텍스쳐 LOD를 끄고 TextureGroup을 Unfiltered 2D Pixel로 변경하는 것이 해법이었다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205314.png" src="♣vaultstorage/attachment/pasted-image-20250812205314.png" target="_self">근데 이렇게 설정을 해도 간혹 1~2 픽셀 굵기의 선이 엉뚱한 곳에 그려지곤 했는데, 이는 텍스쳐 타일링 메서드 문제였다. 타일링 메서드가 Wrap으로 되어있어 오프셋 오차로 UV가 0-1 범위를 초과하면 반대편의 색이 그려진 것. Clamp로 바꿔주니 해결됐다.로직상으론 문제가 없었으나 RenderTarget에 그려진 미니맵과 그 위에 붙은 아이콘들의 이동 속도에 오차가 발생하는 문제가 있었다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205316.png" src="♣vaultstorage/attachment/pasted-image-20250812205316.png" target="_self">(빨간 아이콘 UImage는 플레이어의 이동 결과 분홍색 원 위치에 있어야 하지만, 엉뚱한 속도로 이동한다.)코드상으론 문제가 없어서 찾느가 고생을 좀 했다. 위치에 ScaleMult를 곱하는 대신 속도가 같아지는 매직넘버를 찾은 결과 약 0.3이었는데,
이 값은 미니맵축척(0.1) x 미니맵위젯사이즈(600) / 미니맵렌더타겟사이즈(200)과 같았다.미니맵이 그려지는 렌더 타겟과 이를 위젯에 그리는 UImage 위젯의 사이즈를 통일시키자 문제가 사라졌다. 찾아낸 원인은 아래와 같다.
RenderTarget에 룸 텍스쳐를 그릴 땐 RenderTarget의 사이즈를 단순히 (축척 x 월드사이즈)로 취급하고 그린다. 예컨대 RenderTarget의 사이즈가 200x200이고 축척이 1/10이라면 RenderTarget은 중심을 (0, 0)으로 2000x2000의 월드 공간을 커버하는 것.
그런데 그걸 미니맵 위젯에선 RenderTarget의 크기보다 3배 큰 600x600 짜리 UImage에 올렸다. 이러고선 UpdateMinimapPosition에서 3배 커진 것을 고려하지 않고 (-PlayerPosition x 축척)으로 계산하게 되니까 실제로는 1/3만큼 덜 이동한 셈이 된다.
렌더 타겟과 위젯 사이즈를 통일시키거나, ScaleMult x 위젯크기 / 렌더타겟크기를 곱해주면 된다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/동적-생성-미니맵.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/동적 생성 미니맵.md</guid><pubDate>Tue, 23 Sep 2025 13:03:48 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[함수와 객체의 노출을 제한하기]]></title><description><![CDATA[함수와 객체를 외부로 노출시켜도 되는지, 노출시켜야 하는지 판단하는 것은 설계에 있어 매우 중요하다.꼭 필요한 게 아니라면 일단 숨겨놓는 것을 기본으로 삼는 것이 맞다. 사용자는 언제 어느 때 어떤 행동을 취할 지 누구도 알 수 없으므로, 최대한 숨기고 접근하지 못 하게 만들어 예외 상황을 원천 차단하는 것이 좋은 설계다.C++ 기준이다.노출되지 않아야 하는 멤버는 private 접근 지정자를 통해 은닉한다.네임스페이스를 활용하면 접근 난이도를 높혀 일반 사용자의 접근을 차단할 수 있다.C++1// 코어 개발자만 사용하는 네임 스페이스로 감싸는 예시2// 네임스페이스를 명시하고 접근해야 하므로 접근 난도가 높아지고, 자연히 일반 사용자의 접근을 막을 수 있다.3namespace Engine4{5	void DoSomething();6}789// 익명 네임스페이스(Anonymous namespace)를 사용하는 방식10// 익명 네임스페이스는 그것이 포함된 목적파일 단위로, 그 목적파일 안에서만 접근할 수 있는 변수와 함수를 선언한다. 이걸 소스파일에서 선언하면 해당 소스 파일 안에만 존재하는 선언이 되므로 외부에서 접근할 수 없다.11namespace12{13	void DoSomething();14}C++전역적으로 선언된 static 변수나 함수는 그것이 포함된 목적파일 단위로, 그 목적파일 안에서만 접근할 수 있게(파일 스코프로 종속) 된다. 따라서 익명 네임스페이스처럼 소스 파일 안에서 선언하면 해당 목적 파일 안에만 존재하는 선언이 되므로 외부에서 접근할 수 없다.이를 'Internal linkage'를 가진다고 말한다. Internal linkage를 가지는 요소는 심볼이 해당 목적 파일 안에서만 존재하게 되며 외부에서 extern 키워드 등으로 심볼을 찾을 수 없다.]]></description><link>0-발행완료/프로그래밍-일반/설계-방법론/함수와-객체의-노출을-제한하기.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계 방법론/함수와 객체의 노출을 제한하기.md</guid><pubDate>Tue, 23 Sep 2025 13:03:39 GMT</pubDate></item><item><title><![CDATA[의존성 역전 (Dependency Inversion Principle)]]></title><description><![CDATA[객체지향의 5대 원칙인 SOLID 원칙 중 D에 해당한다. 또한 "수정은 어렵게, 확장은 쉽게" 설계해야 한다는 개방-폐쇄 원칙을 가장 쉽게 구현할 수 있는 방법이기도 하다.<img alt="♣VaultStorage/attachment/Pasted image 20250419132354.png" src="♣vaultstorage/attachment/pasted-image-20250419132354.png" target="_self">개발자스럽게 표현하면 "고수준(High-level) 모듈이 저수준(Low-level) 모듈에 직접 의존하지 않게 한다"고 말한다.
고수준, 저수준 모듈은 일반적으로 말하는 그 하이-레벨, 로우-레벨의 의미가 맞다. 로우-레벨은 어플리케이션의 밑단에서 구체적인 기능과 로직을 구현하는 것이고, 하이-레벨은 보다 추상화되고 사용자에게 노출될 가능성이 큰 것이다.더 쉽게 말하면 다른 모듈을 참조할 때 직접 참조하지 말고 인터페이스같은 추상화 레이어를 하나 끼고서 참조하라는 것이다. 이로 인한 장점을 나열해보자면 다음과 같다.
만약 인터페이스를 통해 추상화하지 않는다면, 저수준 모듈이 변했을 때 그걸 사용하던 고수준 모듈의 로직도 변해야 할 수 있다.
반면 인터페이스를 통해 추상화하고 인터페이스의 명세가 약속한 대로 저수준 모듈이 기능을 제공해주기만 한다면, 고수준 모듈은 저수준 모듈이 어떻게 변하던 신경을 쓸 필요가 없다. 인터페이스를 통해 기능 단위로 잘 분리된 함수들만 제공받을 수 있으면 된다.
여러 종류의 저수준 모듈이 있어도 같은 인터페이스를 상속하기만 하면 고수준 모듈에선 쉽게 교체하여 사용할 수 있다. 이는 런타임에도 가능하므로 아주 강력한 장점이 된다.
테스트나 디버깅을 할 땐 테스트용 Mock 객체를 끼워서 사용해보면 된다. 이런 유연한 구조로 시간, 비용이 절약된다.
]]></description><link>0-발행완료/프로그래밍-일반/설계-방법론/의존성-역전-(dependency-inversion-principle).html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계 방법론/의존성 역전 (Dependency Inversion Principle).md</guid><pubDate>Tue, 23 Sep 2025 13:03:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[서비스 로케이터 패턴 (Service locator pattern)]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250419151747.png" src="♣vaultstorage/attachment/pasted-image-20250419151747.png" target="_self">여러 기능들을 '서비스 로케이터'라는 전역 클래스를 통해 관리하고 제공하는 디자인 패턴.
각각의 기능을 제공하는 객체들을 서비스라고 부르며, 서비스 로케이터에 타입 또는 이름으로 서비스 객체를 등록하고, 필요한 곳에서 이를 요청하여 받아 사용하는 것이 골자이다.개념도 간단하고 구현하기도 쉽다. 다만 구체적인 구현 방식은 하기 나름이라 매우 다양한 형태로 나타날 수 있다.이 패턴을 사용하는 목적은 기본적으로 객체 간 의존성을 최소화하고, 생명주기의 관리마저 서비스 로케이터를 통해 쉽게 수행하는 것에 있다.
의존성을 줄이기 위한 방법론이란 점에서 의존성 주입 패턴과 자주 비교된다. 결론만 말해 서비스 로케이터 패턴은 의존성 주입 패턴보다 당장 구현하기는 더 쉽고 직관적이나, 의존성을 명확하게 드러내는 데는 의존성 주입 패턴이 나아서 확장과 유지보수에는 불리하다. 후술하겠지만 이 때문에 서비스 로케이터 패턴은 오히려 사용을 지양해야 하는 '안티 패턴'이며, 대안으로 의존성 주입 패턴을 사용해야 한다고 주장하는 사람도 있다.혹자는 서비스 로케이터 패턴은 사용하기는 커녕 오히려 지양해야 하는 Anti-Pattern이라고 말한다.
이유는 서비스 로케이터가 서비스를 제공해주는 형태 자체가 '내가 무슨 서비스를 사용(의존)하는 지' 명확하게 알 수 없게 만든다는 것이다. 이는 특히 협업을 할 때, 외부 라이브러리를 사용할 때 두드러지는 문제다.예를 들어, 라면을 끓이고 싶다고 하자. 라면을 끓이려면 물과 냄비가 필요하다. 그렇다면 라면을 끓이는 주체인 RamenChef는 다음과 같이 설계하면 될 것이다.C++1class RamenChef2{3	Pot pot;4	Water water;5public:6	void Cook()7	{8 // pot과 water를 사용해 라면을 끓인다.9	}10};C++이 코드는 아주 단순한 형태로 개방-폐쇄 원칙을 따르지 않고 있다. 단순히 다른 객체를 has-a 관계로 포함하고 있으니 Pot이나 Water가 수정되면 영향을 받게 되는 '나쁜 설계'에 해당한다.
하지만 이런 나쁜 설계조차도, 라면을 끓이기 위해선 Pot과 Water를 써야 한다는 사실만큼은 직관적으로 보여준다. 즉, 코드만 보고 '종속성을 명확히 알 수 있다'는 것이다.하지만 서비스 로케이터처럼 외부에서 객체를 요구하는 방식을 사용한다고 해보자.C++1class Kitchen2{3	static Pot pot;4	static Water water;5public:6	static Pot* GetPot() { return &amp;pot; }7	static Water* GetWater() { return &amp;water; }8};91011class RamenChef12{13public:14	void Cook()15	{16 Pot* pot = Kitchen::GetPot();17 Water* water = Kitchen::GetWater();18 // pot과 water를 사용해 라면을 끓인다.19	}20}C++이 코드는 다음과 같은 문제를 가진다.
RamenChef의 작동 원리를 모르는 사람은 라면을 끓이기 위해 Pot과 Water가 필요하다는 사실을 알기가 쉽지 않다. 이 사람들이 보기에 이 코드는 "자기도 모르게 누군가 주방에서 냄비와 물을 은글슬쩍 가져오는" 것처럼 보일 것이다.
서비스 로케이터의 입장에서도, 어떤 클래스가 어떤 서비스를 사용하고 있는지 알 방법이 없다. 서비스들은 각각의 독립된 기능을 수행하므로 어떤 클래스가 어떤 서비스를 사용하는 지는 몰라도 상관없다고 말할 수 있지만, 의존성이 아예 없는 코드를 짜는 건 너무 힘들기 때문에 언제 문제가 생길지 알 수 없다.
따라서 서비스 로케이터 패턴을 지양해야 한다고 말하는 사람들은 의존성 주입 패턴을 그 대안으로 사용할 것을 권고한다. 의존성 주입 패턴은 명확하게 필요한 객체를 인자 타입으로 요구하기 때문에 노출된 함수만 사용하는 외부자가 보기에도 어떤 객체에 의존하는 지가 아주 명확하게 드러난다.]]></description><link>0-발행완료/프로그래밍-일반/설계-방법론/서비스-로케이터-패턴-(service-locator-pattern).html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/설계 방법론/서비스 로케이터 패턴 (Service locator pattern).md</guid><pubDate>Tue, 23 Sep 2025 13:03:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[API, SDK란]]></title><description><![CDATA[Interface라는 표현대로 어떤 기능이나 서비스를 쉽게 이용할 수 있게 제공(노출)해주는 도구이다.
'쉽게 이용한다'는 말은 곧 내부에서, 또는 요청된 서비스를 처리하는 곳에서 무슨 일이 일어나는 지는 몰라도 되도록 해준다는 것.예를 들어, Win32API는 윈도우즈 OS의 다양한 기능을 쉽게 사용하도록 노출해주는 함수들을 제공하고, 그래픽스 API인 DirectX는 GPU 디바이스를 대신 관리하고 렌더링 작업을 수행해주며, 구글맵 API는 구글 서버와 연결하여 구글 맵을 통해 위치 기반 서비스를 구축할 수 있게 지원해준다.API 중 특히 일반에 무료로 사용할 수 있도록 공개된 것을 Open API라고 부른다.소프트웨어 개발에 필요한 도구들을 모아서 제공하는 키트.
소프트웨어 개발을 위한 편리한 기능들을 제공해주므로 일반적으론 그 자체로 API의 역할을 수행한다. 거기에 별도의 툴이나 문서 등을 제공하기도 하므로, API보다 광의의 개념이라고 할 수 있겠다.Android SDK나 iOS SDK 같이 자기들의 운영체제에서 돌아가는 소프트웨어를 만들라고 제공해주는 함수, 라이브러리, 툴킷들이 대표적이다.]]></description><link>0-발행완료/프로그래밍-일반/개발-상식/api,-sdk란.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/개발 상식/API, SDK란.md</guid><pubDate>Tue, 23 Sep 2025 13:03:30 GMT</pubDate></item><item><title><![CDATA[기호 파일(Symbol file)이란]]></title><description><![CDATA[빌드된 코드에 대한 디버깅 정보가 담긴 파일. Visual Studio IDE를 사용하는 경우 .pdb(ProgramDataBase) 확장자로 생성되는 것을 본 적이 있을 것이다.그 안에는 기호(Symbol) 정보라고 부르는 함수의 서명, 변수의 이름 등과 해당 코드가 몇 번째 라인에 있는 지 등의 정보가 담겨있다. (쉽게 생각해서, 소스 코드와 기계어로 번역된 코드를 연결시켜준다고 할 수 있다.)
기호 파일이 없으면 IDE에서 디버깅을 할 때 콜스택에 함수 이름이 아닌 주소가 찍힌다거나, 브레이크 포인트를 제대로 걸 수 없다거나 한다고 한다.문제는 내가 작성한 코드는 IDE가 자동으로 기호 파일을 생성해준다지만, DLL 형태로 제공되는 외부 라이브러리의 기호 파일은 생성할 방법이 없다는 것이다.
그래서 라이브러리의 제작사에서 기호 파일을 받아와야 한다. VS에서 Debug - Options - Debugging - Symbols 메뉴에서 기호 파일을 어디서 받아올 지 고르는 게 이것이다.<img alt="♣VaultStorage/attachment/Pasted image 20240529132015.png" src="♣vaultstorage/attachment/pasted-image-20240529132015.png" target="_self">언리얼에서도 기호 파일(30GB가 넘는다)을 받는 것이 중요하다. 모듈들이 전부 DLL로 제공되기 때문이다.]]></description><link>0-발행완료/프로그래밍-일반/개발-상식/기호-파일(symbol-file)이란.html</link><guid isPermaLink="false">0 발행완료/프로그래밍 일반/개발 상식/기호 파일(Symbol file)이란.md</guid><pubDate>Tue, 23 Sep 2025 13:03:28 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[메모리 디버깅]]></title><description><![CDATA[Visual Studio에서 메모리 상태를 보는 방법을 알아보자.
디버깅(F5) 상태에서 상단의 Debug -&gt; Windows 탭을 열면 다양한 디버그용 창 메뉴가 추가되어 있다.<img alt="♣VaultStorage/attachment/Pasted image 20240531183000.png" src="♣vaultstorage/attachment/pasted-image-20240531183000.png" target="_self" style="width: 450px; max-width: 100%;">여기서 Memory 창을 열자. 실제 메모리의 상태를 볼 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20240531183016.png" src="♣vaultstorage/attachment/pasted-image-20240531183016.png" target="_self">상단의 주소 창에 변수의 주소(16진수 주소를 그대로 입력하거나, 주소 연산자&amp;를 써도 된다)를 입력하면<br><img alt="♣VaultStorage/attachment/Pasted image 20240531183030.png" src="♣vaultstorage/attachment/pasted-image-20240531183030.png" target="_self">해당 주소로 이동하게 되며, 값의 변화를 추적할 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20240531183049.png" src="♣vaultstorage/attachment/pasted-image-20240531183049.png" target="_self">CPU가 리틀 엔디안이라 가장 앞에 있는 바이트부터 채워진 모습이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20240531183111.png" src="♣vaultstorage/attachment/pasted-image-20240531183111.png" target="_self">INT 최대값(2,147,483,647)을 넣으니 0x7fffffff로 갱신된 모습.]]></description><link>0-발행완료/툴과-api/visual-studio/메모리-디버깅.html</link><guid isPermaLink="false">0 발행완료/툴과 API/Visual Studio/메모리 디버깅.md</guid><pubDate>Tue, 23 Sep 2025 13:03:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SVN to Git Revision Migrate]]></title><description><![CDATA[깃은 SVN 저장소를 깃 저장소로 변환하여 클론하는 기능을 제공한다.
깃을 설치하고 다음 커맨드를 입력한다.git svn clone {SVN 저장소 경로} [클론 경로]예컨대 SVN 저장소의 주소가 https://mysvn.repo/이고, 커맨드창의 현재 경로에 바로 클론하고 싶다면git svn clone https://mysvn.repo/ 라고만 적으면 된다.SVN 저장소가 SVN의 전형적인 구조, trunk, branch, tag로 나뉘어져 있다면 다음과 같이 각각 구분하여 클론할 수 있다.git svn clone {SVN 루트} [클론 경로] [-T {SVN trunk 경로}] [-t {SVN tag 경로}] [-b {SVN branch 경로}]예시는 다음과 같다.git svn clone https://mysvn.repo/ SomeDirectory -T https://mysvn.repo/trunk/ -t https://mysvn.repo/tags/ -b https://mysvn.repo/branches/커맨드를 입력하면 깃이 SVN 저장소의 리비전을 깃 히스토리로 변환하며 복사를 수행한다.
상당 시간이 소요되며, 최초로 시도할 경우 SVN의 권한 설정에 따라 유저 이름과 비밀번호를 요구할 수 있다.<img alt="♣VaultStorage/attachment/스크린샷 2025-06-05 222856.png" src="♣vaultstorage/attachment/스크린샷-2025-06-05-222856.png" target="_self">생성된 깃 저장소를 Github Desktop에 추가하고 커밋 히스토리를 본 결과
모든 SVN 커밋들이 깃 커밋으로 잘 변환된 것을 볼 수 있다.<br><img alt="♣VaultStorage/attachment/스크린샷 2025-06-05 224034.png" src="♣vaultstorage/attachment/스크린샷-2025-06-05-224034.png" target="_self">보다 자세한 내용은 공식 문서를 참고하자.<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://git-scm.com/docs/git-svn" target="_self">https://git-scm.com/docs/git-svn</a>
SVN 저장소의 모든 기록을 추적하기 위해선 보다 까다로운 작업이 필요하며, 다음 문서에서 자세하게 설명한다.<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://git-scm.com/book/en/v2/Git-and-Other-Systems-Migrating-to-Git" target="_self">https://git-scm.com/book/en/v2/Git-and-Other-Systems-Migrating-to-Git</a>]]></description><link>0-발행완료/툴과-api/svn/svn-to-git-revision-migrate.html</link><guid isPermaLink="false">0 발행완료/툴과 API/SVN/SVN to Git Revision Migrate.md</guid><pubDate>Tue, 23 Sep 2025 13:03:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Github.io 블로그 개설하기]]></title><description><![CDATA[프론트엔드 지식이 없는 사람이 처음부터 페이지를 만들기는 어렵다.
Ruby 기반의 설치형 블로그 생성기인 Jekyll을 활용하는게 일반적이다. 깃허브 페이지와 호환성도 매우 좋다. 여기서 하나를 선택하자.
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/topics/jekyll-theme" target="_self">https://github.com/topics/jekyll-theme</a>여기서 아무 테마나 선택하고 Fork를 눌러 내 깃허브 계정으로 복사한다.
이 때 레포지토리 이름은 다음의 양식으로 설정한다.
{깃허브계정명}.github.io_config.yml 파일에 들어가서 Edit This File 버튼을 눌러 수정 모드로 들어간다.
여기서 블로그에 들어갈 다양한 Configuration들을 설정해야 한다.가장 중요한 건 url 프로퍼티다. 주석을 지우고 다음의 양식으로 입력한다.
"https://{계정명}.github.io"그 외에도 페이지의 이름을 지정하는 title, 팝업 설명창에 적히는 description 등을 설정하자.
말고도 다양한 프로퍼티들이 있을 것이다. 테마의 구성에 따라 블로그 주인의 이름, 사진, 이메일, SNS 링크 등을 여기서 쓰면 알아서 띄워주도록 되어있기도 하다.jekyll 테마는 _posts 폴더 안에 게시물을 업로드하도록 되어있다.
만약 만들어져있지 않다면 최상단 경로에 _posts 폴더를 직접 추가하자.게시물 파일의 제목 양식은 다음과 같다.
{년-월-일}-{요약제목}.md예컨대, 2025년 3월 23일에 바난에 관한 게시물을 올리고 싶다면
2025-03-23-banana.md 로 짓는다.여기서 지정한 이름이 github.io/ 뒤에 붙는 게시물의 주소가 된다.jekyll 테마에 포스트를 올리기 위해선 규칙에 따라 포스트의 규격을 만든 뒤, 마크다운 문법을 사용한다.
자세한 내용은 다음을 참고하자
jekyllrb.com/docs/posts/
레이아웃과 타이틀 메타데이터를 최상단에 넣는다.
Markdown1---2layout: post3title: "Hello, World!"4---Markdown이미지는 images 폴더 안에 이미지를 넣고, 그 경로를 마크다운 문법으로 가져와서 출력해야 한다.
이런 방법은 너무 불편하기 때문에, 다음 챕터로 넘어가도록 하자.심플한 마크다운 문서 편집기. 깃 경로의 md 파일을 바로바로 편집할 수 있다.
또 좋은 점은 이미지 업로드를 자동화해준다는 것, jekyll 최상단 메타데이터에 다음 내용을 추가하고 이미지를 드래그해서 문서에 첨부하면, 자동으로 해당 경로에 이미지 파일을 복사해준다.Markdown1---2(생략)3typora-copy-images-to: ..\images\2025-03-234---Markdown]]></description><link>0-발행완료/툴과-api/git,-github/github.io-블로그-개설하기.html</link><guid isPermaLink="false">0 발행완료/툴과 API/Git, Github/Github.io 블로그 개설하기.md</guid><pubDate>Tue, 23 Sep 2025 13:03:20 GMT</pubDate></item><item><title><![CDATA[Doxygen, 자동 문서 생성 툴]]></title><description><![CDATA[Doxygen은 C/C++을 사용할 때 주석으로 이용해 자동으로 문서를 생성하는 도구이다.C/C++ 기본 여러 줄 주석이 /*로 시작해 */로 끝나며, 그 안에 있는 라인에는 별도의 기호를 표시하지 않는 것과 달리, Doxygen 주석은 /** 로 시작해 */로 끝나며, 그 안에 있는 라인은 * 기호로 시작한다.또, 주석을 설명하기 위한 다양한 태그를 지원한다. (@로 시작)C++1/**2 * Simple Text3 * @return description about return4 */C++Doxygen은 이런 형식의 주석을 인식하여 알아서 클래스와 함수에 대한 document를 생성해준다.Visual Studio IDE에는 기본적으로 Doxygen 툴이 깔려있는 건 아니지만 IntelliSense가 Doxygen 스타일 주석과 태그의 자동완성을 지원한다.C++1/**2 * @brief 간단한 설명3 * @details 자세한 설명4 * @author 작성자/저작권자5 * @date 날짜6 * @version 버전7 */C++Doxygen으로 문서를 생성하면 이런 모양이 된다.<img alt="♣VaultStorage/attachment/Pasted image 20250315172621.png" src="♣vaultstorage/attachment/pasted-image-20250315172621.png" target="_self" style="width: 204px; max-width: 100%;">C++1/**2 * @brief 간단한 설명3 * @details 자세한 설명4 * @param 인자에 대한 설명5 * @param (일반적으로 줄마다 인자 하나씩 적는다.)6 * @return 반환에 대한 설명7 * @throws 발생 예외에 대한 설명8 */C++<br><img alt="♣VaultStorage/attachment/Pasted image 20250315172651.png" src="♣vaultstorage/attachment/pasted-image-20250315172651.png" target="_self" style="width: 312px; max-width: 100%;">C++1/**2 * @todo 해야 할 일 기록용3 * @bug 버그에 대한 설명4 * @see 비고란. See also.5 * @n 주석 내에서 개행6 */C++Doxygen 문서에 표 만들기C++1/**2 * First Header | Second Header3 * ------------- | -------------4 * Content Cell | Content Cell5 * Content Cell | Content Cell6 */C++리스트 만들기C++1/**2 * @li element13 * @li element24 */C++하이퍼링크 만들기C++1/**2 * [텍스트][링크주소]3 */C++코드 블록C++1/**2 * @code{.cpp}3 * printf("Hello, World!");4 * @endcode5 */C++클래스 참조 링크 (Doxygen으로 문서화된 클래스여야 링크 주소 생성됨)C++1/**2 * @ref 클래스이름 (네임스페이스 아래에 있는 경우 네임스페이스.클래스명)3 * @ref Util.Structure.Vector34 */C++]]></description><link>0-발행완료/툴과-api/기타/doxygen,-자동-문서-생성-툴.html</link><guid isPermaLink="false">0 발행완료/툴과 API/기타/Doxygen, 자동 문서 생성 툴.md</guid><pubDate>Tue, 23 Sep 2025 13:03:16 GMT</pubDate></item><item><title><![CDATA[리틀 엔디안, 빅 엔디안]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20240601001555.png" src="♣vaultstorage/attachment/pasted-image-20240601001555.png" target="_self">컴퓨터가 메모리에 데이터를 저장하는 방식.
위 그림과 같이 4바이트 데이터 0x01020304가 있을 때,
빅 엔디안은 01, 02, 03, 04 순으로 저장하고,
리틀 엔디안은 04, 03, 02, 01 순으로 저장한다.역순으로 저장하는 리틀 엔디안 규약이 존재하는 이유는 다음과 같다.
저장된 값이 홀수인지 짝수인지 판별하기 편리하다. 첫 번째 주소에 저장된 값만 보면 되기 때문이다.
연산 과정에서 자릿수가 증가(캐리)될 때, 빅 엔디안 방식보다 성능이 좋다.
캐스팅에도 유리하다. 예컨대 4바이트 변수를 2바이트로 캐스팅하려면, 앞의 두 바이트만 읽으면 그만이다.
이런 이유로 x86, x86-64 아키텍쳐 CPU의 제조사인 인텔과 AMD 모두 리틀 엔디안 방식을 채택하고 있다.
문제는 같은 규약을 사용하면 상관 없지만, 서로 다른 규약을 사용하는 시스템 간의 통신에서는 서로가 상대가 보낸 데이터를 엉뚱한 값으로 해석하게 된다는 것이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20240601001603.png" src="♣vaultstorage/attachment/pasted-image-20240601001603.png" target="_self">때문에 네트워크 통신 표준에서는 데이터를 전송할 때 빅 엔디안 규약으로 변환하여 전송하라고 되어있다.]]></description><link>0-발행완료/컴퓨터과학/리틀-엔디안,-빅-엔디안.html</link><guid isPermaLink="false">0 발행완료/컴퓨터과학/리틀 엔디안, 빅 엔디안.md</guid><pubDate>Tue, 23 Sep 2025 13:03:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[페이지 교체 알고리즘, LRU]]></title><description><![CDATA[한정된 공간에 데이터를 캐싱할 때, 새로 캐싱해야 하는 데이터가 생겨 기존의 데이터 중 일부를 해제해야 하는 상황에서, 어떤 데이터를 해제할 것인지 결정하는 알고리즘.
다음과 같은 경우에 사용된다.
캐시 메모리에서 해제할 데이터를 고를 때
OS가 가상 메모리 기법으로 보조 저장장치로 이동시킬 페이지를 고를 때
Note
'페이지'에 대한 보다 자세한 내용은 <a class="internal-link" data-href="0. 공부 (정리중)/컴퓨터과학/03. 메모리.md" href="0.-공부-(정리중)/컴퓨터과학/03.-메모리.html" target="_self" rel="noopener nofollow">03. 메모리</a> 문서를 참고하자. Optimal (OPT) : 앞으로 가장 오랫동안 사용되지 않을 (것으로 보이는) 페이지를 교체
FIFO (First In First Out) : 가장 오래 적재되어 있던 페이지를 교체
LRU (Least Recently Used) : 가장 오랫동안 사용되지 않은 페이지를 교체
LFU (Least Frequently Used) : 사용된 빈도가 가장 적은 페이지를 교체
NUR (Not Used Recently) : 최근에 사용되지 않은 페이지 중 하나를 교체
앞으로 가장 오랫동안 사용되지 않을 (것으로 보이는) 페이지를 교체
안타깝게도 비교 연구 목적으로 존재하는 이상적인 개념일 뿐, 실제로 프로세스가 앞으로 사용되지 않을 페이지를 미리 아는 것은 불가능하다.가장 오래 적재되어 있던 페이지를 교체<br><img alt="♣VaultStorage/attachment/Pasted image 20250302220850.png" src="♣vaultstorage/attachment/pasted-image-20250302220850.png" target="_self">들어온 시간을 저장해두거나, 큐 구조를 사용해 페이지를 관리한다.가장 오랫동안 사용되지 않은 페이지를 교체<br><img alt="♣VaultStorage/attachment/Pasted image 20250302220858.png" src="♣vaultstorage/attachment/pasted-image-20250302220858.png" target="_self">가장 오랫동안 사용되지 않은 페이지가 앞으로도 사용될 확률이 적을 것이라는 가정에 입각한 알고리즘.
큐로 비교적 간단하게 구현이 가능하다. 사용한 페이지를 큐에서 꺼내서 맨 위로 올리고, 프레임이 모자랄 경우 맨 아래에 있는 페이지를 제거하고 맨 위에 새 페이지를 넣으면 된다. (근데 임의 위치에 있는 걸 꺼내려면 링크드 리스트를 써야 하는 거 아닌가? 큐에선 어쨌든 꺼낸 뒤에 뒤에 있는 놈들을 한 칸씩 당기는 작업이 필요할텐데)비교적 간단하고 효과적인 알고리즘이라 자주 쓰이지만, 단점도 있다. 우선 사용된 순서를 기록하는 자료구조 또는 페이지가 마지막으로 참조된 시간을 기록해야 하므로 막대한 오버헤드가 발생한다.사용된 빈도가 가장 적은 페이지를 교체
LRU와 달리 보다 장기적인 차원에서 참조 성향을 고려할 수 있다. 그러나 구현이 LRU보다 복잡하고, 가장 최근에 로드된 페이지일 수록 참조 횟수가 쌓이기 힘드니 빈번하게 교체되는 일이 생길 수도 있다. 막대한 오버헤드는 여전하다.최근에 사용되지 않은 페이지 중 하나를 교체
LRU를 근사한 알고리즘으로, 효율과 오버헤드 모두 적절한 수준이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250302220904.png" src="♣vaultstorage/attachment/pasted-image-20250302220904.png" target="_self">다만 LRU와 달리 교체되는 페이지가 가장 예전에 참조된 페이지임을 보장하지는 않는다.
구현은 복잡하니 생략]]></description><link>0-발행완료/자료구조와-알고리즘/알고리즘/페이지-교체-알고리즘,-lru.html</link><guid isPermaLink="false">0 발행완료/자료구조와 알고리즘/알고리즘/페이지 교체 알고리즘, LRU.md</guid><pubDate>Tue, 23 Sep 2025 13:03:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[디바운싱과 스로틀링]]></title><description><![CDATA[웹 개발에서 자주 사용되는 두 가지 기법. 물론 게임 등 다른 분야에서도 유용하다.
이벤트 기반으로 호출되는 함수가 있을 때, 성능을 높히기 위해 불필요한 호출을 생략하는 기법이다.같은 함수가 연달아 호출될 때, 최초 한 번만 혹은 최후 한 번만 호출되도록 최적화하는 것.
예컨대 키보드 키를 입력할 때 자동완성 리스트를 갱신한다고 했을 때, 매 키 입력마다 리스트를 갱신하는 것은 비효율적이므로, 키가 눌린 뒤 n초가 경과하면 갱신시키고, 그 전에 다시 눌리면 타이머를 초기화하는 식으로 사용된다.고의적인 병목을 발생시켜 이벤트가 일정한 시간마다 발생하게 하거나, 이벤트가 한 번 발생한 후 일정 시간이 지나기 전까지 재발생하지 않도록 하는 것.
예컨대 스크롤 이벤트는 매우 잦은 간격으로 발생하게 되는데, 매 스크롤마다 무거운 동작을 실행한다면 스크롤이 일어나는 동안 n초에 한 번씩만 이벤트가 발생하게 한다.]]></description><link>0-발행완료/자료구조와-알고리즘/알고리즘/디바운싱과-스로틀링.html</link><guid isPermaLink="false">0 발행완료/자료구조와 알고리즘/알고리즘/디바운싱과 스로틀링.md</guid><pubDate>Tue, 23 Sep 2025 13:03:08 GMT</pubDate></item><item><title><![CDATA[유니티 기본 함수 목록]]></title><description><![CDATA[
스크립트의 활성화 여부와 관계 없이, 오브젝트가 활성화되어 있다면 가장 먼저(Start보다 우선) 호출된다.
단, Start와 마찬가지로 오브젝트가 비활성화된 채로 게임 루프에 진입하면, 오브젝트가 활성화되는 시점에 호출된다.
프리팹을 Instantiate로 생성하는 경우, 생성 직후 호출된다. 스크립트가 활성화되어 있을 때 첫 번째 Update()가 호출되기 전에 호출된다.
스크립트가 비활성화된 채로 게임 루프에 진입하면, 스크립트가 활성화되는 시점에 호출된다.
이하의 함수들은 Start와 마찬가지로 스크립트에 바인딩되며, 스크립트가 활성화되어 있을 때에만 동작한다.
매 프레임 호출된다.
경과 시간의 일관성을 보장할 수 없다.
매 프레임 수행되어야 하는 동작을 정의한다. 일정한 주기(Fixed TimeStep) 간격으로 호출된다. 실제로 다른 스레드에서 일정 간격마다 호출하는 건 아니고, FixedUpdate의 호출 여부를 결정하는 곳에서 누적된 시간에서 TimeStep을 빼가며 반복 호출하는 식이다.
경과 시간의 일관성이 보장된다.
물리 시뮬레이션은 FixedUpdate가 호출된 후 일어난다. Update()가 호출된 다음으로 호출된다.
주로 Update에서 값을 바꾸고, 그에 따른 처리를 LateUpdate에서 해주는 방식으로 사용한다. 렌더링 루프에서 기즈모를 그릴 때 호출되며 여기서 Gizmo 클래스를 사용해 기즈모를 그릴 수 있다. 렌더링 루프에서 GUI를 그릴 때 호출되며 여기서 GUI 클래스를 사용해 GUI를 그릴 수 있다.
GUI이므로 실제 게임에서도 그려지는 것이다. 게임 오브젝트에 부착된 렌더러가 카메라 절두체 공간에 들어올 때 / 벗어날 때 호출된다. 콜라이더가 부착된 오브젝트가 다른 콜라이더와 충돌, 트리거 오버랩, 지속, 탈출하는 경우 호출된다. 클라이언트의 마우스가 콜라이더 위에 진입, 그 상태로 클릭, 드래그, 지속, 탈출하는 경우에 호출된다. 게임 오브젝트가 파괴되기 전에 호출된다.
이 외에도 엄청나게 많은 상속 가능한 함수들이 있다. 자세한 내용은 유니티 Docs를 참고하자.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.unity3d.com/kr/2021.1/ScriptReference/MonoBehaviour.html" target="_self">https://docs.unity3d.com/kr/2021.1/ScriptReference/MonoBehaviour.html</a>]]></description><link>0-발행완료/유니티-엔진/기초/유니티-기본-함수-목록.html</link><guid isPermaLink="false">0 발행완료/유니티 엔진/기초/유니티 기본 함수 목록.md</guid><pubDate>Tue, 23 Sep 2025 13:03:05 GMT</pubDate></item><item><title><![CDATA[언리얼 인사이트(Insight)]]></title><description><![CDATA[언리얼 에디터 및 엔진과 연동된 프로파일링 툴. 엔진을 설치하면 기본 내장되어 있다.여느 디버깅/프로파일링 툴이 그렇다듯, 언리얼 인사이트도 게임 인스턴스에서 '언리얼 트레이스 서버'를 열고 거기에 언리얼 인사이트를 연결해서 데이터를 전송받는 방식으로 되어있다.디버깅/프로파일링 툴들이 이런 방식을 채택하는 데는 몇 가지 이유가 있다.
런타임 어플리케이션 프로세스와 프로파일링 툴 프로세스를 분리하고, 나아가 기기도 분리하여 성능을 높히고 유연성을 제공한다.
프로파일링을 위한 데이터는 매우 방대하므로, 네트워크 스트림으로 지속적으로 보내는 방식이 관리하기 쉬움. 어플리케이션 자체에서 로컬로 데이터를 수집하려면 지속적으로 I/O 작업을 수행할 순 없으니 메모리에 쌓아놨다가 한 번에 덤프해야 함.
게임은 PC뿐만 아니라 콘솔, 모바일 등 로컬 환경에서 프로파일링하기 어려운 기기에서도 테스트해야 함.
게임 어플리케이션과 인사이트를 같은 환경에서 구동한다면, 기본 값이 로컬 호스트 IP로 되어있으므로 바로 접속할 수 있다.언리얼 인사이트는 크게 (1) Session Browser, (2) Session Insight 창으로 구성된다.
세션 브라우저를 열어 라이브 중인, 혹은 녹화된 세션을 선택해 인사이트 창을 열고, 거기서 프로파일링 데이터를 확인할 수 있다.<img alt="♣VaultStorage/attachment/Pasted image 20250922153757.png" src="♣vaultstorage/attachment/pasted-image-20250922153757.png" target="_self" style="width: 400px; max-width: 100%;">언리얼 에디터 하단의 Trace -&gt; Unreal Insights를 눌러 세션 브라우저를 열 수 있다.
엔진버전\Engine\Binaries\OS\UnrealInsights.exe 경로에서 수동으로 실행해도 된다.프로파일링 데이터를 수집하는 작업을 트레이스라고 한다. 트레이스 스토어는 수행한 트레이스 작업 목록을 나열한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922154317.png" src="♣vaultstorage/attachment/pasted-image-20250922154317.png" target="_self">커넥션 탭에선 프로파일링을 할 Running Instance가 돌아가는 호스트로 언리얼 인사이트를 연결한다.세션 프론트엔드 탭에선 현재 연결되어 있는 세션들(게임들)을 골라 동적으로 프로파일링 옵션을 변경할 수 있으며, 라이브 프로파일링 중일 때 트레이스할 채널을 변경하거나, 스냅샷이나 북마크를 남기는 등의 동작을 수행할 수 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922154826.png" src="♣vaultstorage/attachment/pasted-image-20250922154826.png" target="_self" style="width: 525px; max-width: 100%;">세션 프론트엔드의 기능은 세션 트레이스 서버를 열고있는 각각의 게임 인스턴스에서도 수행할 수 있으며, 언리얼 에디터에서 이를 지원한다. 에디터 상단 Tools - Session Frontend를 눌러 <br><img alt="♣VaultStorage/attachment/Pasted image 20250922154852.png" src="♣vaultstorage/attachment/pasted-image-20250922154852.png" target="_self" style="width: 200px; max-width: 100%;"> <img alt="♣VaultStorage/attachment/Pasted image 20250922154905.png" src="♣vaultstorage/attachment/pasted-image-20250922154905.png" target="_self" style="width: 250px; max-width: 100%;">에디터 또는 세션 프론트엔드의 다음 버튼을 클릭하여 트레이스 작업을 시작한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922155054.png" src="♣vaultstorage/attachment/pasted-image-20250922155054.png" target="_self">트레이스 작업을 시작하는 순간 세션 브라우저에서 실시간으로 데이터가 수집되고 있는 세션을 확인할 수 있으며, 위 버튼을 다시 한 번 눌러 라이브 수집을 종료하고 녹화된 데이터를 통해 확인할 수도 있다.Trace Store에서 분석할 트레이스를 골라서 열면 다음과 같은 인사이트 창이 뜬다.<br><img alt="♣VaultStorage/attachment/스크린샷 2025-09-22 155753 1.png" src="♣vaultstorage/attachment/스크린샷-2025-09-22-155753-1.png" target="_self" style="width: 750px; max-width: 100%;">좌상단의 파랗게 불이 들어온 버튼들을 토글하여 필요한 섹션을 열고 닫을 수 있다.각 섹션의 역할은 다음과 같다.
Frames : 각각의 프레임을 하나의 막대바로 표현한다. 막대바의 높이가 높을 수록 해당 프레임의 비용이 높았음을 의미한다. 게임 프레임과 렌더링 프레임으로 나뉘어져 있다. 막대를 누르면 Timing 섹션에서 해당 프레임이 시작된 순간부터 끝난 순간까지가 범위로 지정된다.
Timing : CPU, GPU의 여러 스레드들이 해당 시간대에 무슨 작업을 하고 있었는지 표시한다.
Log : UE_LOG로 입력된 모든 언리얼 로그들과 트레이스 녹화 중 발생한 스냅샷, 스크린샷, 북마크 이벤트 등에 대한 로그가 표시된다.
Timers : 각각의 동작을 수행하는데 걸린 시간이 측정되어 나열된다. 예컨대 CPU -&gt; FEngineLoop:Tick의 Total Inclusive Time(Incl)이 50.1ms라는 건 언리얼 엔진의 한 엔진 틱(=한 프레임)동안 수행해야 하는 모든 작업이 50.1ms동안 이루어졌음을 의미한다.
Counters : 값의 변화를 추적하여 나열한다. 예컨대 씬에 있는 오브젝트의 개수, 프레임당 드로우콜의 수, 네트워크로 전송된 패킷의 수 등이다.
Callers/Callees : 해당 동작이 누구에 의해 호출되었고(Callers), 누가 호출되어 수행하는지(Callees)를 표시한다.
Timers, Counters, Callers, Callees의 각 항목은 커서를 올리면 이름 좌측에 i 아이콘이 표시되며, 그 위로 커서를 올리면 소스파일의 위치와 라인 등 여러 부가 정보를 확인할 수 있다.이제 실제로 프로파일링을 수행해보자.
다음 트레이스는 '게임 시작 -&gt; 게이트 진입 -&gt; 던전 생성 후 플레이어 스타트' 작업을 수행한 뒤 녹화를 중단한 트레이스이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922163908.png" src="♣vaultstorage/attachment/pasted-image-20250922163908.png" target="_self" style="width: 675px; max-width: 100%;">시간대별로 대강 구간을 나눠보면 다음과 같다.<br><img alt="♣VaultStorage/attachment/스크린샷 2025-09-22 163906.png" src="♣vaultstorage/attachment/스크린샷-2025-09-22-163906.png" target="_self" style="width: 675px; max-width: 100%;">참고로 중간중간 게임 프레임이 갑자기 극단적으로 치솟은 건 중단점에 걸려서 VS IDE에 의해 인터럽트가 발생하고, CPU가 WaitForTasks로 멈춰있는 것이므로 무시하자.비용이 큰 프레임을 분석해보자.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922164541.png" src="♣vaultstorage/attachment/pasted-image-20250922164541.png" target="_self" style="width: 250px; max-width: 100%;">여기 2320, 2321 프레임은 게이트 레벨에 던전이 동적으로 생성되는 단계의 막바지에 발생했다. 2320번 프레임은 게임 프레임, 2321번 프레임은 렌더링 프레임에서 비용이 크게 발생했다.먼저 2320번 프레임을 살펴보자.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922164821.png" src="♣vaultstorage/attachment/pasted-image-20250922164821.png" target="_self" style="width: 850px; max-width: 100%;">Frame은 한 단위 프레임을 수행하는 동안 걸린 시간을, WaitForTasks는 CPU가 다른 병렬 비동기 처리의 완료를 기다리고 있는 것이므로 무시하자.
WaitForTasks는 VS IDE에서 중단점에 의해 개입할 때 이를 기다리는 시간을 표현하기도 한다. 즉, 이 시간동안 어떤 동작을 수행하느라 오래 걸리는 것이 아니라 CPU의 정상적인 동작으로 다른 작업의 완료를 기다리는 것이다.우리가 눈여겨 볼 것은 FEngineLoop::Tick 함수이다. 이 함수는 언리얼 엔진이 한 게임 프레임을 시작하면서 호출하는 함수로, 해당 게임 프레임에서 이루어지는 모든 동작들이 이 아래에서 이루어진다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922165304.png" src="♣vaultstorage/attachment/pasted-image-20250922165304.png" target="_self" style="width: 325px; max-width: 100%;">눌러서 확인해보니, BP_DungeonGenerator_KSH_C 액터가 무려 66.7ms를 혼자서 차지하고 있는 모습을 볼 수 있다.
이는 Timing 섹션에서 시각적으로 확인할 수도 있다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922165601.png" src="♣vaultstorage/attachment/pasted-image-20250922165601.png" target="_self" style="width: 300px; max-width: 100%;">눌러서 그 안에서 무슨 작업들이 이루어지고 있는지 확인해보자.<br><img alt="♣VaultStorage/attachment/Pasted image 20250922165655.png" src="♣vaultstorage/attachment/pasted-image-20250922165655.png" target="_self" style="width: 425px; max-width: 100%;">GeometryCollection을 생성하고, 액터를 초기화하는 함수들이다. 즉, 던전 생성의 막바지에 던전 내에 부술 수 있는 마나석 액터들을 스폰하는 프레임이라 오래 걸린 것이었다.아마 2321 프레임은 그렇게 새로 생성된 액터들을 렌더링하기 위한 초기 리소스를 가져오느라 렌더링 프레임에서 오래 걸리는 듯 하다 :D]]></description><link>0-발행완료/언리얼-엔진/프로파일링/언리얼-인사이트(insight).html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/프로파일링/언리얼 인사이트(Insight).md</guid><pubDate>Tue, 23 Sep 2025 13:03:01 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Event Dispatcher]]></title><description><![CDATA[특정한 이벤트가 발생할 때 호출할 콜백 함수들을 담고 있는 객체.
블루프린트에서 Delegate를 사용하기 위한 특정한 형태로, 기본적으로 델리게이트이며 블루프린트에서 사용할 때 '이벤트 디스패처'라고 부른다고 이해하면 된다.블루프린트에서 Event Dispatcher 노드를 생성하면, C++로 따지면 다음과 같은 델리게이트가 선언되는 것이나 마찬가지다.C++1// 이벤트 디스패처는 블루프린트와 연동되는(DYNAMIC), 여러 리스너를 등록할 수 있는(MULTICAST) 델리게이트이다.2DECLARE_DYNAMIC_MULTICAST_DELEGATE(FDoSomething);34...5UPROPERTY(BlueprintAssignable, Category="Event")6FDoSomething OnSomethingHappend;C++]]></description><link>0-발행완료/언리얼-엔진/블루프린트/event-dispatcher.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/블루프린트/Event Dispatcher.md</guid><pubDate>Tue, 23 Sep 2025 13:02:58 GMT</pubDate></item><item><title><![CDATA[Assertion, Logging]]></title><description><![CDATA[언리얼에서 정의한 Assertion 용 매크로는 크게 (1) check, (2) verify, (3) ensure 세 가지가 있다. 또 이것들이 활용하는 형태에 따라 조금 변형된 버전으로 존재한다.C++의 assert 매크로에 대응된다. 디버그 빌드에서 조건이 false면 에러를 던져 에디터를 꺼버린다. 릴리즈 빌드에선 컴파일러에 의해 제거된다. (보다 구체적으로는, 디버그 빌드에서만 켜지는 DO_CHECK 플래그가 있어야지만 동작한다.)기본 동작은 check와 같으나, DO_CHECK 플래그가 꺼져있어도(즉, 릴리즈 빌드에서도) 제거되지 않고 검사는 한다. 다만 반환값을 무시하므로 오류를 뱉지는 않는다.치명적이지 않은 오류에 사용하여, 조건이 false면 언리얼 크래시 리포터에 그 사실을 알리고 경고 문구를 출력하지만 에러를 던지지는 않는다.언리얼에선 로그 파일, 출력 로그 창에 로그를 기록하기 위한 UE_LOG 매크로를 제공한다.
가장 기본이 되는 형태는 다음과 같다.C++1UE_LOG(카테고리, 속성, TEXXT("log contents formatted"), ...);C++매번 모든 인자를 직접 입력하기는 번거로우므로 다음과 같은 매크로를 정의하여 사용하자.로그 매크로를 정의할 소스 파일의 헤더C++1// 유저 정의 로그 카테고리 추가2DECLARE_LOG_CATEGORY_EXTERN(MyProjectLog, Log, All);34// 함수명과 줄번호 기록하기5#define LOG_INFO (FString(__FUNCTION__) + TEXT("(") + FString::FromInt(__LINE__) + TEXT(")"))67#define PRINT_LOG_INFO() UE_LOG(MyProjectLog, Warning, TEXT("%s"), *LOG_INFO)89#define PRINT_LOG(str, ...) UE_LOG(MyProjectLog, Warning, TEXT("%s %s"), *LOG_INFO, *FString::Printf(str, ##__VA_ARGS__))C++로그 매크로를 정의할 소스 파일C++1DEFINE_LOG_CATEGORY(MyProjectLog);C++이제 다음과 같이 사용한다.C++1PRINT_LOG(TEXT("Hello, %s"), TEXT("World!"));C++]]></description><link>0-발행완료/언리얼-엔진/기초/assertion,-logging.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/기초/Assertion, Logging.md</guid><pubDate>Tue, 23 Sep 2025 13:02:55 GMT</pubDate></item><item><title><![CDATA[언리얼 타입]]></title><description><![CDATA[언리얼은 몇몇 케이스에서 자신들이 직접 만든 타입을 C++ 기본 타입 대신 사용할 것을 권고 또는 요구한다. 더 명확한 크기의 타입을 쓰거나 언리얼 리플렉션 및 Garbage Collector 시스템 등과 연동하기 위함이다.Note
게임에선 성능이 가장 중요하기 때문에, 조금이라도 캐시 히트율을 높이기 위해 구조체 정렬의 최적화에 많은 공을 들여야 한다.
bool 타입은 시스템에 따라 크기가 달라 문제가 생길 수 있다. (표준 자체가 없다.)
언리얼에서 직렬화 대상이 되는 boolean 데이터멤버를 선언할 땐, 다음과 같이 명시적으로 1바이트 변수를 선언하고 Bit Field 오퍼레이터로 1비트만 사용한다고 지정할 것을 권장한다. 접두어로는 b를 붙인다.C++1uint8 bMyFlag : 1;C++이론적으로 다른 크기도 사용 가능하나 uint8을 사용하는 이유는 구조체 패딩이 기본타입의 크기를 따라가기 때문인 것으로 보인다. 간혹 샘플 프로젝트에선 uint32 : 1를 사용하는 경우도 많이 보이는데, 이는 구조체 정렬의 기본 바이트수를 맞추기 위해서인 것으로 것으로 보임.UTF-16 (2바이트, wchar_t, TCHAR) 포맷을 사용하는 가변 문자열 타입.
기존 문자열 타입들은 크기가 중구난방이라 포맷 변환 문제도 까다롭고 정렬도 제대로 안 된다. 그래서 언리얼은 TCHAR 크기와 UTF-16 포맷만 사용한다. FString은 TCHAR 배열을 포함하는(내부적으론 TArray&lt;TCHAR&gt;로 관리한다) 일종의 헬퍼 객체이다.C++1// TEXT 매크로는 모든 포맷의 문자열 리터럴을 TCHAR 배열로 변환한다.2FString str = TEXT("Hello!");34// 다른 타입을 문자열로 만들 땐 언리얼 타입의 ToString() 메서드를 사용하거나 FString의 변환 메서드를 사용한다.5VectorVariable.ToString(); // FVector6FString::SanitizeFloat(FloatVariable); // float7FString::FromInt(IntVariable); // int89// FString을 다른 타입으로 변환할 땐 다음 함수를 사용한다.10TestHUDString.ToBool(); // -&gt; bool11FCString::Atoi(*TestHUDString); // -&gt; int12FCString::Atof(*TestHUDString); // -&gt; float1314// 포함된 문자열을 검색할 땐 Contains 메서드를 사용한다.15TestHUDString.Contains(TEXT("Test"), ESearchCase::IgnoreCase)); // 대소문자 무시16TestHUDString.Contains(TEXT("Test"), ESearchCase::CaseSensitive, ESearchDir::FromEnd); // 대소문자 비교, 뒤에서부터 찾기C++에셋 관리, 속성이나 태그, 이벤트 이름 등에 사용하는 고유함을 보장하는 상수 문자열 타입.
대소문자의 구분이 없고 빌드시 해시값으로 변환되며 내부적으로 전역 풀(FNamePool)에 저장된다.
새 FName을 생성할 때마다 풀에 같은 키가 존재하는지 체크하는 과정을 거침에 주의.C++1// FName 생성자에 FNAME 매크로로 새 FName을 생성한다.2// const TCHAR*를 바로 전달해도 되지만, 유니코드 호환성과 일관성을 보장하기 위해 TEXT로 감싸서 전달하자.3FName key1(TEXT("SomeKey"));4FName key2 = FNAME(TEXT("somekey")); // FName은 대소문자를 구분하지 않는다. 따라서 윗 행에서 추가한 SomeKey와 중복된 키로 판단하고 윗 행에서 생성된 FName을 반환한다.C++문자열 현지화를 위해 문자열 테이블에서 일종의 키로 사용되는 타입. 자세한 내용은 현지화를 공부할 때...]]></description><link>0-발행완료/언리얼-엔진/기초/언리얼-타입.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/기초/언리얼 타입.md</guid><pubDate>Tue, 23 Sep 2025 13:02:53 GMT</pubDate></item><item><title><![CDATA[언리얼 자잘한 팁 모음]]></title><description><![CDATA[ 엔진 설정 - 디버깅을 위한 편집기 기호(에디터 심볼) 항목을 설치해야 디버깅 및 콜스택 보기가 가능하다. UHT에 의해 리플렉션되는 헤더 파일을 편집할 경우, 멤버가 변하거나 GENERATED_BODY 내의 라인줄 정보가 변하게 되면 generated.h 파일을 수시로 재생성하게 된다. 이 때 포커스를 강제로 Visual Studio의 Output 창으로 빼앗아 가버리는 문제가 있다. VS의 언리얼 설정에서 실시간 재성성을 끌 순 있는데 권장하지 않는다. 그냥 ESC를 누르면 마지막 포커스로 되돌아오니 이걸 쓰자. ]]></description><link>0-발행완료/언리얼-엔진/기초/언리얼-자잘한-팁-모음.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/기초/언리얼 자잘한 팁 모음.md</guid><pubDate>Tue, 23 Sep 2025 13:02:50 GMT</pubDate></item><item><title><![CDATA[언리얼 오브젝트(UObject)의 이해]]></title><description><![CDATA[언리얼에선 기존의 C++ 오브젝트와 언리얼 오브젝트를 모두 사용하지만,
언리얼의 핵심은 ‘언리얼 오브젝트’라는 독특한 객체 규약이다. UObject 클래스를 상속하여 만들어진 모든 오브젝트가 언리얼 오브젝트이다.C++ 오브젝트는 저수준의 빠른 처리를 위해서, 언리얼 오브젝트는 콘텐츠 제작과 관련된 복잡한 설계와 구현에 사용된다고 생각하자.
언리얼 코딩 컨벤션에 따르면 기존 C++ 오브젝트와 언리얼 오브젝트를 구분하기 위해 전자에는 F, 후자에는 U 접두어를 붙인다.
다음과 같은 언리얼 엔진이 제공하는 기능들은 대부분 언리얼 오브젝트에 대해서 동작한다. (모두 그런 것은 아니다)
클래스 기본 객체(CDO)를 생성하고 에디터에서 편집하기.
리플렉션을 통해 에디터에서 오브젝트를 편집하고 런타임에 클래스 정보를 조회하기.
모던 객체 지향 언어들이 사용하는 인터페이스 기능.
향상된 열거형 타입의 지원.
객체 간 의존도를 낮출 수 있는 대리자(Delegate) 기능.
Garbage Collector에 의한 자동 메모리 관리.
쉽고 빠른 바이트 스트림으로의 직렬화 및 역직렬화.
물론 이런 기능들이 단순히 UObject 클래스를 상속한다고 적용되는 것은 아니다.이런 언리얼 오브젝트들은 어떻게 관리되는 것일까?
그걸 알기 위해선 우선 언리얼이 소스코드를 어떻게 관리하는 지부터 알아야 한다.주어진 소스 코드들을 플랫폼에 알맞게 빌드하기 위해 필요한 구성으로 준비해주는 역할을 수행하는 전처리 프로그램.
예컨대 윈도우즈에서 프로젝트를 만들면 Visual Studio 솔루션으로 편집이 가능하게 준비해주고, 맥에서 프로젝트를 만들면 XCode로 편집이 가능하게 준비해주는 역할을 한다.원리는 생각보다 심플하다. 빌드 툴이 실행되면 Source 폴더 내 Target.cs 파일을 열어 모듈들에 대해 조사하고, 조사가 끝난 모듈에 대해 Intermediate 폴더 안의 ProjectFiles 폴더에 정리하여 알맞은 IDE의 프로젝트 파일을 생성하고, 언리얼 엔진의 설치 경로로 가서 언리얼 엔진 프로젝트의 프로젝트 파일도 복사해온다.
이후 모듈 프로젝트 파일들과 언리얼 엔진 프로젝트 파일들을 합쳐서 솔루션 파일을 생성해 개발자가 바로 편집이 가능한 상태로 만들어준다.프로젝트 경로에서 uproject 파일을 우클릭하고 'Generate Visual Studio project files'을 눌러 솔루션을 재생성하는 것이 바로 UBT를 동작시키는 것이다. 파일을 지우다 버그가 났거나 이래서 IDE 파일들을 지우고 UBT를 재가동하는 건 자주 하게 된다.소스 파일들을 컴파일 하기 전에 모든 헤더를 순회하며 언리얼 리플렉션 시스템에 필요한 정보를 정리하여 .generated.h 파일과 .gen.cpp 파일을 Intermediate 폴더 안에 생성하는 전처리 모듈(EpicGames.UHT.dll)빌드가 시작되면 우선 UHT가 먼저 동작하여 UCLASS, UFUNCTION, UPROPERTY 등의 리플렉션 매크로가 지정된 클래스나 함수나 멤버들의 정보를 모두 모아서 앞서 말한 클래스 등의 메타 정보 파일인 .generated.h, .gen.cpp 파일을 생성한다. 이후 이 코드들을 포함하여 컴파일을 진행하게 된다.
.generated.h를 열어보면 언리얼 리플렉션에 필요한 핵심 매크로와 함수들이 모두 정의되어 있는 것을 볼 수 있다.언리얼 오브젝트의 메타 정보를 담고 있는 컨테이너. UHT가 생성한 .generated.h 파일을 열어보면(Intermediate/Build/Win64/UnrealEditor/Inc/프로젝트명/UHT 안에 있다), UClass 포인터를 반환하는 StaticClass 함수가 정의되어 있는 걸 볼 수 있는데, UHT에 의해 컴파일 타임에 각각의 언리얼 오브젝트에 대응하는 UClass가 만들어진다고 봐도 무방하다.이 안에는 언리얼 오브젝트에 대한 클래스 계층 구조, 멤버 정보 등이 모두 담겨있어 이를 통해 CDO를 만들고, 에디터에서 편집하고, 런타임에 멤버 정보를 순회하는 등의 행동이 가능해진다.Note
UHT가 이 언리얼 오브젝트에 대해 UClass를 생성하도록 지시하는 매크로는 UCLASS()이다.
언리얼 프로젝트를 빌드하여 실행하면 가장 먼저 UClass를 참고하여 언리얼 오브젝트의 초기상태 인스턴스가 생성된다. 이것이 CDO이다.
실제로 메모리에 로드되는 인스턴스이므로 생성자까지는 호출이 된다. 따라서 언리얼에선 UObject의 생성자를 CDO의 초기 상태를 지정하는 역할로 사용한다.CDO가 필요한 이유는 다음과 같다.
언리얼 에디터에서 UObject를 편집하려면 우선 초기 상태의 UObject가 필요하다. 그 위에 여러 값을 덮어씌우는 방식으로 수정하게 된다.
같은 UObject를 여러 버전으로 파생시켜서 사용한다고 할때, 이를 일일히 새로 만드는 것보다 그냥 초기 상태의 UObject 인스턴스를 하나 만들어두고, 이를 복제하여 각각의 속성 값만 변경하는 방식으로 파생시키는 게 훨씬 효율적이다.
이런 이유로 언리얼은 CDO를 에디터에서 편집되기 전의 초기 상태 객체이자 UObject를 생성할 때 복제할 원본으로 사용한다.이상의 과정을 정리하면 다음과 같다.
빌드가 시작되면 각각의 모듈에 속한 UObject들의 메타 정보를 UHT가 생성한다.
에디터나 게임이 실행되면 UObject들의 컴파일 타임에 만들어진 메타 정보를 보고 CDO를 생성하고, 이 때 생성자를 통해 CDO의 구성을 완료한다.
에디터에서 CDO를 편집하거나, 게임에서 CDO를 기반으로 값을 바꿔 실제 사용하는 UObject로 만들어 사용한다.
UObject 클래스에 있는 독특한 문법으론 다음과 같은 것들이 있다.UHT가 생성한 메타 정보 코드를 포함하는 부분. 헤더의 가장 마지막으로 포함해야 한다.이 UObject의 메타 정보를 생성하라고 알려주는 매크로. 안 쓰면 리플렉션이고 뭐고 메타 정보가 만들어지지 않으므로 못 쓴다.클래스 개방 규약. 언리얼의 소스 코드들은 여러 모듈(dll)들로 이루어지는데, 이 소스 코드를 다른 dll에서도 사용할 수 있게 개방한다고 명시하는 것이다.
실제로 MyProject_API 부분을 지워도 작동은 한다. 다만 해당 클래스는 MyProject 모듈에서만 사용할 수 있다.UObject 클래스 본문 필수 코드 생성 매크로. 앞서 말한 MyObject.generated.h 파일에 정의된 매크로나 기능을 사용한다고 명시하는 것이라고 한다. 헤더를 포함하고 이 매크로를 사용함으로써 리플렉션같은 여러 기능을 이용할 수 있게 된다.
매크로 내부는 MyObject.generated.h 에 정의된 CURRENT__FILE_ID, 매크로의 라인줄, 여러 플래그들로 이루어진다.
주의할 점은 매크로가 매크로의 라인줄을 요구하기 때문에 매크로의 라인줄이 변경되면 헤더부터 다시 빌드해야 한다는 것.]]></description><link>0-발행완료/언리얼-엔진/기초/언리얼-오브젝트(uobject)의-이해.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/기초/언리얼 오브젝트(UObject)의 이해.md</guid><pubDate>Tue, 23 Sep 2025 13:02:48 GMT</pubDate></item><item><title><![CDATA[언리얼 스마트 포인터 타입]]></title><description><![CDATA[리플렉션, 레퍼런스 카운팅 등 언리얼 시스템과 호환을 위해 언리얼이 자체 제공하는 스마트 포인터.
기존의 C++ 스마트 포인터는 언리얼 시스템과 호환이 되지 않으므로 사용하지 않는다.이하의 스마트 포인터 타입들은 언리얼 오브젝트를 가리키기 위한 것이 아니며, 따라서 참조 카운트가 0이 될 때 소멸자를 호출할 뿐 GC가 수거하지는 않는다(GC는 UObject에 대해서만 동작한다는 걸 명심하자).기본적으로 C++ 네이티브 타입(F 접두어)을 가리키는 용도이다. 그럼 그냥 C++ 스마트 포인터를 쓰지 왜 만들었나 싶겠지만, 커스터마이징, 스레드 안전성, 디버깅과 로깅 등 여러 측면에서 언리얼 환경에 보다 적합하게 설계되어 있으므로 이걸 써야 한다.C++의 shared_ptr에 대응된다. 여러 객체가 하나의 객체를 공유하여 참조한다.C++1// 기본 선언 형태는 다음과 같다.2TSharedPtr&lt;FMyData&gt; MyData = MakeShared&lt;FMyData&gt;();C++항상 유효한 객체를 가리키는 TSharedPtr . 항상 유효한 객체를 가리키므로 IsValid 함수도 없다.C++1// 기본 선언 형태는 다음과 같다.2TSharedPtr&lt;FMyData&gt; MyData = MakeShared&lt;FMyData&gt;().ToSharedRef();C++C++의 weak_ptr에 대응된다. TSharedPtr가 가리키는 객체를 참조카운팅을 증가시키지 않고 참조한다.C++1TSharedPtr&lt;FMyData&gt; MyData = MakeShared&lt;FMyData&gt;();23TWeakPtr&lt;FMyData&gt; MyDataWeak = MyData;4// 필요한 경우 Pin() 함수로 카운팅을 증가시키며 TSharedPtr로 변환한다.5TSharedPtr&lt;FMyData&gt; MyDataShared = MyDataWeak.Pin(); C++C++의 unique_ptr에 대응된다. 단일 소유권을 가져 동시 참조, 복사는 불가능하며 소유권과 함께 이동만 가능하다.C++1TUniquePtr&lt;FMyData&gt; MyData = MakeUnique&lt;FMyData&gt;();C++이하의 타입들은 UObject를 대상으로 하는 스마트 포인터 타입들이다. UObject는 C++ 네이티브 클래스와 달리 소멸자에 의해 리소스를 해제하지 않고 GC가 알아서 수거하는 방식으로 동작하며, 대표적으로 World가참조하는 Actor들과 같이 개발자가 명시한 참조가 아니더라도 여러 곳에서 이미 참조되고 있을 수 있다.또, GC가 동작하는 방식은 어디까지나 Mark-and-Sweep 방식에서 ‘도달 가능한가’의 여부를 통해 수거 대상을 선정하므로, 참조 카운트로 관리하는 방식은 아니다.UE5에서 도입된 강 참조 UObject 포인터.가리키는 UObject 객체의 참조 카운트를 증가시키므로(정확히는, GC 루트에서 도달 가능하게 연결됨) TObjectPtr가 가리키는 객체가 GC에 의해 수거되는 건 뭔가 문제가 있는 상황이다.
UE5 이전에는 일반 포인터를 사용했다.
UObject의 참조 카운트를 증가시키지 않고(정확히는, GC 루트에서 도달 가능하게 연결을 시키지 않음) 참조하는 포인터.참조하던 UObject 객체가 GC에 의해 수거되면 알아서 nullptr로 바뀌며, IsValid() 함수로 유효성 검사(현재 가리키는 객체가 살아있는 유효한 객체인가?)가 가능하다.Lazy 로딩을 위한 포인터. 에셋의 경로만 저장한 상태로 시작해 필요할 때 지연 로드하여 사용한다. 이 때 TSoftObjectPtr 자체는 지연 로드된 리소스를 강 참조하지는 않기 때문에 GC에 의해 바로 수거되지 않도록 주의해야 한다. (보통은 사용할 때 로드되고, 사용된다는 건 강참조한다는 뜻이므로 문제가 되지는 않는다.)
메모리에 존재하는 객체를 참조하는 방식을 일반(또는 hard) 레퍼런스, 에셋의 경로만 저장해놓는 것을 소프트 레퍼런스라고 한다.
C++1TSoftObjectPtr&lt;UTexture2D&gt; SoftTexture;23// 지연 동기 로딩4UTexture2D* ptr = SoftTexture.LoadSynchronous();56// 이미 로드된 리소스는 Get을 통해 다시 주소를 얻을 수 있다.7UTexture2D* ptr = SoftTexture.Get();C++필요하다면 에셋 매니저를 통해 비동기 로딩을 요청할 수 있다.C++1FStreamableManager&amp; Streamable = UAssetManager::GetStreamableManager();2Streamable.RequestAsyncLoad(SoftTexture.ToSoftObjectPath(), FStreamableDelegate::CreateLambda([=]()3{4 UTexture2D* LoadedTexture = SoftTexture.Get();5}));C++스마트 포인터는 아니고 그냥 템플릿 레퍼런스 래퍼이다. UObject 객체의 UClass를 가리킨다. 실객체가 아니라 UObject의 리플렉션된 구조를 나타내는 UClass를 저장할 뿐이므로 실제 인스턴스처럼 사용할 수 없고, 스폰할 액터의 타입을 저장해놓는다던가 하는 데 사용한다.다른 스마트 포인터들처럼 이 놈도 템플릿 타입으로 지정한 UObject와 그 자식 클래스의 UClass만 담기도록 타입 안정성을 보장해준다.]]></description><link>0-발행완료/언리얼-엔진/기초/언리얼-스마트-포인터-타입.html</link><guid isPermaLink="false">0 발행완료/언리얼 엔진/기초/언리얼 스마트 포인터 타입.md</guid><pubDate>Tue, 23 Sep 2025 13:02:46 GMT</pubDate></item><item><title><![CDATA[5. (작성중) 아핀 공간]]></title><description><![CDATA[앞서 2차원 공간에서의 크기 변환, 전단 변환, 회전 변환 행렬에 대해 다루었지만 이동 변환에 대해선 다루지 않았다. 그 이유는 2차원 공간에선 2차원 이동을 표현하는 선형 변환 함수를 만들 수 없기 때문이다.]]></description><link>0-발행완료/수학과-물리/게임수학/5.-(작성중)-아핀-공간.html</link><guid isPermaLink="false">0 발행완료/수학과 물리/게임수학/5. (작성중) 아핀 공간.md</guid><pubDate>Tue, 23 Sep 2025 13:02:43 GMT</pubDate></item><item><title><![CDATA[4. 행렬]]></title><description><![CDATA[앞서 선형성에 대해 간단하게 이해한 바 있지만, 보다 엄밀한 정의는 다음과 같다.
가법성(Additivity)와 1차 동차성(Homogeneity)을 만족하는 함수는 '선형성'을 가진다.
가법성(덧셈 보존): "두 벡터를 더한 후 변환한 결과는, 각 벡터를 변환한 후 더한 것과 같다."
1차 동차성(스칼라 곱 보존): "벡터를 k배 한 후 변환한 결과는, 변환한 벡터를 k배 한 것과 같다."
수식으로 보면 직관적으로 이해가 안 돼서 오히려 알아보기 힘들다. 그러나 그래프를 그려보면 아주 쉽게 이해할 수 있다.
왜냐하면, 원점을 지나는 1차 함수, 즉 의 꼴인 함수만이 위 식을 만족하기 때문이다.반면 이라던지, 같은 함수들은 직접 가법성과 1차 동차성이 성립하는지 확인해보면 그렇지 않다는 것을 쉽게 확인할 수 있다.요약하자면, 선형성이란 두 집합의 순수한 비로 구성된 1차적 대응 관계를 의미한다. 꼴의 함수는 인풋과 아웃풋이 1차원적인 순수한 비로 구성되므로 어떤 입력값을 넣었을 때 어떤 출력값이 나올 지를 쉽게 예측할 수 있고, 반대로 역함수 를 사용해 출력값으로부터 입력값을 계산하는 것이 가능하다.2차원 벡터를 입력으로 받고 2차원 벡터를 출력하는, 선형성을 가지는 선형 변환 함수를 설계해보자.먼저 2차원 벡터 공간의 선형 변환 함수는 두 개의 기저 벡터간의 선형 결합을 통해 인풋으로 들어온 2차원 벡터를 변환된 2차원 벡터로 출력하는 함수다.
또한 선형성을 가지므로 인풋으로 들어오는 두 스칼라 값에 비례하여 일정한 선형적 결과물을 출력해야 한다.
그럼 가장 적합한 형태는 각 기저가 한 축씩을 맡아 선형결합되는 다음과 같은 꼴이다.
예컨대 x축 스칼라를 2배로 늘리는 선형 변환 함수는 아래와 같다.
이런 선형 함수들은 인풋으로 들어가는 n차원의 벡터 공간 그 자체를 변형시킨다고 볼 수 있다. 아래 이미지는 선형 변환 함수 (3x + 1y, 1x + 2y)가 벡터 공간을 어떻게 변형시키는지 직관적으로 보여준다. 본래 (1, 0), (0, 1)이었던 표준 기저는 공간의 변형으로 (3, 1), (1, 2)를 가리키게 되었다.<img alt="♣VaultStorage/attachment/cxmIOB.gif" src="♣vaultstorage/attachment/cxmiob.gif" target="_self">기존의 벡터 공간이 선형 함수를 거쳐 변형되었을 때 변형된 공간 역시 선형성을 지니게 되는데(그 역시 선형 결합을 통해서 생성된 벡터들의 집합이므로), 이처럼 전과 후의 두 공간이 동일한 구조를 지니게 되는 연산을 변환(Transformation)이라고 부르며, 그 중에서도 선형성이 유지되는 변환을 선형 변환(Linear transformation)이라고 부른다.선형 변환은 선형대수학의 모든 것이다. 앞으로 다루게 될 모든 연산은 선형 변환이다.수를 사각형 형태로 행과 열을 맞춰 배열한 테이블. 계산을 쉽게 수행하기 위해 만들어진 규칙이자 수학적 도구라고 볼 수 있다. 행렬을 사용하면 선형변환을 매우 쉽게 계산할 수 있다.행렬은 일종의 수학적 규칙이므로 계산하는 방법을 철저히 따라야 한다. 행렬의 곱셈은 가장 중요하므로 따로 다루겠다.행과 열의 개수가 같은 행렬 간에만 성립하며, 같은 위치의 원소를 서로 더한다.행렬의 모든 구성 요소에 스칼라를 곱한다.첨자 로 표시하며, 행렬의 행과 열을 서로 바꾸는 연산이다. 아래에서 볼 수 있듯이 정방 행렬의 전치는 우하단으로 내려가는 사선을 기준으로 뒤집은 모양이 된다.
N x M 크기의 행렬과 M x K 크기의 행렬만 곱할 수 있으며, 곱셈의 결과 N x K 크기의 행렬이 생성된다. 예컨대 5x2 크기의 행렬과 2x3 크기의 행렬을 곱하면 5x3 크기의 행렬이 생성된다.
결합법칙은 성립하나 앞에 오는 행렬이 '행' 담당이고 뒤에 오는 행렬이 '열' 담당으로 교환법칙은 성립하지 않는다.
곱셈 결과 행렬의 R행 C열 요소는 행 담당 행렬의 R행 벡터와 열 담당 행렬의 C열 벡터의 각 요소끼리 곱한 뒤 이를 모두 더한 값이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712150052.png" src="♣vaultstorage/attachment/pasted-image-20250712150052.png" target="_self">예컨대 위 그림에서 곱셈 결과 행렬의 2행 1열의 요소는 행 담당 행렬의 2행 벡터와 열 담당 행렬의 1열 벡터의 각 요소를 순서대로 곱한 뒤 더한 것이다.행렬을 전치하면 행과 열이 서로 뒤바뀌므로, 행렬 곱의 결과를 전치한 것은 각 행렬의 전치 행렬을 반대로 곱한 것과 같다.
행렬은 선형변환을 계산할 때 아주 유용하다. 선형 변환 함수를 하나의 행렬로 표현하고, 여기에 벡터를 곱해 변환된 벡터를 얻을 수 있다. 예컨대 위에서 살펴본 2차원 벡터 공간의 선형변환 함수 는 다음과 같은 2x2의 정방 행렬로 나타난다.
여기에 임의의 벡터 (x, y)를 곱해보면 변환된 벡터를 얻을 수 있다.
여기서 중요한 건 '벡터를 어떻게 표현할 것이냐'이다. 위의 식은 벡터의 각 스칼라를 세로로 나열하는 '열 벡터' 방식을 사용했다. 이 때는 벡터가 행렬의 뒤에 있어야 행렬 곱셈 연산이 가능해지므로 곱셈이 역방향으로 놓이게 된다.열 벡터의 행렬 곱셈
예컨대 선형변환 행렬 A, B, C를 벡터 가 거친다면, 순으로 배치가 된다. 물론 배치가 역순으로 이루어졌다고 꼭 우측에서 좌측으로 계산해야만 하는 건 아니다. 행렬 곱셈은 결합법칙이 성립하기 때문.
그리고 바로 이 때문에 컴퓨터 그래픽스 연산에서 계산량은 획기적으로 줄어들게 된다. 이미 알고 있는 선형변환 행렬 A, B, C는 미리 곱해놓고, 그 결과를 매번 바뀌는 와 곱하기만 하면 되기 때문이다.
하지만 벡터의 각 스칼라를 가로로 나열하는 '행 벡터' 방식을 사용할 경우, 벡터가 행렬의 앞으로 가야 행렬 곱셈 연산이 가능해지므로 곱셈이 정방향으로 놓이게 된다.
이 때는 행렬 역시 열 벡터가 아닌 행 벡터 형태로 놓임에 주의하자. 이는 열 벡터 형태의 행렬이 전치된 것과 같다.다행인 사실은 열 벡터 방식의 계산을 전치하면 행 벡터 방식이 되고, 반대로 행 벡터 방식을 전치하면 열 벡터 방식이 된다는 것이다. 앞서 임을 배웠다. 따라서 서로 변환하고 싶다면 그냥 계산 결과를 전치하기만 하면 된다.행 벡터 vs 열 벡터
행 벡터를 쓸 것인지 열 벡터를 쓸 것인지는 자유다. 하지만 하나를 골랐다면 반드시 그것만 써야 한다. 실제로 DirectX, Unreal Engine은 행 벡터 방식을 사용하고, OpenGL, Unity Engine은 열 벡터 방식을 사용한다.
선형변환 행렬 은 두 기저 벡터 과 가 변환된 벡터 공간에서 (a, c), (b, d)가 되었을 때, 그 변환된 벡터 공간의 기저 벡터를 열벡터로 나열해둔 것과 같다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712160212.png" src="♣vaultstorage/attachment/pasted-image-20250712160212.png" target="_self"><br><img alt="♣VaultStorage/attachment/Pasted image 20250712160226.png" src="♣vaultstorage/attachment/pasted-image-20250712160226.png" target="_self">즉 선형변환 행렬과 벡터의 곱은 이 벡터를 변환된 벡터 공간의 벡터로 변환시키는 동작이다.이제부터 컴퓨터 그래픽스에서 실제로 사용하게 될 2차원 실 벡터 공간의 선형변환 행렬들을 알아보자.벡터 공간의 각 축의 스케일을 바꾸는 행렬.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712160629.png" src="♣vaultstorage/attachment/pasted-image-20250712160629.png" target="_self">원점을 기준으로 벡터를 회전시키는 행렬.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712160824.png" src="♣vaultstorage/attachment/pasted-image-20250712160824.png" target="_self">전단 변환이란 한 축이 고정된 상태로 다른 축을 밀어내듯이 변환시키는 것을 말한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712161032.png" src="♣vaultstorage/attachment/pasted-image-20250712161032.png" target="_self">이번엔 변환된 벡터 공간을 원래의 상태로 되돌리는 역행렬에 대해 알아보자. 우선 어떤 함수가 역함수를 갖기 위해선 전단사 함수여야 한다고 했다.
그리고 선형 결합 함수가 선형 종속이면, 선형 결합에 사용되는 벡터들 중 일부만의 결합으로 다른 벡터를 만들어내는 게 가능하므로 단사 함수의 성질을 잃어버리고, 선형 결합의 결과로 하나 이상의 차원(축) 정보가 소실되어 버리므로 전사 함수의 성질 역시 잃어버리게 된다. 따라서 선형 종속인 선형 결합은 역함수가 있을 수 없다.행렬식을 계산해보면 이 행렬이 선형 종속인 선형 변환 행렬인지 아닌 지를 아주 쉽게 알아낼 수 있다.
행렬식은 기호로 표기하며, 2x2 정방 행렬의 행렬식은 다음과 같다.
행렬식의 결과가 0이라면 그 선형 변환은 선형 종속이다.판별식은 기하학적으로 두 기저 벡터가 이루는 사각형의 넓이를 구하는 식으로 이해할 수 있다.<br><img alt="♣VaultStorage/attachment/1_cq4J4JNDaqTLCR3D1TJzsQ.gif" src="♣vaultstorage/attachment/1_cq4j4jndaqtlcr3d1tjzsq.gif" target="_self" style="width: 500px; max-width: 100%;">그런데 위 그림과 같이 선형 결합의 결과가 선형 종속이라면, 그렇게 만들어지는 벡터 공간은 기존의 차원보다 하나 이상 낮은 차원의 공간이 되기 때문에 넓이가 0이 되어버린다.반면 넓이가 0이 아니라면 2차원 벡터 공간을 선형 변환한 결과 역시 동형의 2차원 벡터 공간임을 의미하므로, 선형 독립이라는 소리가 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712163128.png" src="♣vaultstorage/attachment/pasted-image-20250712163128.png" target="_self">행렬식의 결과는 음수값일 수도 있다.
행렬식의 결과가 음수값이란 건 벡터 공간이 뒤집혔음을 의미한다. 예컨대 기저 벡터 (1, 0)이 변환의 결과 (0, 1)이 되고, (0, 1)은 변환의 결과 (1, 0)이 되었다면, 우상향하는 사선을 기준으로 벡터 공간 자체가 뒤집힌 모양이 되고, 행렬식의 결과는 -1이 나오게 된다.
늘리거나 줄였던 축의 크기를 다시 기존의 크기로 되돌리는 것이므로, 단순히 곱셈의 역원을 취한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712163344.png" src="♣vaultstorage/attachment/pasted-image-20250712163344.png" target="_self">이는 각 만큼 회전한 벡터 공간을 각 만큼 회전시키는 것과 같다. ()
sin 함수와 cos 함수는 다음과 같은 성질이 있으므로, 이를 활용한다. 참고로 이는 기존 회전 행렬을 전치한 것과 같다: <br><img alt="♣VaultStorage/attachment/Pasted image 20250712163519.png" src="♣vaultstorage/attachment/pasted-image-20250712163519.png" target="_self">밀었던 축을 원래 위치로 되돌리는 것이므로, 단순히 덧셈의 역원을 취한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250712172600.png" src="♣vaultstorage/attachment/pasted-image-20250712172600.png" target="_self">합성 함수의 역함수에 대해서 의 관계가 성립한다고 했다. 이는 행렬 곱에 대해서도 성립한다.]]></description><link>0-발행완료/수학과-물리/게임수학/4.-행렬.html</link><guid isPermaLink="false">0 발행완료/수학과 물리/게임수학/4. 행렬.md</guid><pubDate>Tue, 23 Sep 2025 13:02:40 GMT</pubDate><enclosure url="♣vaultstorage/attachment/cxmiob.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;♣vaultstorage/attachment/cxmiob.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. 삼각함수]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250706114553.png" src="♣vaultstorage/attachment/pasted-image-20250706114553.png" target="_self">빗변의 길이가 1인 직각삼각형은 밑변이 , 높이가 이다. 이로부터 다음의 식도 얻어낼 수 있다.
<br><img alt="♣VaultStorage/attachment/Pasted image 20250706120426.png" src="♣vaultstorage/attachment/pasted-image-20250706120426.png" target="_self">빗변이 r로 늘어날 경우 단순히 r을 곱해주면 되므로, 밑변은 , 높이는 가 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706120609.png" src="♣vaultstorage/attachment/pasted-image-20250706120609.png" target="_self">다음과 같은 관계성을 가진다.
호의 길이로 각을 측정하는 방법. 원의 둘레는 반지름의 배로 일정하다는 원리를 이용한다.
자주 사용하는 각을 각도법과 호도법으로 표현하면 다음과 같다.
벡터를 이동시키고 크기를 늘리는 동작은 단순히 각 축을 독립적으로 계산해 결합하는 것과 같았다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706122027.png" src="♣vaultstorage/attachment/pasted-image-20250706122027.png" target="_self">이 동작은 매우 직관적이고 간단하지만, 회전 동작은 그렇지 않다.
회전은 (2차원 좌표계 기준) 두 축이 함께 영향을 받기 때문에 축을 나누어 독립적으로 계산할 수 없기 때문이다.대신 회전 공식을 구할 때는 계산하기 편한 표준 기저 벡터를 사용해 회전 전과 회전 후의 차이로부터 규칙성을 구해볼 것이다.
다음은 표준 기저 벡터 (1, 0)과 (0, 1)이 각 만큼 회전한 결과이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706122148.png" src="♣vaultstorage/attachment/pasted-image-20250706122148.png" target="_self">삼각함수를 통해 계산해보면, 은 (1, 0)에서 가 되었고, 은 (1, 0)에서 가 되었다.그렇다면 이 두 기저 벡터의 결합으로 만들어졌던 벡터 (1, 1)은 로 변하게 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706122606.png" src="♣vaultstorage/attachment/pasted-image-20250706122606.png" target="_self">이상에서 임의의 벡터 (x, y)가 각 만큼 회전한 결과는 다음과 같다. 주어진 벡터의 각도(축으로부터의)를 알려면 삼각함수의 역함수를 알아야 한다.
삼각함수는 전단사함수가 아니기 때문에, 역함수를 구하기 위해선 범위를 제한하여 전단사 함수의 형태로 만들어야 한다. 모두 180도 주기를 가지므로 아래 그림과 같이 -90 ~ 90도 사이로 범위를 제한하는 식으로 구한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706132326.png" src="♣vaultstorage/attachment/pasted-image-20250706132326.png" target="_self">다만 arcsin과 arccos을 직접 계산하거나 활용할 일은 크게 없다. 게임에서 가장 중요한 건 arctan 함수이다. 탄젠트는 코사인과 사인의 비를 통해 구할 수 있으므로, 임의의 2차원 벡터를 x, y축으로 분리해 arctan 함수를 거치게 되면 쉽게 벡터의 Yaw 각도를 구할 수 있기 때문이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706132559.png" src="♣vaultstorage/attachment/pasted-image-20250706132559.png" target="_self">그런데 arctan 함수의 치역은 이므로, x, y 값을 arctan 함수에 집어넣을 때 이 벡터가 사사분면 중 어디에 있는지 체크한 뒤 결과값을 보정할 필요가 있다.예컨대 x, y값이 모두 음수라면, 3사분면에 속한다는 것을 알 수 있고, 의 결과에 180도를 추가해주면 실제 벡터의 Yaw 각도를 구할 수 있게 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706132831.png" src="♣vaultstorage/attachment/pasted-image-20250706132831.png" target="_self">웬만한 수학 라이브러리들은 모두 벡터의 x, y값을 통해 각도를 구하는 arctan 함수를 제공한다. 특히 x, y의 값을 분리해 받음으로써 어느 사분면에 속하는지까지 체크하는 함수들은 atan2 라는 이름을 많이 사용한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250706132947.png" src="♣vaultstorage/attachment/pasted-image-20250706132947.png" target="_self">]]></description><link>0-발행완료/수학과-물리/게임수학/3.-삼각함수.html</link><guid isPermaLink="false">0 발행완료/수학과 물리/게임수학/3. 삼각함수.md</guid><pubDate>Tue, 23 Sep 2025 13:02:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2. 벡터]]></title><description><![CDATA[실수 집합 두 개의 곱집합으로, 각 집합을 나타내는 두 축이 서로 직교하는 형태로 그려진다. <img alt="♣VaultStorage/attachment/Pasted image 20250705154846.png" src="♣vaultstorage/attachment/pasted-image-20250705154846.png" target="_self">1차원 수직선에서 그러했듯이 2차원 데카르트 좌표계 상의 한 점 역시 원점으로부터 각 축으로 일정한 크기만큼 뻗어나가는 화살표로 표현할 수 있다. 이 때의 점을 좌표라고 한다.둘 이상의 실수 집합의 곱집합으로 형성된 공간을 공리적 집합론의 관점에서 '벡터 공간'이라고 부르며, 그 공간의 원소는 '벡터'라고 한다. 그리고 체의 구조를 지니는 집합의 원소를 '스칼라'라고 부른다.
따라서 데카르트 좌표계는 2차원 벡터 공간이며, 이 공간의 한 점인 '벡터'는 두 개의 스칼라로 이루어진다.벡터 공간은 다음의 8가지 공리를 만족한다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705215904.png" src="♣vaultstorage/attachment/pasted-image-20250705215904.png" target="_self">벡터의 크기, 즉 원점으로부터 점까지의 거리는 피타고라스의 정리를 사용해 쉽게 구할 수 있다. 벡터의 크기는 Norm이라고 부른다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705220353.png" src="♣vaultstorage/attachment/pasted-image-20250705220353.png" target="_self">Note
나중에 배우겠지만, 3차원에서도, 더 나아가 n차원에서도 같은 방법으로 벡터의 크기를 구할 수 있다.
크기가 1인 벡터를 단위 벡터(Unit vector)라고 하며, 모자 기호(Hat)을 씌워 로 표기한다.
벡터를 벡터의 크기로 나누어 방향성만 남기고 크기가 1인 단위 벡터로 정규화(Normalize)할 수 있다.벡터간의 합이나 벡터와 스칼라의 곱셈은 연산의 결과가 일정한 비율로 유지되는 선형적 성질을 가지므로 선형 연산이라고 한다. 선형성에 대해서는 추후 더 자세히 살펴보겠으나, 쉽게 y = 2x와 같이 일정한 비율에 따라 결과값이 도출되는 함수는 선형성을 가진다고 생각하면 된다.
더 직관적으로 이해하고 싶다면, 벡터에 다른 벡터를 아무리 더해도, 또 스칼라를 아무리 곱해도 결국 원점에서 그어지는 화살표로 나타낼 수 있는 하나의 벡터가 될 뿐이라는 걸 생각하면 된다.선형 연산은 n개의 스칼라와 n개의 벡터를 결합해 새로운 벡터를 만들어내는 연산으로 볼 수 있다. 이를 선형 결합(Linear combination)이라고 하며, 수식으로 표현하면 다음과 같다.
선형 결합의 수식에서 0 벡터가 나오는 방법은 두 가지이다.
모든 스칼라 가 0일 때.
모든 스칼라 가 0이 아님에도, 계산의 결과 0 벡터가 나올 수 있을 때
선형대수학에선 1번 방법으로만 0 벡터가 나올 수 있는 벡터들의 선형 결합은 선형 독립적이라고 하고,
1번 방법 외에 2번 방법으로도 0 벡터가 나올 수 있는 벡터들의 선형 결합은 선형 종속적이라고 한다.예컨대 벡터 (1, 1)과 (2, 2)의 선형 결합은, 다음과 같이 모든 스칼라가 0이 아님에도 0 벡터가 나오므로 선형 종속이다.
반면 벡터 (1, 2)와 (2, 1)의 선형 결합은, 모든 스칼라가 0이 아니면 절대로 0 벡터가 나올 수 없으므로 선형 독립이다.Note
'모든 스칼라가 0이 아니어도 0 벡터가 나올 수 있느냐'는 말은 곧 '선형 결합에 이용되는 어떤 한 벡터에 어떤 스칼라를 곱해, 다른 한 벡터와 같아질 수 있느냐'는 말과 같다. 예컨대, 이다.
2차원 좌표계를 통해 시각적으로 확인해보면 왜 이런 차이가 발생하는 지 쉽게 이해할 수 있다. 첫 번째 예시인 (1, 1)과 (2, 2)는 선형 종속으로, 그래프 상에서 원점을 지나는 한 직선 상에 놓이며<br><img alt="♣VaultStorage/attachment/Pasted image 20250705223032.png" src="♣vaultstorage/attachment/pasted-image-20250705223032.png" target="_self">두 번째 예시인 (1, 2)와 (2, 1)은 선형 독립으로, 그래프 상에서 원점을 지나는 한 직선 상에 놓이지 않는다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705223214.png" src="♣vaultstorage/attachment/pasted-image-20250705223214.png" target="_self">이로부터 선형 종속이란, n개의 축으로 이루어진 벡터 간의 결합으로 1개 이상의 축의 정보가 소실된, 더 낮은 차원의 벡터가 나오게 되는 경우를 의미하고,
선형 독립이란, n개의 축으로 이루어진 벡터 간의 결합으로 n개의 축의 정보가 온전히 살아있는 같은 차원의 벡터가 나오게 되는 경우를 의미한다는 걸 알 수 있다.즉, 선형 종속은 '종속'이란 표현 그대로 더 낮은 차원에 갇혀 버리는 것을 말한다.선형 독립이냐 종속이냐가 매우 중요한 개념인 이유는, 선형 독립인 선형 결합으로만 해당 벡터 공간에 있는 모든 벡터를 생성해내는 게 가능하기 때문이다.
반면 선형 종속인 선형 결합으로는 종속된 더 낮은 차원의 벡터 공간의 벡터만을 생성해낼 수 있다.시각적으로 보자. 두 벡터 (1, 3)과 (2, 1)간의 선형 결합은 선형 독립이며, 그렇기에 곱하는 스칼라를 달리 함으로써 2차원 벡터 공간의 모든 벡터를 생성해내는 게 가능하다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705224107.png" src="♣vaultstorage/attachment/pasted-image-20250705224107.png" target="_self">하지만 선형 결합이 선형 종속인 두 벡터 (1, 2)와 (2, 4)의 결합으로는 두 벡터가 종속된 직선 위에 있는 벡터만을 구할 수 있다. 2차원 벡터 공간의 두 벡터를 결합한 결과가 1차원 벡터 공간의 벡터들로 종속되어 버리는 것이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705224205.png" src="♣vaultstorage/attachment/pasted-image-20250705224205.png" target="_self">N 차원 벡터 공간의 선형 독립이 보장되려면, 반드시 N개의 벡터간의 선형 결합이어야 한다.
만약 2차원 벡터 공간 상의 선형 독립인 두 벡터 A, B가 있다고 해보자. 이 둘의 선형 결합은 2차원 벡터 공간의 어떤 벡터도 생성해낼 수 있다. 그런데 여기에 2차원 벡터 공간 상의 다른 한 벡터 C가 추가된다고 해보자. 이 셋의 선형 결합은 의 형태가 되는데, 벡터 A, B의 선형결합으로 2차원상의 모든 벡터를 생성할 수 있으므로 C를 만들 수도 있을 것이며, 따라서 다음과 같은 식이 언제나 나올 수 있음을 의미한다. 일 때, 따라서 N차원 벡터 공간에서 N+1개 이상의 벡터간의 선형 결합은 반드시 선형 종속이다.
선형 결합이 선형 독립 관계를 가지는 벡터 집합을 기저라고 부른다. 예컨대 (1, 2)와 (2, 1)은 하나의 기저 벡터 집합이다. 그리고 기저 벡터 집합에 속하는 각각의 벡터들은 기저 벡터(Basis vector)라고 부른다.기저가 될 수 있는 벡터들의 조합은 무한하지만, 그 중에서도 특별히 하나의 축만, 1이라는 값을 가지는 단위 벡터들로 구성된 기저를 표준 기저(Standard basis)라고 한다. 2차원 벡터 공간의 표준 기저는 (1, 0)과 (0, 1)이다.
이들은 알파벳 e에 축의 순서를 붙여 각각 으로 표기하며, 표준 기저를 특별취급하는 이유는 기저로써의 역할은 잘 수행하면서도 매우 직관적이고 각자가 하나의 축을 담당하므로 연산에 써먹기가 쉽기 때문이다.또, 기저를 통해 생성해낼 수 있는 벡터 공간은 으로 표기하며, N차원 실벡터 공간(Real vector space)이라고 부른다. 지금까진 2차원 데카르트 좌표계에서만 놀았으므로, 지금까지 우리가 다룬 건 2차원 실벡터 공간 라고 할 수 있겠다.]]></description><link>0-발행완료/수학과-물리/게임수학/2.-벡터.html</link><guid isPermaLink="false">0 발행완료/수학과 물리/게임수학/2. 벡터.md</guid><pubDate>Tue, 23 Sep 2025 13:02:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. 수, 함수, 집합]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/Pasted image 20250705140111.png" src="♣vaultstorage/attachment/pasted-image-20250705140111.png" target="_self">이러한 성질들로부터 증명이 필요하지 않은 자명한 진리인 공리를 구축해내고, 그 공리들로부터 기존의 수 집합 체계를 새롭게 만들어볼 수 있다. 이를 '공리적 집합론'이라고 부른다.두 이항연산 덧셈과 곱셈에 대해,
연산에 대해 닫혀있고, 교환법칙·결합법칙·분배법칙이 성립하며, 항등원과 역원이 존재하는 수 집합이 있다면, 그 수 집합은 체(Field)의 구조를 지닌다고 말한다.이를 만족하는 수 집합은 유리수와 실수를 들 수 있다. 체의 구조를 지니는 것이 중요한 이유는, 이 집합이 덧셈과 곱셈을 활용한 자유로운 연산이 어떠한 예외도 없이 가능하며, 선형대수, 해석학, 대수학 등 여러 수학 이론을 전개할 수 있는 토대가 되기 때문이다.여기서 덧셈과 곱셈에 대해서만 살펴보는 이유는, 뺄셈은 덧셈의 역원을 더하는 것으로, 나눗셈은 곱셈의 역원을 곱하는 것으로 표현하는 게 가능하기 때문이다. 따라서 체의 구조를 지닌다면 사칙연산이 자유롭다는 뜻으로 이해해도 좋다.
<br><img alt="♣VaultStorage/attachment/Pasted image 20250705142356.png" src="♣vaultstorage/attachment/pasted-image-20250705142356.png" target="_self">어떠한 수를 수직선상에 나타내면, 위 그림과 같이 0에서 출발하며 크기가 수와 같은 화살표로 나타낼 수 있다. 이러한 관념은 선형대수학의 기초가 된다.공역의 모든 요소가 정의역에 대응되는 함수.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705142833.png" src="♣vaultstorage/attachment/pasted-image-20250705142833.png" target="_self">정의역과 공역의 요소가 일대일로 대응되는 함수.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705142906.png" src="♣vaultstorage/attachment/pasted-image-20250705142906.png" target="_self">전사 + 단사 함수. 정의역과 공역의 모든 요소가 빠짐없이 일대일로 대응되는 함수.
추후 배우겠지만 전단사 함수인 선형 변환의 기저 벡터는 반드시 선형 독립이어야 하기 때문에, 전단사 함수인 선형 변환이면서 선형 독립이 아닌 경우는 없다. 단 그 역은 성립하지 않으므로 주의.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705143000.png" src="♣vaultstorage/attachment/pasted-image-20250705143000.png" target="_self"><br><img alt="♣VaultStorage/attachment/Pasted image 20250705143538.png" src="♣vaultstorage/attachment/pasted-image-20250705143538.png" target="_self">둘 이상의 함수가 연쇄적으로 이어져 합성 함수를 만든다. 이 경우 중간 결과값(위 그림의 집합 Y처럼)을 생략하고 처음의 인풋과 최종 아웃풋 간의 직접적인 대응 관계로 표현할 수 있다.
위 그림과 같은 경우 또는 로 표기할 수 있다.합성 함수의 중요한 성질은 사칙연산 함수 간의 합성은 결합법칙이 성립한다는 것이다.
예컨대 아래와 같이 세 함수를 합성할 때,<br><img alt="♣VaultStorage/attachment/Pasted image 20250705143940.png" src="♣vaultstorage/attachment/pasted-image-20250705143940.png" target="_self"> 를 먼저 하는 것과 를 먼저 하는 것의 결과는 같다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705143953.png" src="♣vaultstorage/attachment/pasted-image-20250705143953.png" target="_self">정의역과 공역이 동일한 값으로 대응되는 함수. 기호로 라고 표기한다.아래 그림의 와 같이 어떠한 함수와 합성했을 때 그 결과가 항등함수가 되는 함수를 원함수의 역함수라고 말한다. ()<br><img alt="♣VaultStorage/attachment/Pasted image 20250705144732.png" src="♣vaultstorage/attachment/pasted-image-20250705144732.png" target="_self">역함수는 두 집합의 대응 관계를 뒤집어 공역 Y에서 정의역 X로 대응하는 함수라고도 표현할 수 있다. 일 때, 어떤 함수가 역함수를 가지려면 반드시 전단사 함수여야 한다. 아래 그림과 같이 전사 함수나 단사 함수는 역함수를 가질 수 없다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250705145208.png" src="♣vaultstorage/attachment/pasted-image-20250705145208.png" target="_self">또 한 가지 역함수의 중요한 성질은 어떤 합성 함수의 역함수는 두 원 함수의 역함수를 역순으로 합성한 것과 같다는 사실이다.
]]></description><link>0-발행완료/수학과-물리/게임수학/1.-수,-함수,-집합.html</link><guid isPermaLink="false">0 발행완료/수학과 물리/게임수학/1. 수, 함수, 집합.md</guid><pubDate>Tue, 23 Sep 2025 13:02:34 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Texture Mapping]]></title><description><![CDATA[3D 공간에 배치되는 오브젝트는 기본적으로 3가지 단계를 거쳐 렌더링된다.
수 많은 Vertex들로 이루어진 메쉬로 모양을 표현한다.
2D Texture를 메쉬에 맵핑한다.
셰이더 연산을 거쳐 최종적으로 그려낸다.
여기서 2번 과정을 Texture Mapping이라고 하며, 3D 메쉬를 조각내 2차원 평면의 펴바르듯 UV 좌표를 매기고, 이 위에 2D Texture를 입히는 작업이다.블렌더를 통해 Texture mapping 과정 전체를 실습해볼 수 있다.UV Editing 패널로 들어가면 2차원 UV 좌표계 평면을 볼 수 있다. 여기서 원하는 정점들을 선택한 후 UV - Unwrap을 누르면 자동으로 3D 메쉬를 잘라서 펴준다.<img alt="♣VaultStorage/attachment/Pasted image 20250812205732.png" src="♣vaultstorage/attachment/pasted-image-20250812205732.png" target="_self" style="width: 400px; max-width: 100%;"><br><img alt="♣VaultStorage/attachment/Pasted image 20250812205744.png" src="♣vaultstorage/attachment/pasted-image-20250812205744.png" target="_self" style="width: 425px; max-width: 100%;">혹은 수동으로 펴는 방식을 정의할 수 있다. Edge 하나를 선택한 상태로 우클릭 - Mark Seam을 선택하면 메쉬를 펴는 기준(잘리는 선)이 되며, 이 상태로 Unwrap을 할 경우 해당 Edge를 기준으로메쉬가 펴진다.Unwrap이 제대로 이루어졌는지 확인할 때는 일반적으로 체커 맵을 사용한다. 단색의 체크무늬가 반복되는 컬러 맵으로, 본래 정사각형인 체크무늬가 일그러진 정도로 왜곡이 얼마나 심한 지 알 수 있다.
블렌더에선 이미지 텍스쳐를 새로 생성하고, Generated Type을 UV Grid로 지정하면 된다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205818.png" src="♣vaultstorage/attachment/pasted-image-20250812205818.png" target="_self"><br><img alt="♣VaultStorage/attachment/Pasted image 20250812205819.png" src="♣vaultstorage/attachment/pasted-image-20250812205819.png" target="_self" style="width: 400px; max-width: 100%;">텍스쳐의 면적은 한정되어 있고 많은 텍스쳐를 사용할 수록 그만큼 비용이 증가하기 때문에, 적절한 수준의 비용으로 적절한 비중을 분배할 필요가 있다. 다음은 거북이 메쉬를 한 장의 텍스쳐에 표현한 예시이다.<br><img alt="♣VaultStorage/attachment/Pasted image 20250812205826.png" src="♣vaultstorage/attachment/pasted-image-20250812205826.png" target="_self" style="width: 400px; max-width: 100%;">예시와 같이 일반적으로 많이 노출되는 부분, 디테일이 살아있어야 하는 부분이 많은 비중을 차지하고, 잘 드러나지 않는 아랫배 등은 실제 크기에 비해 매우 작은 비중을 차지한다.]]></description><link>0-발행완료/그래픽스/texture-mapping.html</link><guid isPermaLink="false">0 발행완료/그래픽스/Texture Mapping.md</guid><pubDate>Tue, 23 Sep 2025 13:02:30 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PBR(Physically-Based Rendering)]]></title><description><![CDATA[PBR 이전의 컴퓨터 그래픽스(Legacy rendering 또는 phong lighting이라고 부르는)는 다음 3가지 텍스쳐를 핵심으로 사용했다.
Diffuse Map : 사물이 난반사된 색상을 표현.
Normal Map : 표면의 고저, 심도를 표현.
Specular Map : 표면의 재질과 빛의 반사율 / 정반사의 정도를 표현.
이 방식은 연산부하가 적고 간단한 쉐이더 식으로 구현되지만 현실의 사물을 컴퓨터 그래픽으로 구현하기엔 많이 허접했다.
이에 빛의 물리적 속성까지 고려하여 새롭게 등장한 렌더링 방식이 PBR이다.
일반적으로 다음의 네 가지 기본 맵에
Base Color (Diffuse Color, Albedo) : 물체의 기본 색상
Roghness(&lt;-&gt;Glossiness) : 표면의 거칠기
Metallic(Specular) : 금속성 정도(반사율)
Normal Map
다음과 같이 부가적인 정보를 전달하는 여러 가지 맵을 추가로 사용한다.
Ambient Occlusion : 구석지고 모나서 빛이 닿기 어려운 부분의 그림자를 강조
Emissive : 빛을 자체적으로 발산하는 속성을 표현
]]></description><link>0-발행완료/그래픽스/pbr(physically-based-rendering).html</link><guid isPermaLink="false">0 발행완료/그래픽스/PBR(Physically-Based Rendering).md</guid><pubDate>Tue, 23 Sep 2025 13:02:27 GMT</pubDate></item><item><title><![CDATA[Bone Skinning, Animation Rigging]]></title><description><![CDATA[메쉬에 있는 수 천 수 만개의 정점마다 일일히 애니메이션 키프레임을 입힐 수는 없다. 따라서 메쉬에 뼈대를 심고, 버텍스마다 어떤 뼈와 얼마나 결부되는 지를 기록한 후, 키 프레임은 뼈에 대해서만 주고 뼈가 움직이면 그 결과를 버텍스에 곱하는 방식으로 애니메이션을 구현하게 된다.이 때 각 Vertex들이 각 Bone에 얼마나 결부되는가(Weight로 표현)를 결정하는 작업을 Skinning이라고 한다.먼저 본 구조를 만들어보자. 블렌더에선 Add - Armature로 루트 본을 추가하고, 에디트 모드에서 본들을 이어나가며 본 구조를 만들 수 있다.본은 기본적으로 상위 본의 자식이 되며, 이를 분리하는 방법은 세 가지가 있다.
에디트 모드에서 본 우클릭 -&gt; Parent -&gt; Clear를 누르면 부모 본으로부터 떨어진다. 단, 여전히 같은 본 구조 안에 속하게 되며, 여기엔 두 가지 방식이 있다. Clear -&gt; Clear Parent는 완전 분리로 부모로부터 완전히 독립적으로 분리되어 Transform의 상속 구조가 끊어진다. 따라서 부모의 움직임에 영향을 받지 않는다.
Clear -&gt; Disconnect Bone은 불완전 분리로 물리적으로 떨어져 있으나 여전히 Transform의 상속 구조는 유지되는 경우다. 에디트 모드에서 본 우클릭 -&gt; Separate Bones를 누르면 아예 다른 본 구조로 분리된다.
Note
그냥 본 세개를 이어도 되는데 분리를 하는 이유는 불필요한 본의 개수를 최대한 줄이기 위해서이다.
]]></description><link>0-발행완료/그래픽스/bone-skinning,-animation-rigging.html</link><guid isPermaLink="false">0 발행완료/그래픽스/Bone Skinning, Animation Rigging.md</guid><pubDate>Tue, 23 Sep 2025 13:02:25 GMT</pubDate></item><item><title><![CDATA[(0923) 나선형 계단 Nav Mesh 베이킹 문제]]></title><description><![CDATA[<img alt="♣VaultStorage/attachment/스크린샷 2025-09-23 113928.png" src="♣vaultstorage/attachment/스크린샷-2025-09-23-113928.png" target="_self" style="width: 500px; max-width: 100%;">나선형 계단 레벨을 레벨 스트리밍으로 배치한 뒤 동적으로 Nav Mesh를 생성할 경우 확률적으로 계단에 네비 메쉬가 생성되지 않고, 주변에 이어진 룸이 있으면 근처의 엉뚱한 빈 공간에 나선형 모양의 네비 메쉬가 만들어진다.나선형 계단 레벨이 2종이었으며 그 중 한 종에서만 이러한 문제가 발생했기에 두 레벨의 차이점을 찾아보았다.
문제가 되는 레벨의 경우 나선 계단 브러시가 그대로 배치되어 있었고, 문제가 발생하지 않는 레벨에선 나선 계단 브러시로 만들어진 메시를 베이킹하여 스태틱 메시로 배치해두고 있었다.추측하건데, 브러시 액터가 레벨 스트리밍 과정에서 레벨과 함께 회전하지 않고 기본 각도로 배치되었거나(단, 나선 계단 브러시로 block을 수행하므로 플레이어가 걸어 올라갈 수 있는 걸 보면 이 쪽은 확률이 낮다), 네비 메쉬 생성을 위한 데이터만 회전하지 않은 것으로 보인다. 그럼 실제 계단이 보이는 곳엔 네비 메쉬가 만들어지지 않고 마치 네비 메쉬만 회전한 것처럼 엉뚱한 빈 공간에 나선형으로 만들어지는 이유를 설명할 수 있다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/트러블슈팅/(0923)-나선형-계단-nav-mesh-베이킹-문제.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/트러블슈팅/(0923) 나선형 계단 Nav Mesh 베이킹 문제.md</guid><pubDate>Tue, 23 Sep 2025 13:01:37 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프롭 스폰 포인트, 스폰될 액터 미리보기]]></title><description><![CDATA[던전 내부에 배치되어야 하는 일부 프롭들은 NavMesh 기반으로 랜덤 포지션에 생성될 경우 미관상 좋지 않다.
때문에 룸 레벨 내부에 미리 지정된 위치들 중에서 스폰 포지션을 고를 수 있어야 한다는 요청이 있었다.스폰 포인트 액터를 수집하여 임의 시점에 지정된 액터를 스폰하게 하는 것은 어렵지 않다.
다만 스폰 포인트를 배치할 때 배치될 액터가 어떤 크기, 방향으로 배치될 지는 미리 볼 수 있는 것이 좋다.스폰 포인트 액터에 ChildActorComponent를 달아 미리보기를 구현할 것이다.C++1UCLASS()2class FRANKHUNTER_API AFHObjectSpawningPoint : public AActor3{4	GENERATED_BODY()5	...6public:78// 에디터 환경에서만 동작9#if WITH_EDITOR10	TObjectPtr&lt;class UChildActorComponent&gt; PreviewActor;1112	int32 previewIdx{ 0 };13	14	// CallInEditor 옵션은 디테일 창에 호출 버튼을 생성한다. 15	UFUNCTION(CallInEditor)16	void HidePreviewActor();17	UFUNCTION(CallInEditor)18	void ShowPreviewActor();19	20	// 액터를 레벨에 처음 배치할 때, 혹은 배치된 액터의 프로퍼티(transform 포함)가 변할 때 호출된다.21	virtual void OnConstruction(const FTransform&amp; Transform) override;22#endifC++WITH_EDITOR 매크로 내부의 UPROPERTY
기본적으로 언리얼 헤더 툴은 리플렉션 파일(gen.cpp)을 생성하는 과정에서 WITH_EDITOR 매크로를 인식하지 못 한다. 에디터에서만 사용할 데이터인데 리플렉션이 필요하다면 헤더에선 if WITH_EDITORONLY_DATA를 사용하고, 소스 코드에선 if WITH_EDITOR로 사용부를 감싸야 한다.
C++1#if WITH_EDITOR2void AFHObjectSpawningPoint::ShowPreviewActor()3{4	if (!SpawningPointDescriptor) return;5	if (!PreviewActor) return;67	if (previewIdx &gt;= SpawningPointDescriptor-&gt;SpawnableActorList.Num())8	{9 previewIdx = 0;10 return;11	}12	TSubclassOf&lt;AActor&gt; target = SpawningPointDescriptor-&gt;SpawnableActorList[previewIdx].actor;13	PreviewActor-&gt;SetChildActorClass(target);14	PreviewActor-&gt;SetWorldLocationAndRotation(GetActorLocation(), GetActorRotation());15	PreviewActor-&gt;SetWorldScale3D(GetActorScale());1617	++previewIdx;18	if (previewIdx &gt;= SpawningPointDescriptor-&gt;SpawnableActorList.Num())19	{20 previewIdx = 0;21	}22}2324void AFHObjectSpawningPoint::OnConstruction(const FTransform&amp; Transform)25{26	Super::OnConstruction(Transform);2728	if (!PreviewActor) return;29	PreviewActor-&gt;SetWorldLocationAndRotation(GetActorLocation(), GetActorRotation());30	PreviewActor-&gt;SetWorldScale3D(GetActorScale());31}3233void AFHObjectSpawningPoint::HidePreviewActor()34{35	if (!PreviewActor) return;36	PreviewActor-&gt;SetChildActorClass(nullptr);37}38#endif394041AFHObjectSpawningPoint::AFHObjectSpawningPoint()42{43	PrimaryActorTick.bCanEverTick = false;44	...45	46#if WITH_EDITOR47	PreviewActor = CreateDefaultSubobject&lt;UChildActorComponent&gt;(TEXT("PreviewActor"));48#endif49}5051void AFHObjectSpawningPoint::BeginPlay()52{53	Super::BeginPlay();5455#if WITH_EDITOR56	PreviewActor-&gt;SetChildActorClass(nullptr);57#endif58}C++OnConstruction 함수에만 주목하면 된다. 액터가 레벨에 처음 배치되거나 transform을 포함한 액터의 프로퍼티가 변할 때마다 호출되므로 여기서 미리보기용 액터의 위치를 갱신시켜 스포닝 포인트를 따라다니게 해주면 된다.
자식인데 알아서 따라다니는 거 아니냐 싶겠지만, 자식이 부모의 Transform을 상속받는 작업은 Tick에서 일어나므로 에디터에서 즉시 반영하려면 이렇게 해야한다.UChildActorComponent 내부 코드를 보면 SetChildActorClass를 호출할 경우 기존의 ChildActor를 알아서 제거하고 새 ChildActor 인스턴스를 즉시 생성하는 방식인 듯 하다.
따라서 지우고 싶을 땐 SetChildActorClass(nullptr); 만 호출한다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/프롭-스폰-포인트,-스폰될-액터-미리보기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/프롭 스폰 포인트, 스폰될 액터 미리보기.md</guid><pubDate>Tue, 23 Sep 2025 13:00:26 GMT</pubDate></item><item><title><![CDATA[(정리중..) 메타휴먼 다루기]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-메타휴먼-다루기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 메타휴먼 다루기.md</guid><pubDate>Mon, 22 Sep 2025 14:11:25 GMT</pubDate></item><item><title><![CDATA[(정리중..) 아웃라인]]></title><description><![CDATA[<img src="♣vaultstorage/attachment/pasted-image-20250916185719.png" target="_self"><img src="♣vaultstorage/attachment/pasted-image-20250916185723.png" target="_self">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-아웃라인.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 아웃라인.md</guid><pubDate>Mon, 22 Sep 2025 14:11:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(정리중..) 절차적 던전 생성]]></title><description><![CDATA[간략한 전체 플로우<img src="♣vaultstorage/attachment/pasted-image-20250916190930.png" target="_self">
그래프 구성 단계에선 연결 규칙에 따라 룸들을 이어나간다. 배치 우선순위는 배치 준비가 된 필수 룸 → 배치 가능한 후보군 중 배치 점수가 높은 순으로, 던전이 완성되지 않았음에도 더이상 룸을 이어나갈 수 없거나 룸의 개수가 한도에 달했음에도 필수 룸의 배치에 끝내 실패했다면 재생성을 시도하게 된다.
룸 레벨 인스턴싱 단계에선 언리얼의 DynamicLevelStreaming을 통해 룸 레벨을 로드한다. 이 과정에서 룸 내부에 있는 여러 액터들이 초기화된다.
던전 내부 환경 구성 단계에선 완성된 던전 구조에 대해 네비게이션 메쉬를 동적으로 빌드하고, 플레이어가 도달 가능한 곳에 마력석, 함정 등 다양한 프롭을 채워넣는다.
구성이 끝나면 해당 플레이어의 준비 완료 신호를 서버로 전달한다.
가장 많은 공을 들인 부분은 ‘룸’의 가치와 규칙을 정의하는 것. 던전의 구조가 곧 게임의 재미와 밸런스로 직결되므로 밸런스 잡힌 던전을 생성하기 위해 고민했다.예컨대 시작 룸으로부터 멀거나, 룸의 규모가 클 수록 내부에 가치있는 프롭이 스폰될 확률이 증가하며, 크리쳐들은 적당한 긴장감을 주기 위해 순차적으로 플레이어들로부터 멀리 있는 방에서 스폰된다. 여러 종류의 문이나 룸의 디자인에 바리에이션을 줄 수 있도록 해 매번 새로운 던전을 경험하는 감각을 느낄 수 있게 했다.]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-절차적-던전-생성.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 절차적 던전 생성.md</guid><pubDate>Mon, 22 Sep 2025 14:11:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(정리중..) 커스텀 큐]]></title><description><![CDATA[<img src="♣vaultstorage/attachment/pasted-image-20250916185757.png" target="_self">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-커스텀-큐.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 커스텀 큐.md</guid><pubDate>Mon, 22 Sep 2025 14:11:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(정리중..) 커스텀 CameraShake]]></title><description><![CDATA[<img src="♣vaultstorage/attachment/pasted-image-20250916185704.png" target="_self">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-커스텀-camerashake.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 커스텀 CameraShake.md</guid><pubDate>Mon, 22 Sep 2025 14:11:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(정리중..) 플레이어 스탯 관리]]></title><description><![CDATA[<img src="♣vaultstorage/attachment/pasted-image-20250916185744.png" target="_self"><br><img src="♣vaultstorage/attachment/pasted-image-20250916185747.png" target="_self">]]></description><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-플레이어-스탯-관리.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 플레이어 스탯 관리.md</guid><pubDate>Mon, 22 Sep 2025 14:11:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(정리중..) 발소리 구현하기]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-발소리-구현하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 발소리 구현하기.md</guid><pubDate>Sun, 21 Sep 2025 08:10:32 GMT</pubDate></item><item><title><![CDATA[(정리중..) 래그돌에 충격 가하기]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-래그돌에-충격-가하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 래그돌에 충격 가하기.md</guid><pubDate>Sun, 21 Sep 2025 08:10:07 GMT</pubDate></item><item><title><![CDATA[(정리중..) 장비 착용 상태 동기화]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-장비-착용-상태-동기화.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 장비 착용 상태 동기화.md</guid><pubDate>Sun, 21 Sep 2025 08:09:47 GMT</pubDate></item><item><title><![CDATA[(정리중..) 1, 3인칭 분리하기]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-1,-3인칭-분리하기.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 1, 3인칭 분리하기.md</guid><pubDate>Sun, 21 Sep 2025 08:09:20 GMT</pubDate></item><item><title><![CDATA[(정리중..) 동적으로 그려지는 미니맵]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-동적으로-그려지는-미니맵.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 동적으로 그려지는 미니맵.md</guid><pubDate>Sun, 21 Sep 2025 08:09:04 GMT</pubDate></item><item><title><![CDATA[(정리중..) Cloth physics, 깃발]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-cloth-physics,-깃발.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) Cloth physics, 깃발.md</guid><pubDate>Sun, 21 Sep 2025 08:08:52 GMT</pubDate></item><item><title><![CDATA[(정리중..) 상호작용 컴포넌트]]></title><link>0-발행완료/프로젝트/2504_f급헌터생존기/구현-목록/(정리중..)-상호작용-컴포넌트.html</link><guid isPermaLink="false">0 발행완료/프로젝트/2504_F급헌터생존기/구현 목록/(정리중..) 상호작용 컴포넌트.md</guid><pubDate>Tue, 16 Sep 2025 10:23:26 GMT</pubDate></item></channel></rss>