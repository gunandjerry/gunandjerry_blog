<!DOCTYPE html> <html lang="ko"><head>
<title>스레드 2. thread 라이브러리</title>
<base href="../../..">
<meta name="pathname" content="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html">
<meta name="description" content="건제리의 블로그 - 스레드 2. thread 라이브러리">
<meta property="og:title" content="스레드 2. thread 라이브러리">
<meta property="og:description" content="건제리의 블로그 - 스레드 2. thread 라이브러리">
<meta property="og:type" content="website">
<meta property="og:url" content="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html">
<meta property="og:image" content="undefined">
<meta charset="UTF-8"><meta property="og:site_name" content="건제리의 블로그"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0"><script async="" id="webpage-script" src="site-lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-wasm-script" src="site-lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="site-lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="site-lib/media/favicon.png"><link rel="stylesheet" href="site-lib/styles/obsidian.css"><link rel="preload" href="site-lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="site-lib/styles/theme.css"><link rel="preload" href="site-lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="site-lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/supported-plugins.css"></noscript><link rel="preload" href="site-lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/main-styles.css"></noscript><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-vertical-spacing:1.3em;--sidebar-margin:12px}:root{background-color:#202124}.sidebar{height:100%;font-size:14px;z-index:10;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));position:relative;overflow:hidden;overflow:clip;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}#left-sidebar{left:0}#right-sidebar{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}.sidebar.floating{position:absolute}.sidebar .leaf-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .leaf-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}#left-sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}#right-sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar #left-sidebar-content,.sidebar #right-sidebar-content{contain:none!important;container-type:normal!important;animation:none!important}.sidebar:has(.leaf-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:calc(2.3em + 2 * var(--sidebar-margin));width:var(--sidebar-width);padding:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}#left-sidebar .sidebar-topbar{left:0;flex-direction:row;border-top-right-radius:var(--radius-l)}#right-sidebar .sidebar-topbar{right:0;flex-direction:row-reverse;border-top-left-radius:var(--radius-l)}#left-sidebar .topbar-content{margin-right:calc(2.3em + var(--sidebar-margin));flex-direction:row}#right-sidebar .topbar-content{margin-left:calc(2.3em + var(--sidebar-margin));flex-direction:row-reverse}.topbar-content{overflow:hidden visible;overflow:clip visible;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:2px!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}#left-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}#right-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.feature-title{margin-left:1px;text-transform:uppercase;letter-spacing:.06em;margin-top:.75em;margin-bottom:.75em}.feature-header{display:flex;align-items:center;padding-top:0;font-size:1em;padding-left:0}body.floating-sidebars .sidebar{position:absolute}body{transition:background-color var(--color-fade-speed) ease-in-out}#navbar:not(:empty){display:flex;align-items:center;justify-content:space-between;padding:.5em 1em;width:100%}#main{display:flex;flex-direction:column;height:100%;width:100%;align-items:stretch;justify-content:center}#main-horizontal{display:flex;flex-direction:row;flex-grow:1;width:100%;align-items:stretch;justify-content:center}#center-content{flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0!important;transition:opacity .2s ease-in-out;pointer-events:none}#center-content>.obsidian-document{padding-left:2em;padding-right:1em;margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}body #center-content>.obsidian-document>.markdown-preview-sizer{padding-bottom:80vh;width:100%;max-width:var(--line-width);flex-basis:var(--line-width);transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document>div{width:100%!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document:not([data-type=markdown]).embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}#center-content>.obsidian-document:not([data-type=markdown]).embed>*{max-width:100%;max-height:100%;object-fit:contain}:not(h1,h2,h3,h4,h5,h6,li):has(> :is(.math,table)){overflow-x:auto!important}#center-content>.obsidian-document:not([data-type=markdown]){overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.obsidian-document[data-type=attachment]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;width:100%}.obsidian-document[data-type=attachment]>*{outline:0;border:none;box-shadow:none}.obsidian-document[data-type=attachment] :is(img){max-width:90%;max-height:90%;object-fit:contain}.obsidian-document[data-type=attachment]>:is(audio){width:100%;max-width:min(90%,var(--line-width))}.obsidian-document[data-type=attachment]>:is(embed,iframe,video){width:100%;height:100%;max-width:100%;max-height:100%;object-fit:contain}.canvas-wrapper>:is(.header,.footer){z-index:100;position:absolute;display:flex;justify-content:center;flex-direction:column;width:100%;align-items:center}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){let e=document.querySelectorAll("link[itemprop='include']");for(const t of e){let e=t.getAttribute("href");try{let o="";if(e.startsWith("https:")||e.startsWith("http:")||"file:"!=window.location.protocol){const n=await fetch(e);if(!n.ok){console.log("Could not include file: "+e),t?.remove();continue}o=await n.text()}else{const t=document.getElementById(btoa(encodeURI(e)));if(t){const e=JSON.parse(decodeURI(atob(t.getAttribute("value")??"")));o=e?.data??""}}let n=document.createRange().createContextualFragment(o);t.before(n),t.remove(),console.log("Included text: "+o),console.log("Included file: "+e)}catch(o){t?.remove(),console.log("Could not include file: "+e,o);continue}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script")));!function e(n){let l=o[n],c=n+1;l?(l&&"true"!=l.getAttribute("loaded")||n<o.length&&e(c),n<o.length&&l.addEventListener("load",(()=>e(c)))):n<o.length?e(c):t()}(0)}</script></head><body class="publish css-settings-manager is-frameless is-hidden-frameless styled-scrollbars show-inline-title show-ribbon ctp-latte ctp-mocha ctp-accent-sapphire anuppuccin-accent-toggle anp-callout-sleek anp-codeblock-numbers anp-list-toggle anp-table-toggle anp-table-th-highlight anp-h1-red anp-h2-peach anp-h3-green anp-h4-teal anp-h5-lavender anp-h6-mauve anp-decoration-toggle anp-bold-red anp-italic-maroon anp-highlight-yellow anp-file-icons anp-collapse-folders anp-simple-rainbow-color-toggle anp-rainbow-file-toggle anp-simple-rainbow-title-toggle anp-simple-rainbow-collapse-icon-toggle anp-simple-rainbow-indentation-toggle anp-default-tab anp-card-layout is-focused"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="parsed-feature-container" style="display: contents;"><link itemprop="include" href="site-lib/html/custom-head-content-content.html"></div><div id="main"><div id="navbar"></div><div id="main-horizontal"><div id="left-content" class="leaf" style="--sidebar-width: var(--sidebar-width-left);"><div id="left-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><div id="search-container"><div id="search-wrapper"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div aria-label="Clear search" id="search-clear-button"></div></div></div></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="left-sidebar-content" class="leaf-content"><link itemprop="include" href="site-lib/html/file-tree-content.html"></div></div><script defer="">let ls = document.querySelector("#left-sidebar"); ls.classList.toggle("is-collapsed", window.innerWidth < 768); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div></div><div id="center-content" class="leaf"><div class="obsidian-document markdown-preview-view markdown-rendered node-insert-event allow-fold-headings allow-fold-lists show-indentation-guide show-properties is-readable-line-width" data-type="markdown"><style id="MJX-CHTML-styles">mjx-c.mjx-c1D44B.TEX-I::before{padding:.683em .852em 0 0;content:"X"}mjx-c.mjx-c2F::before{padding:.75em .5em .25em 0;content:"/"}mjx-c.mjx-c1D442.TEX-I::before{padding:.704em .763em .022em 0;content:"O"}mjx-c.mjx-c1D462.TEX-I::before{padding:.442em .572em .011em 0;content:"u"}mjx-c.mjx-c1D459.TEX-I::before{padding:.694em .298em .011em 0;content:"l"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c1D45D.TEX-I::before{padding:.442em .503em .194em 0;content:"p"}mjx-c.mjx-c1D44E.TEX-I::before{padding:.441em .529em .01em 0;content:"a"}mjx-c.mjx-c1D466.TEX-I::before{padding:.442em .49em .205em 0;content:"y"}mjx-c.mjx-c1D454.TEX-I::before{padding:.442em .477em .205em 0;content:"g"}mjx-texatom{display:inline-block;text-align:left}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c1D435.TEX-I::before{padding:.683em .759em 0 0;content:"B"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c1D70B.TEX-I::before{padding:.431em .57em .011em 0;content:"π"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c1D440.TEX-I::before{padding:.683em 1.051em 0 0;content:"M"}mjx-c.mjx-c1D43F.TEX-I::before{padding:.683em .681em 0 0;content:"L"}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c2217::before{padding:.465em .5em 0 0;content:"∗"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-c.mjx-c1D451.TEX-I::before{padding:.694em .52em .01em 0;content:"d"}mjx-c.mjx-c1D45C.TEX-I::before{padding:.441em .485em .011em 0;content:"o"}mjx-c.mjx-c1D461.TEX-I::before{padding:.626em .361em .011em 0;content:"t"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c1D449.TEX-I::before{padding:.683em .769em .022em 0;content:"V"}mjx-c.mjx-c1D43E.TEX-I::before{padding:.683em .889em 0 0;content:"K"}mjx-c.mjx-c22C5::before{padding:.31em .278em 0 0;content:"⋅"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c1D452.TEX-I::before{padding:.442em .466em .011em 0;content:"e"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c1D445.TEX-I::before{padding:.683em .759em .021em 0;content:"R"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c38::before{padding:.666em .5em .022em 0;content:"8"}mjx-c.mjx-c1D43C.TEX-I::before{padding:.683em .504em 0 0;content:"I"}mjx-c.mjx-c1D43B.TEX-I::before{padding:.683em .888em 0 0;content:"H"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c35::before{padding:.666em .5em .022em 0;content:"5"}mjx-c.mjx-c34::before{padding:.677em .5em 0 0;content:"4"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-msub{display:inline-block;text-align:left}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("site-lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("site-lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("site-lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("site-lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("site-lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("site-lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("site-lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("site-lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("site-lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("site-lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("site-lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("site-lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("site-lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("site-lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("site-lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("site-lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("site-lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("site-lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("site-lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("site-lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("site-lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("site-lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D453.TEX-I::before{padding:.705em .55em .205em 0;content:"f"}mjx-c.mjx-c1D437.TEX-I::before{padding:.683em .828em 0 0;content:"D"}mjx-c.mjx-c1D439.TEX-I::before{padding:.68em .749em 0 0;content:"F"}mjx-c.mjx-c1D43A.TEX-I::before{padding:.705em .786em .022em 0;content:"G"}</style><div class="markdown-preview-sizer markdown-preview-section"><div class="header"><h1 class="page-title heading inline-title" id="스레드_2._thread_라이브러리_0">스레드 2. thread 라이브러리</h1><div class="data-bar"></div></div><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="el-h1"><h1 data-heading="`std::thread`" dir="auto" class="heading" id="`stdthread`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>std::thread</code></h1></div><div class="el-p"><p dir="auto">C++11에서 추가된 새로운 스레드 표준. OS마다 알아서 다른 함수를 호출해 스레드를 생성한다.<br>
기존의 WinAPI 스레드 함수를 사용하는 것보다 훨씬 편리하다.</p></div><div class="el-p"><p dir="auto">다음과 같이 사용한다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded">std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>진입함수<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 스레드 객체가 생성되는 동시에 새 스레드를 생성한다.</span>

<span class="token comment">// std::thread t; // 혹은 빈 스레드 객체만 만들어놓고</span>
<span class="token comment">// t = std::thread(진입함수); // 나중에 생성해도 된다.</span>

<span class="token comment">// 스레드가 콜백(흐름이 종료되고 호출자에게 반환)될 때까지 대기한다.</span>
t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 스레드를 백그라운드에서 돌아가게 만들고 반환여부를 신경쓰지 않는다.</span>
t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">스레드 객체는 생성과 동시에 동작에 필요한 자원(진입점 정보, 스레드의 스택프레임, 스레드 고유 자원 등등)을 할당받게 되므로 join 또는 detach 중 하나는 반드시 써줘야 안전하게 종료와 함께 자원을 해제할 수 있다.</p></div><div class="el-hr"><hr></div><div class="el-h1"><h1 data-heading="`std::mutex` (`<mutex>`)" dir="auto" class="heading" id="`stdmutex`_(`<mutex>`)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>std::mutex</code> (<code>&lt;mutex&gt;</code>)</h1></div><div class="el-p"><p dir="auto">경쟁 조건(race condition)에 놓인 메모리의 배타적 사용을 위한 커널 뮤텍스 객체의 래퍼.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded">std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span> <span class="token comment">// 커널 뮤텍스 오브젝트 생성.</span>

m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 현재 스레드에 의한 락</span>

<span class="token comment">// 경쟁 자원에 접근</span>
<span class="token comment">// 여길 임계 영역(critical section 이라고 함)</span>

m<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 락 해제</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">한 스레드에서 같은 뮤텍스 객체의 lock()을 호출할 경우 뮤텍스 객체를 해당 스레드가 점유하게 되면서, 다른 스레드는 먼저 점유한 스레드가 unlock()을 할 때까지 대기하게 된다.</p></div><div class="el-p"><p dir="auto">흔히 헷갈리는 것은 둘 이상의 스레드가 함께 lock()과 unlock() 사이에 있는 임계영역에 들어갈 수도 있지 않냐는 것인데, 스레드가 동시에 작동하고 있다고 하더라도 m.lock()에 의해 커널 객체의 점유권이 이양되는 동작은 한 번에 하나만 일어나기 때문에, 가장 먼저 접근한 스레드만 이를 받을 수 있으므로 그런 일은 생기지 않는다.</p></div><div class="el-p"><p dir="auto">std::mutex는 교착상태를 수습하기 위한 함수로 try_lock()을 제공한다. 아무도 해당 뮤텍스를 점유하고 있지 않다면 락을 걸고 true를 반환하고, 누군가 이미 락을 걸고 있으면 false를 반환한다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span>mutex<span class="token operator">&amp;</span> m1<span class="token punctuation">,</span> mutex<span class="token operator">&amp;</span> m2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	m1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	m2<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// Do Something</span>
	
	m2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	m1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span>mutex<span class="token operator">&amp;</span> m1<span class="token punctuation">,</span> mutex<span class="token operator">&amp;</span> m2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	m2<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>m1<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		m2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// Do Something</span>
	
	m1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	m2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">이러면 무조건 Func1을 돌리는 스레드가 우선권을 얻게 되기 때문에 교착상태는 일어나지 않는다. 그러나 이런식으로 스레드간의 우선순위를 정하는 방식으로 교착상태를 막게 되면, 경우에 따라 어떤 스레드는 다른 스레드에게 순서를 빼앗겨 거의 혹은 절대로 경쟁자원에 접근할 수 없는 상태가 될 수 있는데, <strong>이를 기아 상태(Starvation) 문제</strong>라고 한다.</p></div><div class="el-div"><div data-callout-metadata="" data-callout-fold="" data-callout="note" class="callout"><div class="callout-title" dir="auto"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-pencil"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">교착상태를 예방하는 법</div></div><div class="callout-content">
<ol>
<li data-line="1" dir="auto">중첩된 Lock의 사용을 최대한 피한다. 대부분의 경우 설계가 문제지 사실은 Lock 하나만으로 충분히 구현할 수 있다. 애초에 Lock이 하나면 모든 스레드가 동일한 Lock에 대해 획득을 시도하므로 절대로 교착상태가 일어나지 않는다.</li>
<li data-line="2" dir="auto">중첩된 Lock을 사용할 수밖에 없다면, 반드시 정해진 순서대로 획득하고, 그 역순으로 해제한다.</li>
</ol>
</div></div></div><div class="el-h3"><h3 data-heading="동시에 락 걸기: `std::lock`" dir="auto" class="heading" id="동시에_락_걸기_`stdlock`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>동시에 락 걸기: <code>std::lock</code></h3></div><div class="el-p"><p dir="auto">만약 A가 B에게 돈을 송금하고, B가 A에게 돈을 송금하는 상황이 동시에 발생하면 어떻게 될까?</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&amp;</span> from<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&amp;</span> to<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	from<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	to<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 대충 전송을 처리하는 코드</span>

	to<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	from<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>mutex A<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>mutex B<span class="token punctuation">;</span>
	
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>transfer<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>transfer<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">스레드 t1이 from(A)를 잠구고 to(B)를 잠구려고 시도할 때, 이미 스레드 t2가 from(B)를 잠구고 to(A)를 잠구려고 시도하고 있었다면, 데드락이 발생한다.<br>
따라서 이런 상황에선 두 뮤텍스를 동시에 잠궈야 한다. 이 때 사용하는 함수가 std::lock이다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>mutex from<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>mutex to<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span><span class="token function">lock</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 대충 전송을 처리하는 코드</span>

	to<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	from<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">이러면 두 상호배제 객체가 동시에 락이 걸리기 때문에 한 스레드가 일부만 락을 거는 상황은 발생하지 않는다.</p></div><div class="el-h3"><h3 data-heading="락 가드(Lock guard))" dir="auto" class="heading" id="락_가드(Lock_guard))_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>락 가드(Lock guard))</h3></div><div class="el-p"><p dir="auto">std::mutex는 unlock()을 잊으면 대참사가 나기 때문에, 스마트 포인터처럼 스택을 벗어날 때 알아서 unlock()을 호출하는 방법이 몇 가지 있다.</p></div><div class="el-h5"><h5 data-heading="`std::lock_guard<T>`" dir="auto" class="heading" id="`stdlock_guard<T>`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>std::lock_guard&lt;T&gt;</code></h5></div><div class="el-p"><p dir="auto">상호배제 객체를 담아서 생성하는 순간 해당 객체를 통해 락을 걸고, 스택프레임이 풀릴 때 언락을 하는 객체. 임의로 언락을 하는 방법은 없다.</p></div><div class="el-h5"><h5 data-heading="`std::scoped_lock<T>`" dir="auto" class="heading" id="`stdscoped_lock<T>`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>std::scoped_lock&lt;T&gt;</code></h5></div><div class="el-p"><p dir="auto">여러 개의 상호배제 객체를 담아서 생성할 수 있는 락 가드. 언락을 할 땐 락을 건 역순으로 풀어서 데드락이 발생하지 않게 한다. 마찬가지로 임의로 언락을 하는 방법은 없다.</p></div><div class="el-h5"><h5 data-heading="`std::unique_lock<T>`" dir="auto" class="heading" id="`stdunique_lock<T>`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>std::unique_lock&lt;T&gt;</code></h5></div><div class="el-p"><p dir="auto">아마 가장 많이 사용할 락 가드. 기본적으로 <code>std::lock_guard</code>와 같지만 언제든지 임의로 락을 풀고 다른 상호배제 객체를 넣고 임의로 락을 걸 수 있다. 즉, 스택프레임이 사라질 때 현재 가지고 있는 객체를 언락시킨다는 걸 빼면 그냥 std::mutex랑 다름 없다.<br>
참고로 두 번째 매개변수로 <code>std::defer_lock</code>을 전달하면 unique_lock을 생성하는 시점에서 락을 걸지 않고 나중에 .lock() 메서드나 std::lock()을 통해 락을 걸게 할 수 있다. 근데 이럴 거면 그냥 std::mutex를 직접 쓰는 게 낫지 않을까?</p></div><div class="el-hr"><hr></div><div class="el-h1"><h1 data-heading="`std::condition_variable` (`<condition_variable>`)" dir="auto" class="heading" id="`stdcondition_variable`_(`<condition_variable>`)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>std::condition_variable</code> (<code>&lt;condition_variable&gt;</code>)</h1></div><div class="el-p"><p dir="auto">이벤트 커널 객체로 스레드를 깨우는 것과 유사한 방식으로 락을 대기시키는 객체. 내부적으론 SleepConditionalVariableSRW로 구현되어 있다고 한다. 그런데 SRWLock은 일정 주기로 체크하는 방식으로 알고있는데, 이건 notify()로 깨우는 방식이라 다르지 않나?</p></div><div class="el-p"><p dir="auto">예컨대 다음과 같은 생성자-소비자 패턴 코드가 있다고 하자.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">void</span> <span class="token function">Produce</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token operator">&amp;</span> jobs<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&amp;</span> mtx<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 대충 일할 거리 구해다가 jobs 큐에 집어넣는 코드</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Consume</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token operator">&amp;</span> jobs<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&amp;</span> mtx<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>jobs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 할 일이 없으면</span>
		<span class="token punctuation">{</span>
			mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 락을 풀고</span>
			std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">miliseconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10ms동안 대기</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">// 대충 jobs에서 일감을 꺼내서 처리하는 코드</span>
		
		mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">여러 개의 워커 스레드가 각각 Consume()을 돌린다고 해보자. 현재는 jobs에 일감이 없으면 스레드는 10ms동안 대기하고 다시 뮤텍스의 락을 시도하게 된다. 이렇게 매번 락을 걸었다가, 풀었다가, 다시 시도하는 방식은 CPU 자원을 매우 비효율적으로 낭비하는 행위다.</p></div><div class="el-p"><p dir="auto">이것보단 스레드를 대기시켜놓고, jobs에 일감이 들어오면 순서대로 깨우는 것이 좋을 것이다.</p></div><div class="el-p"><p dir="auto">std::condition_variable 객체를 사용하면 이를 아주 쉽게 구현할 수 있다. 바뀐 코드를 보자.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">void</span> <span class="token function">Produce</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token operator">&amp;</span> jobs<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&amp;</span> mtx<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>conditional_variable<span class="token operator">&amp;</span> cv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 대충 일할 거리 구해다가 jobs 큐에 집어넣는 코드</span>
	
	cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 잠자고 있는 스레드 중 가장 먼저 재워진 스레드를 깨운다.</span>
	<span class="token comment">// cv.notify_all(); // 이건 해당 cv에 의해 재워진 모든 스레드를 깨우는 함수.</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Consume</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token operator">&amp;</span> jobs<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&amp;</span> mtx<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>conditional_variable<span class="token operator">&amp;</span> cv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// std::lock_guard와 비슷하게 생성과 동시에 락을 걸고 소멸될 때 unlock을 하는 lock wrapping 객체. 다만 std::lock_guard는 생성밖에 못 하는데 얘는 생성 후에도 unlock, lock이 자유롭다.</span>
		<span class="token comment">// 여기선 cv.wait이 unique_lock을 매개변수로 받기 때문에 사용했다.</span>
		std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 두 번째 매개변수에 전달되는 조건이 false라면 락을 풀고 스레드의 경동맥을 졸라서 잠재운다.</span>
		<span class="token comment">// 이후 notify()류 함수에 의해 스레드가 깨어나면 다시 조건 함수를 체크하고, 이 때 true로 바뀌었다면 락을 걸고 진행한다. 여전히 false를 반환한다면 다시 잠든다.</span>
		cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>jobs<span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span>jobs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 대충 jobs에서 일감을 꺼내서 처리하는 코드</span>
		
		lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">위 코드는 매우 단순한 형태임을 명심하자. 여러 개의 생산자, 소비자 스레드가 동시에 생성되었을 때, 소비자 스레드의 입장에선 jobs가 비었으면 cv.wait에 의해 대기 상태가 되고, 생산자 입장에선 jobs에 일감을 하나 넣었다면 최소한 하나의 일감이 있음이 보장되므로 잠자고 있는 스레드 하나를 깨워서 일을 시킨다.</p></div><div class="el-p"><p dir="auto">std::conditional_variable에는 다음과 같은 함수들이 있다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token comment">// 기본 대기, 조건이 참이면 그대로 넘어가고, 거짓이면 락을 푼 뒤 notify_one 또는 notify_all에 의해 깨어날 때까지 대기한다. 깨어나면 락을 걸고 진행된다. (물론, notify_all에 의해 여러 스레드가 같은 위치에서 깨어나면 선행 스레드가 락을 풀 때까지 대기한다.)</span>
cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>락<span class="token punctuation">,</span> 조건<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 시간 제한이 있는 대기. 기본적으로 wait과 동일하게 작동하나, 대기할 경우 notify에 의해 깨어나지 않더라도 지정된 시간이 지나면 자동으로 깨어난다.</span>
<span class="token comment">// 스레드 스케줄링 오버헤드 등에 의해 실제 대기 시간이 정확하지가 않다. 이건 Sleep과 같이 스레드를 재우고 깨우는 함수 모두에 해당되는 얘기다.</span>
cv<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>락<span class="token punctuation">,</span> 시간<span class="token punctuation">(</span>chrono<span class="token punctuation">)</span><span class="token punctuation">,</span> 조건<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 특점 시점까지만 대기. 기본적으로 wait_for와 동일하게 작동하나, wait_for가 '일정 시간 동안'만 대기하는 거라면 이건 '특정 시간 까지'만 대기하는 것이다.</span>
cv<span class="token punctuation">.</span><span class="token function">wait_until</span><span class="token punctuation">(</span>락<span class="token punctuation">,</span> 시간<span class="token punctuation">(</span>chorono<span class="token punctuation">)</span><span class="token punctuation">,</span> 조건<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// cv.wait류 함수에 의해 대기하고 있는 스레드 중 가장 먼저 잠재운 스레드 하나를 깨운다.</span>
cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// cv.wait류 함수에 의해 대기하고 있는 모든 스레드를 깨운다.</span>
cv<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">주의할 점은 cv.wait의 두 번째 매개변수인 predicate 함수는 처음 wait() 함수를 만났을 때, 그리고 스레드가 notify()에 의해 깨어났을 때마다 한 번씩 호출되어 조건 함수로 쓰인다는 점이다.<br>
그래서 만약 predicate 함수 내부에서 종료 조건을 따로 체크하지 않으면 스레드가 영원히 잠들게 되는 수가 있다. 보통 스레드를 종료시키기 전에 종료 플래그를 켜고, notify_all()을 호출해 모든 스레드가 깨어나도록 한 뒤 return할 때까지 기다리는 방식을 많이 사용하는데, predicate 함수 내부에서 종료 조건을 설정했을 때 탈출하지 못 하도록 로직이 짜여져 있으면 다시 잠들 뿐이라는 것.</p></div><div class="el-hr"><hr></div><div class="el-h1"><h1 data-heading="std::future &amp; std::promise (`<future>`)" dir="auto" class="heading" id="stdfuture_&amp;_stdpromise_(`<future>`)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>std::future &amp; std::promise (<code>&lt;future&gt;</code>)</h1></div><div class="el-p"><p dir="auto">쉬운 비동기 처리를 위한 객체. 동작 과정은 다음과 같다.</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">std::promise 객체가 <strong>미래에 어떤 값을 주겠다고</strong> 약속(promise) 한다.</li>
<li data-line="1" dir="auto">std::future 객체는 <strong>미래에 어떤 값을 받겠다</strong>는 의미로 그 약속을 받는다.</li>
<li data-line="2" dir="auto">std::future 객체는 wait() 함수로 <strong>약속이 이루어질 때까지 대기</strong>한다.</li>
<li data-line="3" dir="auto"><strong>std::promise 객체에 값이 담기면</strong>, 이 값이 future에게 전달되며 future의 대기가 끝난다.</li>
</ol></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">void</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> pm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1초간 대기하고</span>
	pm<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// promise 객체에 값을 담을 것</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pm<span class="token punctuation">;</span>
	
	<span class="token comment">// 미래에 값을 주겠다고 약속함</span>
	std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ft <span class="token operator">=</span> pm<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 워커 스레드에서 1초 후 pm에 값을 대입</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>DoSomething<span class="token punctuation">,</span> pm<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 약속이 이행될 때까지 대기</span>
	ft<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// pm이 값을 전달해주면 ft의 대기가 끝남</span>

	<span class="token comment">// get()으로 전달을 약속받았던 값을 얻을 수 있다.</span>
	<span class="token comment">// 참고로, wait() 없이 그냥 get()만 호출해도 값이 담길 때까지 대기한다.</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>std::future.get()</code>은 값을 이동으로 반환하므로 두 번 호출할 수 없다.<br>
conditional_variable을 쓰거나 thread만 써도 이런 동작을 구현할 수는 있지만, promise - future를 사용하는 게 훨씬 간단하고 직관적이다. 더욱이 <code>promise.set_value()</code> 말고도 <code>promise.set_exception()</code> 으로 예외를 전달하는 등 써먹을 방법이 많다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded">p<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

f<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
	f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get을 할 때 실제로 예외가 던져진다.</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>std::conditional_variable</code>과 마찬가지로 wait_for 문을 지원한다. 기본 동작은 wait()과 같고, 대기할 경우 지정된 시간 동안만 기다렸다가 <code>std::future_status::timeout</code>을 반환하고 넘어간다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded">std<span class="token double-colon punctuation">::</span>future_status status <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3"><h3 data-heading="std::shared_future" dir="auto" class="heading" id="stdshared_future_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>std::shared_future</h3></div><div class="el-p"><p dir="auto"><code>std::future::get()</code>은 기본적으로 값을 이동시키므로 한 번만 호출할 수 있다고 했는데, 이건 이동이 아니라 스마트 포인터처럼 내부 주소값을 전달해 참조하게 하므로 <code>get()</code>을 여러 번 호출할 수 있다.<br>
여러 스레드에서 동일한 future 객체의 값을 참조하는 경우에 사용한다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded">std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sf <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 사용법은 동일</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>DoSomething<span class="token punctuation">,</span> sf<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>DoSomething<span class="token punctuation">,</span> sf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3"><h3 data-heading="std::packaged_task" dir="auto" class="heading" id="stdpackaged_task_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>std::packaged_task</h3></div><div class="el-p"><p dir="auto"><code>std::function</code>처럼 Callable을 담는 객체. 그런데 promise-future 패턴을 내부에서 구현한다.<br>
<code>std::packaged_task</code> 그 자체는 Callable을 담으면서 동시에 <code>std::promise</code>처럼 쓰여 get_future()를 호출해 약속을 하고, Callable이 리턴하는 값을 set_value()로 넣는 것처럼 future에 전달한다.<br>
쉽게 말해 들고있는 콜백 함수의 반환값으로 set_value()를 하는 promise라고 생각하면 된다.</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">int</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>DoSomething<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 복사생성이 불가능</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"결과값: "</span> <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	
	t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">8번 라인에 <code>std::thread</code>를 생성하면서 <code>std::packaged_task</code> 객체를 이동시키고 있는데, 그 이유는 다음과 같다.</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">기본적으로 <code>std::packaged_task</code>는 내부에 Callable과 연결된 <code>std::promise</code> 객체를 가지고 있다. 따라서 자기가 가리키는 함수 포인터만 전달할 수 없고 통채로 전달해야 한다.</li>
<li data-line="1" dir="auto">그런데 <code>std::packaged_task</code>가 복사로 전달되면 <code>std::promise</code> 도 복사되는 등 참사가 일어나므로 복사생성이 불가능하다.</li>
<li data-line="2" dir="auto">따라서 <code>std::move</code>로 감싸 이동을 시켜야만 한다.</li>
</ol></div><div class="el-h3"><h3 data-heading="std::async" dir="auto" class="heading" id="stdasync_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>std::async</h3></div><div class="el-p"><p dir="auto">극한까지 추상화되어 <code>std::promise</code> 객체와 함수를 바인딩하고 스레드를 생성해 해당 함수를 호출하고 <code>std::future</code> 객체에게 반환을 약속하는 것까지 전부 해주는 함수.<br>
함수 포인터를 넣어도 되고 람다를 넣어도 된다.</p></div><div class="el-p"><p dir="auto">함수 포인터 전달</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">int</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token keyword">int</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// std::async 호출과 동시에 새 스레드가 생성된다.</span>
<span class="token comment">// 리턴값을 전달받을 것을 약속받은 std::future 객체를 반환한다.</span>
std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> DoSomething<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

f<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">첫 번째 인자는 어떤 형태로 실행할 지를 결정하는데 사용된다.<br>
(1) std::launch::async : 즉시 스레드를 생성, 인자로 전달된 함수를 실행하도록 한다.<br>
(2) std::launch::deferred : future의 get() 함수가 호출될 때 동기적으로 실행된다. (왜 있지 이거?)</p></div><div class="el-p"><p dir="auto">람다식 전달</p></div><div class="el-pre"><pre class="language-cpp"><code data-line="0" class="language-cpp is-loaded">std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="footer"><div class="data-bar"></div></div></div></div></div><div id="right-content" class="leaf" style="--sidebar-width: var(--sidebar-width-right);"><div id="right-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme-toggle-input" id=""><input class="theme-toggle-input" type="checkbox" id="theme-toggle-input"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="right-sidebar-content" class="leaf-content"><div class="graph-view-wrapper"><div class="feature-header"><div class="feature-title">Interactive Graph</div></div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<div class="graph-icon graph-global" role="button" aria-label="Global Graph" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-git-fork"><circle cx="12" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><circle cx="18" cy="6" r="3"></circle><path d="M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9"></path><path d="M12 12v3"></path></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div id="outline" class=" tree-container"><div class="feature-header"><div class="feature-title">Table Of Contents</div><button class="clickable-icon nav-action-button tree-collapse-all" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#스레드_2._thread_라이브러리_0" data-path="#스레드_2._thread_라이브러리_0"><div class="tree-item-inner heading-link" heading-name="스레드 2. thread 라이브러리">스레드 2. thread 라이브러리</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#`stdthread`_0" data-path="#`stdthread`_0"><div class="tree-item-inner heading-link" heading-name="`std::thread`"><code>std::thread</code></div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#`stdmutex`_(`<mutex>`)_0" data-path="#`stdmutex`_(`<mutex>`)_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="`std::mutex` (`<mutex>`)"><code>std::mutex</code> (<code>&lt;mutex&gt;</code>)</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#동시에_락_걸기_`stdlock`_0" data-path="#동시에_락_걸기_`stdlock`_0"><div class="tree-item-inner heading-link" heading-name="동시에 락 걸기: `std::lock`">동시에 락 걸기: <code>std::lock</code></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#락_가드(Lock_guard))_0" data-path="#락_가드(Lock_guard))_0"><div class="tree-item-inner heading-link" heading-name="락 가드(Lock guard))">락 가드(Lock guard))</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#`stdlock_guard<T>`_0" data-path="#`stdlock_guard<T>`_0"><div class="tree-item-inner heading-link" heading-name="`std::lock_guard<T>`"><code>std::lock_guard&lt;T&gt;</code></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#`stdscoped_lock<T>`_0" data-path="#`stdscoped_lock<T>`_0"><div class="tree-item-inner heading-link" heading-name="`std::scoped_lock<T>`"><code>std::scoped_lock&lt;T&gt;</code></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#`stdunique_lock<T>`_0" data-path="#`stdunique_lock<T>`_0"><div class="tree-item-inner heading-link" heading-name="`std::unique_lock<T>`"><code>std::unique_lock&lt;T&gt;</code></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#`stdcondition_variable`_(`<condition_variable>`)_0" data-path="#`stdcondition_variable`_(`<condition_variable>`)_0"><div class="tree-item-inner heading-link" heading-name="`std::condition_variable` (`<condition_variable>`)"><code>std::condition_variable</code> (<code>&lt;condition_variable&gt;</code>)</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#stdfuture_&amp;_stdpromise_(`<future>`)_0" data-path="#stdfuture_&amp;_stdpromise_(`<future>`)_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="std::future &amp; std::promise (`<future>`)">std::future &amp; std::promise (<code>&lt;future&gt;</code>)</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#stdshared_future_0" data-path="#stdshared_future_0"><div class="tree-item-inner heading-link" heading-name="std::shared_future">std::shared_future</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#stdpackaged_task_0" data-path="#stdpackaged_task_0"><div class="tree-item-inner heading-link" heading-name="std::packaged_task">std::packaged_task</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="0-발행완료/c,-c++/시스템/스레드-2.-thread-라이브러리.html#stdasync_0" data-path="#stdasync_0"><div class="tree-item-inner heading-link" heading-name="std::async">std::async</div></a><div class="tree-item-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector("#right-sidebar"); rs.classList.toggle("is-collapsed", window.innerWidth < 768); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></div></div></body></html>